<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar32.jpg?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar16.jpg?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="CPU结构CPU（中央处理器）的结构是计算机系统的核心部分，负责执行各种指令和处理数据。现代CPU结构通常由多个复杂的子系统组成，这些子系统共同协作以实现高效的计算。以下是CPU结构的主要组成部分及其功能： 算术逻辑单元ALU，Arithmetic Logic Unit  功能：ALU 是CPU中执行算术和逻辑运算的核心部分。它负责处理整数加法、减法、乘法、除法以及逻辑运算（如与、或、非、异或等）">
<meta name="keywords" content="搭建博客,前端">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程基本概念">
<meta property="og:url" content="https://userzhang.tk/p/8vugj/index.html">
<meta property="og:site_name" content="魔圣的博客">
<meta property="og:description" content="CPU结构CPU（中央处理器）的结构是计算机系统的核心部分，负责执行各种指令和处理数据。现代CPU结构通常由多个复杂的子系统组成，这些子系统共同协作以实现高效的计算。以下是CPU结构的主要组成部分及其功能： 算术逻辑单元ALU，Arithmetic Logic Unit  功能：ALU 是CPU中执行算术和逻辑运算的核心部分。它负责处理整数加法、减法、乘法、除法以及逻辑运算（如与、或、非、异或等）">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192335920.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191854010.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192341949.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192343116.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211948847.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212021496.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212027272.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212107085.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212138072.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212139546.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212140423.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212142102.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212142597.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212146003.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212147868.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211652379.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211522431.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211523466.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211454363.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211455767.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211455781.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211542620.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211545787.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191745877.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192253053.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192254977.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190849514.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190851685.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190852270.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191958517.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192010738.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/393192/1650080165361-18864833-42e6-47a3-beb0-d97886e8fe71.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408201047785.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408201757013.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221514463.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221514464.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221515767.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221516077.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221517247.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221517407.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221519084.png">
<meta property="og:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221519846.png">
<meta property="og:updated_time" content="2024-08-23T00:50:10.789Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发编程基本概念">
<meta name="twitter:description" content="CPU结构CPU（中央处理器）的结构是计算机系统的核心部分，负责执行各种指令和处理数据。现代CPU结构通常由多个复杂的子系统组成，这些子系统共同协作以实现高效的计算。以下是CPU结构的主要组成部分及其功能： 算术逻辑单元ALU，Arithmetic Logic Unit  功能：ALU 是CPU中执行算术和逻辑运算的核心部分。它负责处理整数加法、减法、乘法、除法以及逻辑运算（如与、或、非、异或等）">
<meta name="twitter:image" content="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192335920.png">





  
  
  <link rel="canonical" href="https://userzhang.tk/p/8vugj/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>java并发编程基本概念 | 魔圣的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">魔圣的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://userzhang.tk/p/8vugj/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="魔圣">
      <meta itemprop="description" content="二十四桥明月夜，玉人何处教吹箫">
      <meta itemprop="image" content="/images/photo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="魔圣的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java并发编程基本概念

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2024-08-11 00:19:17" itemprop="dateCreated datePublished" datetime="2024-08-11T00:19:17+08:00">2024-08-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2024-08-23 08:50:10" itemprop="dateModified" datetime="2024-08-23T08:50:10+08:00">2024-08-23</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h1><p>CPU（中央处理器）的结构是计算机系统的核心部分，负责执行各种指令和处理数据。现代CPU结构通常由多个复杂的子系统组成，这些子系统共同协作以实现高效的计算。以下是CPU结构的主要组成部分及其功能：</p>
<h3 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h3><p>ALU，Arithmetic Logic Unit</p>
<ul>
<li><strong>功能</strong>：ALU 是CPU中执行算术和逻辑运算的核心部分。它负责处理整数加法、减法、乘法、除法以及逻辑运算（如与、或、非、异或等）。</li>
<li><strong>作用</strong>：执行基本的计算任务，比如加法、减法、乘法等，是处理器执行程序的基础。</li>
</ul>
<h3 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h3><p>CU，Control Unit</p>
<ul>
<li><strong>功能</strong>：控制单元负责指挥CPU的操作，协调各个部分的工作。它通过从内存中读取指令，并根据指令控制其他组件执行相应的操作。</li>
<li><strong>作用</strong>：解码指令，控制数据流动和指令执行的顺序，协调CPU内部各部分的工作。</li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>Registers</p>
<ul>
<li><strong>功能</strong>：寄存器是CPU内部用于临时存储数据和指令的高速存储器。寄存器的存取速度极快，通常用来保存正在处理的数据或指令的地址。</li>
<li><strong>作用</strong>：存储CPU当前操作的数据、指令或其他临时信息，提高处理效率。</li>
<li>常见寄存器：<ul>
<li><strong>通用寄存器</strong>：用于存储一般性数据，例如累加器（Accumulator）。</li>
<li><strong>专用寄存器</strong>：用于特定目的，如程序计数器（PC）存储当前指令的地址，堆栈指针（SP）管理堆栈内存。</li>
</ul>
</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Cache</p>
<ul>
<li><strong>功能</strong>：缓存是位于CPU与主内存之间的小容量但高速的存储器，用于存储频繁访问的数据和指令。</li>
<li><strong>作用</strong>：减少CPU访问主内存的时间，提升整体处理速度。</li>
<li>层次：<ul>
<li><strong>L1缓存</strong>：最接近CPU核心，速度最快，容量最小。</li>
<li><strong>L2缓存</strong>：速度稍慢于L1，容量较大。</li>
<li><strong>L3缓存</strong>：速度最慢但容量最大，用于多个核心共享。</li>
</ul>
</li>
</ul>
<h3 id="总线接口单元"><a href="#总线接口单元" class="headerlink" title="总线接口单元"></a>总线接口单元</h3><p>BIU，Bus Interface Unit</p>
<ul>
<li><strong>功能</strong>：BIU负责在CPU和其他系统组件（如内存、I/O设备）之间传输数据。它管理CPU与外部设备之间的通信，确保数据能够顺利进出处理器。</li>
<li><strong>作用</strong>：连接CPU与外部设备，传递指令和数据。</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li><strong>功能</strong>：前端是处理器获取和解码指令的部分。它负责从内存中获取指令，并将其解码成可执行的微操作。</li>
<li>组成部分：<ul>
<li><strong>指令提取单元</strong>：从内存或缓存中获取指令。</li>
<li><strong>指令解码单元</strong>：将指令翻译成CPU可以执行的微指令。</li>
<li><strong>分支预测单元</strong>：预测程序执行中可能的分支路径，以减少处理器等待时间。</li>
</ul>
</li>
</ul>
<h3 id="执行单元"><a href="#执行单元" class="headerlink" title="执行单元"></a>执行单元</h3><ul>
<li><strong>功能</strong>：执行单元负责执行已经解码的指令。它包括ALU、浮点单元（FPU）、加载/存储单元等。</li>
<li><strong>作用</strong>：完成算术运算、逻辑运算、浮点运算，以及内存访问等操作。</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul>
<li><strong>功能</strong>：后端负责指令的最终执行和结果的写回。它包括寄存器重命名、指令调度等部分。</li>
<li>组成部分：<ul>
<li><strong>寄存器重命名</strong>：消除数据依赖冲突，提高指令执行效率。</li>
<li><strong>指令调度器</strong>：根据执行单元的可用性，调度指令的执行顺序。</li>
</ul>
</li>
</ul>
<h3 id="浮点单元"><a href="#浮点单元" class="headerlink" title="浮点单元"></a>浮点单元</h3><p>FPU</p>
<ul>
<li><strong>功能</strong>：FPU专门用于处理浮点运算，如小数和科学计数法的计算。与整数运算不同，浮点运算涉及更复杂的数学计算。</li>
<li><strong>作用</strong>：加速处理浮点数运算，特别是在图形处理、科学计算等领域。</li>
</ul>
<h3 id="分支预测单元"><a href="#分支预测单元" class="headerlink" title="分支预测单元"></a>分支预测单元</h3><ul>
<li><strong>功能</strong>：分支预测单元用于预测程序执行中的分支结果（例如，if-else语句中的路径选择），以减少流水线停顿和指令执行延迟。</li>
<li><strong>作用</strong>：通过预测程序分支，减少不必要的计算浪费，提高指令执行效率。</li>
</ul>
<h3 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h3><p>MMU</p>
<ul>
<li><strong>功能</strong>：MMU负责管理虚拟内存地址与物理内存地址之间的映射，处理内存保护、分页等功能。</li>
<li><strong>作用</strong>：支持虚拟内存，管理内存访问权限，提升系统的内存使用效率和安全性。</li>
</ul>
<h3 id="输入输出控制器"><a href="#输入输出控制器" class="headerlink" title="输入输出控制器"></a>输入输出控制器</h3><ul>
<li><strong>功能</strong>：I/O控制器管理CPU与外围设备（如硬盘、键盘、显示器等）之间的数据交换。</li>
<li><strong>作用</strong>：控制输入和输出操作，管理外设的通信。</li>
</ul>
<h3 id="时钟与控制逻辑"><a href="#时钟与控制逻辑" class="headerlink" title="时钟与控制逻辑"></a>时钟与控制逻辑</h3><ul>
<li><strong>功能</strong>：时钟逻辑为CPU提供时间基准，控制逻辑确保各个部分按正确顺序执行操作。</li>
<li><strong>作用</strong>：同步CPU内部各个部分的工作，确保操作按预定时间进行。</li>
</ul>
<h3 id="现代CPU架构特点"><a href="#现代CPU架构特点" class="headerlink" title="现代CPU架构特点"></a>现代CPU架构特点</h3><ul>
<li><strong>多核架构</strong>：现代CPU通常包含多个核心（Core），每个核心都是一个完整的处理单元，可以独立执行指令。多核设计可以提高并行处理能力。</li>
<li><strong>超标量架构</strong>：允许CPU在同一个时钟周期内执行多条指令，通过多个执行单元实现指令级并行。</li>
<li><strong>超线程技术（Hyper-Threading）</strong>：通过硬件虚拟化，允许每个物理核心同时处理多个线程，提高并行处理能力。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CPU结构包含了多个子系统，这些子系统紧密协作，共同执行复杂的计算任务。从基本的算术逻辑单元和控制单元，到高级的缓存和多核架构，每个部分都在优化计算性能和效率方面发挥着重要作用。理解这些组件及其功能，有助于更好地理解处理器的工作原理和性能特点。</p>
<p>java集合</p>
<p>ArrayList. 10.    1.5倍</p>
<p>FailFast   </p>
<p>ArrayList有modCount. 迭代器创建时有expectedModCount 在迭代器调用next()方法时会判断二者是否相等,不等会抛出ConcurrentModificationException异常</p>
<p>FailSafe. </p>
<p>CopyOnWriteArrayList. 写时复制 迭代器遍历的是旧数组</p>
<p>添加元素是新建了一个新数组,在新数组中添加</p>
<p>而且next()方法没有expectedModCount,也不检查二者是否相等</p>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>Java 作为一门广泛应用于企业级应用开发的编程语言，为了保障程序的稳定性和安全性，通常限制了开发者对底层内存和硬件的直接访问。然而，Java 中的 <code>Unsafe</code> 类却为开发者提供了一种突破这些限制的方式，让他们可以<strong>直接操作内存、线程和对象</strong>，同时也引发了一系列潜在的风险和挑战</p>
<h2 id="反射获取Unsafe对象"><a href="#反射获取Unsafe对象" class="headerlink" title="反射获取Unsafe对象"></a>反射获取Unsafe对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(unsafe);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取域的偏移地址</span></span><br><span class="line">        <span class="keyword">long</span> idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">"id"</span>));</span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">// 2. 执行 cas 操作</span></span><br><span class="line">        unsafe.compareAndSwapInt(t, idOffset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        unsafe.compareAndSwapObject(t, nameOffset, <span class="keyword">null</span>, <span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192335920.png" alt="image-20240819233521731"></p>
<h2 id="Unsafe实现原子整数"><a href="#Unsafe实现原子整数" class="headerlink" title="Unsafe实现原子整数"></a>Unsafe实现原子整数</h2><p>封装获取Unsafe对象的工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNSAFE = UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = <span class="keyword">this</span>.value;</span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAtomicInteger</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java创建进程方式"><a href="#java创建进程方式" class="headerlink" title="java创建进程方式"></a>java创建进程方式</h1><p>在Java中，可以使用 <code>ProcessBuilder</code> 或 <code>Runtime</code> 类来创建和管理进程。以下是两种方法的示例：</p>
<h3 id="1-使用-ProcessBuilder"><a href="#1-使用-ProcessBuilder" class="headerlink" title="1. 使用 ProcessBuilder"></a>1. 使用 <code>ProcessBuilder</code></h3><p><code>ProcessBuilder</code> 提供了更灵活的方式来创建和管理进程。可以设置环境变量、工作目录等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessBuilderExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ProcessBuilder 实例</span></span><br><span class="line">        ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置要执行的命令</span></span><br><span class="line">        processBuilder.command(<span class="string">"notepad.exe"</span>); <span class="comment">// Windows 示例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选：设置工作目录</span></span><br><span class="line">        <span class="comment">// processBuilder.directory(new File("path/to/your/directory"));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动进程</span></span><br><span class="line">            Process process = processBuilder.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待进程结束</span></span><br><span class="line">            <span class="keyword">int</span> exitCode = process.waitFor();</span><br><span class="line">            System.out.println(<span class="string">"Exited with code: "</span> + exitCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-Runtime"><a href="#2-使用-Runtime" class="headerlink" title="2. 使用 Runtime"></a>2. 使用 <code>Runtime</code></h3><p><code>Runtime</code> 类提供了一个更简单的方式来执行命令，但不如 <code>ProcessBuilder</code> 灵活。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 Runtime 执行命令</span></span><br><span class="line">            Process process = Runtime.getRuntime().exec(<span class="string">"notepad.exe"</span>); <span class="comment">// Windows 示例</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待进程结束</span></span><br><span class="line">            <span class="keyword">int</span> exitCode = process.waitFor();</span><br><span class="line">            System.out.println(<span class="string">"Exited with code: "</span> + exitCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>命令的路径</strong>：确保要执行的命令在系统的 PATH 环境变量中，或者提供完整路径。</li>
<li><strong>处理输入输出</strong>：可以通过 <code>Process</code> 对象获取进程的输入流、输出流和错误流，以便进行更复杂的交互。</li>
<li><strong>异常处理</strong>：要处理 <code>IOException</code> 和 <code>InterruptedException</code>，以确保程序的健壮性。</li>
</ol>
<p>以上示例展示了如何在Java中创建和管理进程。根据具体需求，可以选择使用 <code>ProcessBuilder</code> 或 <code>Runtime</code>。</p>
<h1 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h1><p>进程通信（Inter-Process Communication, IPC）是指不同进程之间交换数据和信息的方式。在操作系统中，由于进程之间的内存空间是独立的，因此需要一些机制来实现它们之间的通信。以下是几种常见的进程通信方式：</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li><strong>无名管道</strong>：用于具有亲缘关系的进程（如父子进程）之间的通信。数据在管道中是单向流动的。</li>
<li><strong>命名管道</strong>：可以在没有亲缘关系的进程之间进行通信，使用文件系统中的名称来标识。</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>通过一个消息队列，进程可以发送和接收消息。消息队列允许进程以异步方式进行通信，支持优先级。</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li>进程可以共享一块内存区域，以便快速交换数据。共享内存的效率很高，但需要通过其他同步机制（如信号量）来控制对共享内存的访问。</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>信号量是一种用于控制对共享资源访问的同步机制。它可以用于进程间的协调和同步。</li>
</ul>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><ul>
<li>套接字可以用于同一台机器上的进程间通信，也可以用于不同机器上的进程间通信。常见于网络编程。</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>信号是一种异步通信机制，允许一个进程向另一个进程发送通知。信号可以用于处理异常情况或通知特定事件的发生。</li>
</ul>
<h3 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h3><ul>
<li>RPC 允许程序在不同的地址空间（通常是不同的机器）上调用另一个程序的子程序或服务。</li>
</ul>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ul>
<li>通过将文件映射到进程的地址空间，多个进程可以共享数据。适合于大数据量的共享。</li>
</ul>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul>
<li>进程可以通过读写文件来进行通信。虽然效率较低，但实现简单且可用于持久化数据。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>不同的进程通信方式各有优缺点，选择合适的通信方式通常取决于应用场景、性能需求和复杂性。</p>
<h1 id="匿名管道和命名管道区别"><a href="#匿名管道和命名管道区别" class="headerlink" title="匿名管道和命名管道区别"></a>匿名管道和命名管道区别</h1><p>命名管道和匿名管道是两种不同类型的管道，用于进程间通信（IPC）。它们之间有几个主要区别：</p>
<h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><ul>
<li><strong>命名管道</strong>：有一个特定的名称，可以在文件系统中查看和访问。进程可以通过这个名称来打开和使用管道。</li>
<li><strong>匿名管道</strong>：没有名称，通常只能在创建它的进程及其子进程之间使用。它们存在于进程的内存中，无法在文件系统中找到。</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><strong>命名管道</strong>：可以在不相关的进程之间通信，因为它们是通过名称来引用的。</li>
<li><strong>匿名管道</strong>：通常用于父子进程之间的通信，因为它们只能在创建它的进程及其子进程之间使用。</li>
</ul>
<h3 id="创建和使用"><a href="#创建和使用" class="headerlink" title="创建和使用"></a>创建和使用</h3><ul>
<li><strong>命名管道</strong>：需要使用特定的系统调用（如 <code>mkfifo</code> 或 <code>CreateNamedPipe</code>）来创建，并且可以在多个进程中打开和使用。</li>
<li><strong>匿名管道</strong>：使用简单的系统调用（如 <code>pipe()</code>）来创建，通常在进程创建时使用。</li>
</ul>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><ul>
<li><strong>命名管道</strong>：在进程结束后仍然存在，直到显式删除。</li>
<li><strong>匿名管道</strong>：在创建它的进程结束后，管道也会被销毁。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>命名管道</strong>适用于需要跨多个不相关进程进行通信的场景，具有持久性和可命名性。</li>
<li><strong>匿名管道</strong>则更适合父子进程之间的简单、临时通信。</li>
</ul>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><ol>
<li>继承Thread</li>
</ol>
<p>Thread t=new Thread()</p>
<ol>
<li>实现Runnable接口 实现run方法</li>
</ol>
<p>Thread t=new Thread(Runnable r)</p>
<ol>
<li>FutureTask</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191854010.png" alt="image-20240819185433268"></p>
<ul>
<li><p>FutureTask实现了Runnable接口和Future接口,内部有一个Callable接口的引用</p>
<ul>
<li>Future接口 get方法阻塞获取值. 内部用park. 这个返回值是FutureTask的outcome</li>
<li>Callable接口。定义基本逻辑 和返回值</li>
</ul>
</li>
<li><p>FutureTask的run()执行逻辑</p>
<ul>
<li>在run方法中调用Callable接口的call,设置outcome变量为Callable接口的返回值,run方法执行最后会调用unpark,唤醒调用get方法的线程</li>
</ul>
</li>
</ul>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>Java线程6种</p>
<p><strong>六种状态及转换</strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192341949.png" alt="image-20240819234137720"></p>
<p>分别是</p>
<ul>
<li>新建<ul>
<li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li>
<li>此时未与操作系统底层线程关联</li>
</ul>
</li>
<li>可运行<ul>
<li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li>
<li>此时与底层线程关联，由操作系统调度执行</li>
</ul>
</li>
<li>终结<ul>
<li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li>
<li>此时会取消与底层线程关联</li>
</ul>
</li>
<li>阻塞<ul>
<li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li>
<li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li>
</ul>
</li>
<li>等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
<li>有时限等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
</ul>
<p><strong><em>其它情况</em></strong></p>
<ul>
<li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li>
<li>park，unpark 等方法也可以让线程等待和唤醒</li>
</ul>
<p>操作系统5种</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192343116.png" alt="image-20240819234324890"></p>
<ul>
<li>运行态：分到 cpu 时间，能真正执行线程内代码的</li>
<li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li>
<li>阻塞态：没资格分到 cpu 时间的<ul>
<li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li>
<li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li>
</ul>
</li>
<li>新建与终结态：与 java 中同名状态类似</li>
</ul>
<p>查看线程状态 getState()</p>
<h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><p>线程使用cpu 到不使用cpu会发生上下文切换。操作系统需要保存线程状态。 恢复另一个线程的状态</p>
<h1 id="Java对象内存布局和对象头"><a href="#Java对象内存布局和对象头" class="headerlink" title="Java对象内存布局和对象头"></a>Java对象内存布局和对象头</h1><h2 id="对象在堆内存中布局"><a href="#对象在堆内存中布局" class="headerlink" title="对象在堆内存中布局"></a>对象在堆内存中布局</h2><p>对象内部结构分为：对象头、实例数据、对齐填充（保证8个字节的倍数）。 对象头分为对象标记（markOop）和类元信息（klassOop），类元信息存储的是指向该对象类元数据（klass）的首地址</p>
<p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节</p>
<p>指针压缩</p>
<p> 默认存储对象的HashCode、分代年龄和锁标志位等信息</p>
<h4 id="对象头多大"><a href="#对象头多大" class="headerlink" title="对象头多大"></a>对象头多大</h4><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存放类的属性(Field)数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存占4字节。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐。</p>
<p>markword(64位)分布图</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211948847.png" alt="image-20240821194834567"></p>
<p>Synchronized 即使发生上下文切换。另外的线程也不能执行代码会处于阻塞状态</p>
<h2 id="Synchronized的性能变化"><a href="#Synchronized的性能变化" class="headerlink" title="Synchronized的性能变化"></a>Synchronized的性能变化</h2><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的<br>Mark Word 中就被设置指向 Monitor 对象的指针</p>
<p>java5以前，只有Synchronized，这个是操作系统级别的重量级操作，重量级锁，假如锁的竞争比较激烈的话，性能下降</p>
<p>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p>
<p> 在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因 Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p>
<p>Mutex Lock Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所以synchronized是Java语言中的一个重量级操作。</p>
<p>Monitor与java对象以及线程是如何关联 ？ 1.如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址 2.Monitor的Owner字段会存放拥有相关联对象锁的线程id</p>
<p>Mutex Lock 的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。</p>
<p>Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"10进制hash码："</span>+o.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"16进制hash码："</span>+Integer.toHexString(o.hashCode()));</span><br><span class="line">        System.out.println(<span class="string">"2进制hash码："</span>+Integer.toBinaryString(o.hashCode()));</span><br><span class="line"></span><br><span class="line">        System.out.println( ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212021496.png" alt="image-20240821202136373"></p>
<p>不开启指针压缩是16个字节,这里默认开启所以对象头12个字节,最后是填充4字节达到8字节的整数倍16</p>
<p>第一个字节01如下图所示</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212027272.png" alt="image-20240821202744146"></p>
<p>然后是hashcode,倒着读每1个字节,共有31位</p>
<p>4b1210ee -&gt;ee 10 12 4b</p>
<p>对象头最高25位是unused,4b的最高位是0所以hashcode也是4b,而且之后都是00</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的出现是为了解决只有在一个线程执行同步时提高性能</p>
<p>54位线程id</p>
<p>通过CAS方式修改markword中的线程ID,之后直接比较线程ID是否相等</p>
<p>技术实现： 一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还 会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向本身的ID，无需再进入 Monitor 去竞争对象了。</p>
<p>一个对象创建时：</p>
<ul>
<li><p>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的</p>
<p>thread、epoch、age 都为 0</p>
</li>
<li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -</p>
<p>XX:BiasedLockingStartupDelay=0 来禁用延迟</p>
</li>
<li><p>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、</p>
<p>age 都为 0，第一次用到 hashcode 时才会赋值</p>
</li>
</ul>
<p>偏向锁JVM命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial |grep BiasedLock*</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 实际上偏向锁在JDK1.6之后是默认开启的，但是启动时间有延迟，</span><br><span class="line">* 所以需要添加参数-XX:BiasedLockingStartupDelay=0，让其在程序启动时立刻启动。</span><br><span class="line">*</span><br><span class="line">* 开启偏向锁：</span><br><span class="line">* -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br><span class="line">*</span><br><span class="line">* 关闭偏向锁：关闭之后程序默认会直接进入------------------------------------------&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   轻量级锁状态。</span><br><span class="line">* -XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>
<p>调用hashCode 会撤销偏向锁 到无锁状态。markword存不下线程id(和hashCode冲突)</p>
<p>轻量级锁不会 hashCode存在栈帧锁记录 解锁再恢复hashCode</p>
<p>重量级锁hashCode存在monitor对象。解锁再恢复hashCode</p>
<p>Wait notify 是重量级锁的,调用就变成重量级锁</p>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁</p>
<p>竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。</p>
<blockquote>
<p>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。 撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行：</p>
<p>① 第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。 此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。 ② 第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。</p>
</blockquote>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212107085.png" alt="image-20240821210751004"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以<br>使用轻量级锁来优化</p>
<p>栈帧创建锁记录（Lock Record）对象(jvm层面的)，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p>
<h4 id><a href="#" class="headerlink" title></a><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212138072.png" alt="image-20240821213844962"></h4><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212139546.png" alt="image-20240821213950449"></p>
<p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212140423.png" alt="image-20240821214022316"></p>
<ul>
<li>如果 cas 失败，有两种情况<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212142102.png" alt="image-20240821214226940"></p>
<p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重<br>入计数减一</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212142597.png" alt="image-20240821214253495"></p>
<ul>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，</p>
<p>这时使用 cas 将 Mark Word 的值恢复给对象头</p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<p>栈帧创建锁记录对象(jvm层面的)。锁记录对象有 对象指针 锁记录地址</p>
<p>对象指针指向锁对象</p>
<p>锁记录地址 cas 对象头的markword.   交换。表示加锁</p>
<p>成功后锁记录的锁记录地址存的是原来的markword,对象头的markword存的是锁记录的地址</p>
<p>赋值锁记录。 对象的markword指针指向</p>
<p>锁膨胀</p>
<p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212146003.png" alt="image-20240821214636908"></p>
<ul>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212147868.png" alt="image-20240821214748726"></p>
<p>自旋优化</p>
<p>升级重量级锁之前进行</p>
<h4 id="轻量锁与偏向锁的区别和不同"><a href="#轻量锁与偏向锁的区别和不同" class="headerlink" title="轻量锁与偏向锁的区别和不同"></a>轻量锁与偏向锁的区别和不同</h4><p>争夺轻量级锁失败时，自旋尝试抢占锁</p>
<p>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁(全局安全点)</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>偏向锁:适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法/代码块则使用偏向锁。 轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法/代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。 重量级锁：适用于竞争激烈的情况，如果同步方法/代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</p>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><p>减少上锁时间<br>同步代码块中尽量短</p>
<p>减少锁的粒度<br>将一个锁拆分为多个锁提高并发度，例如：</p>
<ul>
<li>ConcurrentHashMap</li>
<li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li>
<li>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</li>
</ul>
<p>锁粗化<br>多次循环进入同步块不如同步块内多次循环<br>另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，<br>没必要重入多次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> StringBuffer().append(<span class="string">"a"</span>).append(<span class="string">"b"</span>).append(<span class="string">"c"</span>);</span><br></pre></td></tr></table></figure>
<p>锁消除<br>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候<br>就会被即时编译器忽略掉所有同步操作。</p>
<p>读写分离<br>CopyOnWriteArrayList<br>ConyOnWriteSet</p>
<h2 id="JIT编译器对锁的优化"><a href="#JIT编译器对锁的优化" class="headerlink" title="JIT编译器对锁的优化"></a>JIT编译器对锁的优化</h2><p>锁消除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁消除</span></span><br><span class="line"><span class="comment"> * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，</span></span><br><span class="line"><span class="comment"> * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockClearUPDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();<span class="comment">//正常的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//锁消除,JIT会无视它，synchronized(对象锁)不存在了。不正常的</span></span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"-----hello LockClearUPDemo"</span>+<span class="string">"\t"</span>+o.hashCode()+<span class="string">"\t"</span>+objectLock.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LockClearUPDemo demo = <span class="keyword">new</span> LockClearUPDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                demo.m1();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁粗化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁粗化</span></span><br><span class="line"><span class="comment"> * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，</span></span><br><span class="line"><span class="comment"> * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBigDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"11111"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"22222"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"33333"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"a"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"44444"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"55555"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"66666"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"b"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h1 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h1><p>2个线程互相改变对方结束条件,最后谁也无法结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">"count: &#123;&#125;"</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">"count: &#123;&#125;"</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h1><p>线程优先级太低,得不到cpu,自己又在死等</p>
<p>读写锁有饥饿问题</p>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>线程安全是指在多线程环境中，多个线程同时访问某个资源（例如变量、数据结构或对象）时，能够正确地操作该资源而不会导致数据不一致,如果一段代码有多个线程同时进入可能会导致数据不一致就有线程安全问题,要加同步代码块synchronized等方式解决.</p>
<h3 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h3><ol>
<li><strong>互斥锁（Mutex）</strong>：使用互斥锁来保护共享资源，确保同一时间只有一个线程可以访问该资源。</li>
<li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享数据，但在写入时会阻止其他线程的读取和写入。</li>
<li><strong>原子操作（Atomic Operations）</strong>：使用原子操作来确保某些操作在执行时不会被中断，从而避免数据竞争。</li>
<li><strong>线程局部存储（Thread Local Storage）</strong>：为每个线程分配独立的存储空间，避免共享状态。</li>
<li><strong>不可变对象（Immutable Objects）</strong>：使用不可变对象，确保对象在创建后不会被修改，从而避免并发问题。</li>
</ol>
<p><strong>成员变量和静态变量是否线程安全？</strong></p>
<ul>
<li>如果它们没有共享，则线程安全 </li>
<li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 </p>
</li>
<li><ul>
<li>如果只有读操作，则线程安全 </li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里的共享指被多个线程访问</p>
</blockquote>
<p><strong>局部变量是否线程安全？</strong> </p>
<ul>
<li>局部变量是线程安全的 </li>
<li><p>但局部变量引用的对象则未必 </p>
</li>
<li><ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的 </li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>主要是看这段代码是否有共享(被多线程访问) ,并且有多线程读写(如果全是读操作没有线程安全问题)</p>
<h3 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h3><ul>
<li>String </li>
<li>Integer </li>
<li>StringBuffer </li>
<li>Random </li>
<li>Vector </li>
<li>Hashtable </li>
<li>java.util.concurrent 包下的类</li>
</ul>
<blockquote>
<p>线程安全类的组合调用方法不是线程安全的</p>
</blockquote>
<ul>
<li>它们的每个方法是原子的 </li>
<li>但<strong>注意</strong>它们多个方法的组合不是原子的，见后面分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">"key"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    table.put(<span class="string">"key"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211652379.png" alt="image-20240821165240117"></p>
<h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 </p>
<p>对String修改的replace,substring等方法都是创建新对象,也就是对象内部的状态不会改变</p>
<p>无状态类也是线程安全的(没有成员变量)</p>
<h1 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h1><p>关于打断的三个方法</p>
<ul>
<li><p>Thread.interrupted() 静态方法。返回当前打断标记。 但是会清除打断标记。也就是下次获取是false</p>
</li>
<li><p>isInterrupted  返回当前打断标记。 不会清除打断标记</p>
</li>
<li><p>interrupt(). 打断线程,对于正在运行线程和处于waiting状态线程效果不同</p>
</li>
</ul>
<p>interrupt()打断正常运行状态线程,不抛出异常,记录打断标记为true</p>
<p>interrupt()打断waiting状态线程</p>
<ul>
<li><p>sleep.  抛出异常 打断标记清除</p>
</li>
<li><p>park. 不抛出异常 打断标记不清除。 再次park会失败,需要人为清除打断标记</p>
</li>
</ul>
<h1 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h1><p>需要和同步块结合使用。 </p>
<p>正确用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">  <span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">      lock.wait();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//干活</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    改变条件,使前面的线程条件成立</span><br><span class="line">  	lock.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能存在虚假唤醒,  虽然唤醒了但是条件不满足还是会执行lock.wait();继续处于waiting状态</p>
<p>要用多把锁,一个锁一个条件</p>
<p>同步块中不要用sleep代替wait sleep不释放锁</p>
<p>sleep和wait都释放cpu,wait会释放锁但是sleep不释放锁</p>
<h1 id="park-amp-unpark"><a href="#park-amp-unpark" class="headerlink" title="park&amp;unpark"></a>park&amp;unpark</h1><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"start..."</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">"park..."</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">"resume..."</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">"unpark..."</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻</p>
<ul>
<li><p>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中</p>
<p>的备用干粮（0 为耗尽，1 为充足）</p>
</li>
<li><p>调用 park 就是要看需不需要停下来歇息</p>
<ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ul>
</li>
<li><p>调用 unpark，就好比令干粮充足</p>
<ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ul>
<li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="await-amp-signal"><a href="#await-amp-signal" class="headerlink" title="await&amp;signal"></a>await&amp;signal</h1><p>和ReentrantLock.lock   ReentrantLock.unlock配合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition c=lock.newCondition();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//c.await();</span></span><br><span class="line">  <span class="comment">//c.signal();</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h1><h2 id="顺序打印"><a href="#顺序打印" class="headerlink" title="顺序打印"></a>顺序打印</h2><p>先打印2后打印1</p>
<h3 id="wait-amp-notify-1"><a href="#wait-amp-notify-1" class="headerlink" title="wait &amp;notify"></a>wait &amp;notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 表示 t2 是否运行过</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> t2runned = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!t2runned) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">"1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">"2"</span>);</span><br><span class="line">                t2runned = <span class="keyword">true</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="park-amp-unpark-1"><a href="#park-amp-unpark-1" class="headerlink" title="park&amp;unpark"></a>park&amp;unpark</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">"1"</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"2"</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h2><h3 id="wait-amp-notify-2"><a href="#wait-amp-notify-2" class="headerlink" title="wait &amp;notify"></a>wait &amp;notify</h3><p>线程1输出a 5次</p>
<p>线程2输出b 5次</p>
<p>线程3输出c 5次</p>
<p>要求输出abcabcabcabcabc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify wn = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">"a"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">"b"</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">"c"</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出内容       等待标记     下一个标记</span></span><br><span class="line"><span class="comment">   a           1             2</span></span><br><span class="line"><span class="comment">   b           2             3</span></span><br><span class="line"><span class="comment">   c           3             1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印               a           1             2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotify</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始标记设置为1,线程1等待标记为1先打印a,再将标记设置为2</p>
<p>线程2等待标记为2打印b,再将标记设置为3</p>
<p>线程3等待标记为3打印c,再将标记设置为1</p>
<h3 id="await-amp-signal-1"><a href="#await-amp-signal-1" class="headerlink" title="await.&amp;signal"></a>await.&amp;signal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a = awaitSignal.newCondition();</span><br><span class="line">        Condition b = awaitSignal.newCondition();</span><br><span class="line">        Condition c = awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">"a"</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">"b"</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">"c"</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始..."</span>);</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition current, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="park-amp-unpack"><a href="#park-amp-unpack" class="headerlink" title="park&amp;unpack"></a>park&amp;unpack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test31</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark pu = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">"a"</span>, t2);</span><br><span class="line">        &#125;);</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">"b"</span>, t3);</span><br><span class="line">        &#125;);</span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">"c"</span>, t1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="两阶段终止"><a href="#两阶段终止" class="headerlink" title="两阶段终止"></a>两阶段终止</h1><p>利用停止标记(volatile修饰)</p>
<p> 初始为false</p>
<p>其他线程终止设置停止标记为true</p>
<p>当前线程判断停止标记为true则终止当前线程</p>
<p>利用打断标记</p>
<p>interrupt打断,</p>
<p>线程在可运行状态记录打断标记可以设置终止动作</p>
<p>线程在waiting状态会抛出异常,清除打断标记.我们可以catch异常设置打断标记为true,设置终止动作</p>
<h1 id="保护性暂停模式"><a href="#保护性暂停模式" class="headerlink" title="保护性暂停模式"></a>保护性暂停模式</h1><p>同步模式,一个线程拿另一个线程的结果 </p>
<p>Wait&amp;notify</p>
<h1 id="同步模式之-Balking-犹豫"><a href="#同步模式之-Balking-犹豫" class="headerlink" title="同步模式之 Balking(犹豫)"></a>同步模式之 Balking(犹豫)</h1><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来表示是否已经有线程已经在执行启动了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> starting;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"尝试启动监控线程..."</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真正启动监控线程...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它还经常用来实现线程安全的单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。</p>
<h1 id="CPU流水线和指令级并行"><a href="#CPU流水线和指令级并行" class="headerlink" title="CPU流水线和指令级并行"></a>CPU流水线和指令级并行</h1><p>CPU流水线和指令级并行（Instruction-Level Parallelism, ILP）是现代处理器设计中提升性能的关键技术。它们通过并行执行指令来加快指令处理速度。下面将分别解释这两个概念。</p>
<h2 id="1-CPU流水线（Pipeline）"><a href="#1-CPU流水线（Pipeline）" class="headerlink" title="1. CPU流水线（Pipeline）"></a>1. <strong>CPU流水线（Pipeline）</strong></h2><p>流水线是一种通过将指令的执行过程分成多个阶段，并让多个指令在不同阶段并行处理的技术。它类似于生产线上的流水作业，可以显著提高CPU的指令处理速度。</p>
<h3 id="流水线的基本工作原理："><a href="#流水线的基本工作原理：" class="headerlink" title="流水线的基本工作原理："></a>流水线的基本工作原理：</h3><ul>
<li><strong>分阶段执行</strong>：指令的执行被分解为多个阶段，例如取指令、解码、执行、存储结果等。每个阶段由不同的硬件单元负责。</li>
<li><strong>并行处理</strong>：不同的指令可以同时在流水线的不同阶段中执行。比如，当一条指令在执行阶段时，另一条指令可以在取指阶段，这样在一个时钟周期内处理多条指令。</li>
</ul>
<h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><p>假设一条指令的执行被分为以下5个阶段：</p>
<ol>
<li><strong>取指令（IF）</strong></li>
<li><strong>解码（ID）</strong></li>
<li><strong>执行（EX）</strong></li>
<li><strong>访存（MEM）</strong></li>
<li><strong>写回（WB）</strong></li>
</ol>
<p>在传统的非流水线处理器中，这5个阶段是顺序执行的，需要5个时钟周期来完成一条指令。而在流水线处理器中，当第一条指令进入第二阶段时，第二条指令已经进入了第一阶段。这样，当流水线填满时，每个时钟周期都可以完成一条指令，显著提高了指令处理的吞吐量。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><strong>提高指令吞吐量</strong>：流水线可以让CPU在每个时钟周期执行一条指令，从而大幅度提高了指令的执行速度。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><strong>流水线阻塞</strong>：如果某条指令需要等待数据（如数据依赖），整个流水线可能会被阻塞，影响性能。</li>
</ul>
<h2 id="2-指令级并行（ILP）"><a href="#2-指令级并行（ILP）" class="headerlink" title="2. 指令级并行（ILP）"></a>2. <strong>指令级并行（ILP）</strong></h2><p>指令级并行指的是通过并行执行多条不相关指令（即指令之间没有数据依赖关系），进一步提高CPU的效率。ILP可以通过硬件和软件两种方式来实现。</p>
<h3 id="ILP的实现方式："><a href="#ILP的实现方式：" class="headerlink" title="ILP的实现方式："></a>ILP的实现方式：</h3><ul>
<li><strong>硬件支持的并行</strong>：超标量处理器是硬件实现ILP的典型例子。它们可以在同一个时钟周期内同时执行多条指令。CPU内部有<strong>多个执行单元</strong>，可以并行处理多条指令。</li>
<li><strong>编译器优化</strong>：编译器可以在编译时重新排列指令的顺序，使得更多的指令可以并行执行。通过消除指令之间的依赖关系，编译器可以提高程序的并行性。</li>
</ul>
<h3 id="举例说明：-1"><a href="#举例说明：-1" class="headerlink" title="举例说明："></a>举例说明：</h3><p>假设有以下两条指令：</p>
<ol>
<li>加法：<code>R1 = R2 + R3</code></li>
<li>乘法：<code>R4 = R5 * R6</code></li>
</ol>
<p>这两条指令之间没有依赖关系，可以并行执行。如果CPU有两个执行单元，那么可以同时执行这两条指令，而不必等待加法指令完成再执行乘法指令。</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><strong>提高指令并行度</strong>：ILP使得多个指令可以同时执行，提高了CPU的利用率和整体性能。</li>
</ul>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><strong>复杂性增加</strong>：实现高效的ILP需要复杂的硬件和编译器支持，可能会增加功耗和设计难度。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li><strong>流水线</strong>通过分阶段并行处理指令，提升了指令的执行速度，是一种垂直的并行处理方式。</li>
<li><strong>指令级并行</strong>通过并行执行不同指令，进一步提高了处理器的性能，是一种横向的并行处理方式。</li>
</ul>
<p>两者结合起来，可以显著提高CPU的整体性能。</p>
<h2 id="CPU执行单元"><a href="#CPU执行单元" class="headerlink" title="CPU执行单元"></a>CPU执行单元</h2><p>CPU的执行单元数量取决于其架构和设计。执行单元是处理器内部负责执行指令的功能模块，<strong>不同类型</strong>的执行单元负责不同的任务。常见的执行单元包括整数运算单元、浮点运算单元、加载/存储单元等。现代高性能CPU通常具有<strong>多个执行单元</strong>，以实现指令级并行和提高处理效率。</p>
<h3 id="不同类型的执行单元："><a href="#不同类型的执行单元：" class="headerlink" title="不同类型的执行单元："></a>不同类型的执行单元：</h3><ol>
<li><strong>整数运算单元（Integer Execution Units）</strong>：负责处理整数运算，如加法、减法、逻辑运算等。</li>
<li><strong>浮点运算单元（Floating-Point Units, FPU）</strong>：负责处理浮点数运算，如小数计算、科学计算等。</li>
<li><strong>加载/存储单元（Load/Store Units）</strong>：负责处理内存数据的加载和存储操作。</li>
<li><strong>分支执行单元（Branch Execution Units）</strong>：负责处理分支指令，如条件跳转和循环控制。</li>
<li><strong>向量执行单元（Vector Execution Units）</strong>：负责处理SIMD（单指令多数据）操作，用于并行处理多个数据点，常用于多媒体、图形计算。</li>
</ol>
<h2 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h2><p>现代 CPU 支持<strong>多级指令流水线</strong>，例如支持同时执行 <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理器，就可以称之为<strong>五级指令流水线</strong>。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率</p>
<p>下面5条指令</p>
<ol>
<li><strong>取指令（IF）</strong></li>
<li><strong>解码（ID）</strong></li>
<li><strong>执行（EX）</strong></li>
<li><strong>访存（MEM）</strong></li>
<li><strong>写回（WB）</strong></li>
</ol>
<p>这5个阶段就对应着CPU不同的执行单元,可以在支持流水线的处理器中同时执行</p>
<ul>
<li>第1条指令的WB阶段</li>
<li>第2条指令的MEM阶段</li>
<li>第3条指令的EX阶段</li>
<li>第4条指令的ID阶段</li>
<li>第5条指令的IF阶段</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211522431.png" alt="image-20240821152233123"></p>
<p>大多数处理器包含多个执行单元，并不是所有计算功能都集中在一起，可以再细分为整数运算单元、浮点数运算单 </p>
<p>元等，这样可以把多条指令也可以做到并行获取、译码等，CPU 可以在一个时钟周期内，执行多于一条指令，IPC&gt; 1</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211523466.png" alt="image-20240821152353243"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h4 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h4><p>CPU的执行单元数量取决于其架构和设计。执行单元是处理器内部负责执行指令的功能模块，<strong>不同类型</strong>的执行单元负责不同的任务。常见的执行单元包括整数运算单元、浮点运算单元、加载/存储单元等。现代高性能CPU通常具有<strong>多个执行单元</strong>，以实现指令级并行和提高处理效率。</p>
<h4 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h4><p>编译器可以在编译时重新排列指令的顺序，使得更多的指令可以并行执行。通过消除指令之间的依赖关系，编译器可以提高程序的并行性。</p>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><h2 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h2><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211454363.png" alt="image-20240821145440983"></p>
<ol>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211455767.png" alt="image-20240821145526492"></p>
<ol>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211455781.png" alt="image-20240821145546591"></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>使用volatile（易变关键字） </p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p>
<p>一个写线程写volatile变量，多个读线程读volatile变量可以获取最新值</p>
<p>这个例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性， 也就是 volatile 可以处理可见性问题,但不能处理原子性问题</p>
<p>程安全时举的例子：两个线程一个 i++ 一个 i— ，只能保证看到最新值，不能解决指令交错</p>
<h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>指令重排的前提是，重排指令不能影响结果，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以重排的例子</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// 指令2</span></span><br><span class="line">System.out.println( a + b );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能重排的例子</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="keyword">int</span> b = a - <span class="number">5</span>; <span class="comment">// 指令2</span></span><br></pre></td></tr></table></figure>
<p>为什么要有重排指令这项优化呢？从 CPU 执行指令的原理来理解一下吧,可以看前面介绍的指令级并行</p>
<h2 id="指令重排序导致诡异的结果"><a href="#指令重排序导致诡异的结果" class="headerlink" title="指令重排序导致诡异的结果"></a>指令重排序导致诡异的结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//这里可能发生指令重排序</span></span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？ </p>
<p>有同学这么分析 </p>
<ul>
<li>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1 </li>
<li>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支,结果为1 </li>
<li>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了） </li>
</ul>
<p>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！ </p>
<p>这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2 </p>
<p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，指令重排单线程没有问题,多线程就会出现问题了</p>
<p>这个现象需要通过大量测试才能复现</p>
<p>可以借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>volatile 修饰的变量，可以禁用指令重排</p>
<h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><p>volatile 修饰的变量可以保证可见性和有序性,但不能保证原子性(不同线程间指令交错)</p>
<h2 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a>volatile保证可见性</h2><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li><strong>对 volatile 变量的 写指令后会加入写屏障 :</strong> 保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对 volatile 变量的 读指令前会加入读屏障 :</strong> 在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>写屏障是本线程的volatile写操作和之前的写操作对其他线程可见</p>
</li>
<li><p>读屏障是其他线程的写操作对当前线程可见</p>
</li>
</ol>
<h2 id="volatile保证有序性"><a href="#volatile保证有序性" class="headerlink" title="volatile保证有序性"></a>volatile保证有序性</h2><ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211542620.png" alt="image-20240821154222396"></p>
<p>不能解决指令交错： </p>
<ul>
<li><p>写屏障仅仅是保证之后的volatile读和volatile读之后的读操作能够读到最新的结果，</p>
<p>但不能保证别的线程的读操作不会跑到它前面去,拿着旧数据操作设置回主存会🈶️丢失更新的情况</p>
</li>
<li><p>而有序性的保证也只是保证了本线程内相关代码不被重排序</p>
</li>
</ul>
<h3 id="volatile应用"><a href="#volatile应用" class="headerlink" title="volatile应用"></a><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211545787.png" alt="image-20240821154505562">volatile应用</h3><p>线程安全的双重检查锁单例模式用到了volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>INSTANCE = new Singleton();有三条指令</p>
<ol>
<li><p>分配内存</p>
</li>
<li><p>调用Singleton()构造函数</p>
</li>
<li><p>给INSTANCE赋值</p>
</li>
</ol>
<p>这三条指令会发生重排序,就可能会导致2,3颠倒顺序,这时INSTANCE!=null但是还没有调用Singleton()构造函数,假设此时另一个线程在第一个if条件进行判断发现INSTANCE!=null就会返回一个未经过调用Singleton()构造函数的对象,这是不符合预期的.</p>
<p>可以用volatile修饰,这样第三条指令就是volatile变量的写操作,volatile禁止指令重排序,2,3不会颠倒顺序就不会发生上述情况</p>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><h2 id="CAS概述"><a href="#CAS概述" class="headerlink" title="CAS概述"></a>CAS概述</h2><p>compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它是原子操作</p>
<p>其实 CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p>
<ul>
<li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li>
</ul>
<p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
<h2 id="synchronized和CAS比较"><a href="#synchronized和CAS比较" class="headerlink" title="synchronized和CAS比较"></a>synchronized和CAS比较</h2><p>synchronized 和 cas 没有绝对的谁效率高,要看所处的场景</p>
<ul>
<li><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</p>
</li>
<li><ul>
<li>打个比喻, 线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火,等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大 </li>
</ul>
</li>
<li><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于分配的时间片到时间了，仍然会进入可运行状态让出cpu，还是会导致上下文切换。</p>
</li>
</ul>
<h2 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h2><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。 </p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 </li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 </li>
<li><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 </p>
</li>
<li><ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h1 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens Before规则"></a>Happens Before规则</h1><p>共享变量可见性的总结.  </p>
<p>变量都是指成员变量或静态成员变量</p>
<p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛<br>开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>
<p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待<br>它结束）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">"t1"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>
<p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过<br>t2.interrupted 或 t2.isInterrupted）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"t2"</span>);</span><br><span class="line">t2.start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">t2.interrupt();</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">y = <span class="number">10</span>;</span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span></span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<h1 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191745877.png" alt="image-20240819174553708"></p>
<p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、<br>AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的</p>
<h2 id="原子整型"><a href="#原子整型" class="headerlink" title="原子整型"></a>原子整型</h2><p>AtomicInteger AtomicLong AtomicBoolean</p>
<p>incrementAndGet</p>
<p>getAndIncrement</p>
<p>getAndAdd</p>
<p>addAndGet</p>
<p>updateAndGet.    类似++i</p>
<p>getAndUpdate.    类似i++</p>
<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><p> AtomicIntegerArray AtomicLongArray. AtomicReferenceArray</p>
<p>AtomicIntegerArray array=new AtomicIntegerArray(length)</p>
<p>array.getAndIncrement(index)</p>
<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>AtomicReference. AtomicStampedReference. AtomicMarkableReference</p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">"A"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        testAtomicReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"main start..."</span>);</span><br><span class="line">        <span class="comment">// 获取值 A</span></span><br><span class="line">        String prev = ref.get();</span><br><span class="line">        <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">        otherReference();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 尝试改为 C</span></span><br><span class="line">        log.debug(<span class="string">"change A-&gt;C &#123;&#125;"</span>, ref.compareAndSet(prev, <span class="string">"C"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"change A-&gt;B &#123;&#125;"</span>, ref.compareAndSet(ref.get(), <span class="string">"B"</span>));</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"change B-&gt;A &#123;&#125;"</span>, ref.compareAndSet(ref.get(), <span class="string">"A"</span>));</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192253053.png" alt="image-20240819225333928"></p>
<p>AtomicStampedReference 加版本号解决ABA</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">"A"</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        testAtomicStampedReference ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomicStampedReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"main start..."</span>);</span><br><span class="line">        <span class="comment">// 获取值 A</span></span><br><span class="line">        String prev = stampedReference.getReference();</span><br><span class="line">        <span class="comment">// 获取版本号</span></span><br><span class="line">        <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">        log.debug(<span class="string">"版本 &#123;&#125;"</span>, stamp);</span><br><span class="line">        <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">        other();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 尝试改为 C</span></span><br><span class="line">        log.debug(<span class="string">"change A-&gt;C &#123;&#125;"</span>, stampedReference.compareAndSet(prev, <span class="string">"C"</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"change A-&gt;B &#123;&#125;"</span>, stampedReference.compareAndSet(stampedReference.getReference(), <span class="string">"B"</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            log.debug(<span class="string">"更新版本为 &#123;&#125;"</span>, stampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"change B-&gt;A &#123;&#125;"</span>, stampedReference.compareAndSet(stampedReference.getReference(), <span class="string">"A"</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            log.debug(<span class="string">"更新版本为 &#123;&#125;"</span>, stampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192254977.png" alt="image-20240819225426774"></p>
<p>AtomicmarkableReference  关心是否修改过,维护一个布尔变量. 不能解决ABA</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        GarbageBag bag = <span class="keyword">new</span> GarbageBag(<span class="string">"装满了垃圾"</span>);</span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"start..."</span>);</span><br><span class="line">        GarbageBag prev = ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"start..."</span>);</span><br><span class="line">            bag.setDesc(<span class="string">"空垃圾袋"</span>);</span><br><span class="line">            <span class="keyword">boolean</span> b = ref.compareAndSet (bag, bag, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            log.info (<span class="string">"bb..&#123;&#125;"</span>,b);</span><br><span class="line">            log.info (<span class="string">"bb...&#123;&#125;"</span>,ref.isMarked ());</span><br><span class="line">            log.debug(bag.toString());</span><br><span class="line">        &#125;,<span class="string">"保洁阿姨"</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">"想换一只新垃圾袋？"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println (ref.getReference ()==prev);</span><br><span class="line">        System.out.println (ref.getReference ()==bag);</span><br><span class="line">        <span class="keyword">boolean</span> success = ref.compareAndSet(prev, <span class="keyword">new</span> GarbageBag(<span class="string">"空垃圾袋"</span>), <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        log.debug(<span class="string">"换了么？"</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GarbageBag</span> </span>&#123;</span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GarbageBag</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">" "</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子字段更新器"><a href="#原子字段更新器" class="headerlink" title="原子字段更新器"></a>原子字段更新器</h2><p>AtomicIntegerFieldUpdater. AtomicLongFieldUpdater. AtomicReferenceFieldUpdater</p>
<p>必须和volatile配合使用,否则会有异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> t=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        AtomicReferenceFieldUpdater updater =</span><br><span class="line">                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(updater.compareAndSet(stu, <span class="keyword">null</span>, <span class="string">"张三"</span>));</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">        AtomicIntegerFieldUpdater integerFieldUpdater=AtomicIntegerFieldUpdater.newUpdater (Test40.class,<span class="string">"t"</span>);</span><br><span class="line"></span><br><span class="line">        Test40 test40=<span class="keyword">new</span> Test40 ();</span><br><span class="line">        System.out.println(integerFieldUpdater.compareAndSet(test40, <span class="number">10</span>, <span class="number">13</span>));</span><br><span class="line">        System.out.println(test40.t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><p>LongAdder DoubleAdder  LongAccumulator</p>
<h3 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h3><p>LongAdder只能用来计算加法，且从零开始计算</p>
<p>LongAccumulator提供了自定义的函数操作</p>
<p><code>LongAccumulator</code> 是 Java 8 引入的一个类，位于 <code>java.util.concurrent.atomic</code> 包中。它允许在多线程环境中对 <code>long</code> 值进行并发累加操作，并支持自定义的累加函数。</p>
<p>以下是一个简单的 <code>LongAccumulator</code> 使用示例，演示如何在多线程环境中安全地进行累加操作。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAccumulator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAccumulatorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 LongAccumulator，初始值为 0，使用加法作为累加函数</span></span><br><span class="line">        LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator(Long::sum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程进行累加操作</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                accumulator.accumulate(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">101</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">                accumulator.accumulate(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">201</span>; i &lt;= <span class="number">300</span>; i++) &#123;</span><br><span class="line">                accumulator.accumulate(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">            thread3.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最终结果</span></span><br><span class="line">        <span class="keyword">long</span> result = accumulator.get();</span><br><span class="line">        System.out.println(<span class="string">"最终累加结果: "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>创建 <code>LongAccumulator</code></strong>：</p>
<ul>
<li>使用 <code>Long::sum</code> 作为累加函数，初始值为 <code>0</code>。</li>
</ul>
</li>
<li><p><strong>创建多个线程</strong>：</p>
<ul>
<li>每个线程对不同范围的整数进行累加。</li>
</ul>
</li>
<li><p><strong>启动线程</strong>：</p>
<ul>
<li>启动所有线程并等待它们完成。</li>
</ul>
</li>
<li><p><strong>获取结果</strong>：</p>
<ul>
<li>使用 <code>accumulator.get()</code> 获取最终的累加结果，并打印出来。</li>
</ul>
</li>
</ol>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行上述代码后，您将看到输出的最终累加结果，该结果是所有线程累加的值之和。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>LongAccumulator</code> 是线程安全的，适用于高并发场景。</li>
<li>可以根据需要自定义累加函数，例如使用乘法、最大值、最小值等操作。只需替换 <code>Long::sum</code> 为相应的函数即可。</li>
</ul>
<p>这个示例展示了如何使用 <code>LongAccumulator</code> 进行并发累加，您可以根据具体需求进行扩展和修改。</p>
<p>对象由对象头，实例数据，对齐填充组成，而对象头又由mark word（8字节），类型指针（8字节），数组长度组成</p>
<h3 id="LongAdder源码"><a href="#LongAdder源码" class="headerlink" title="LongAdder源码"></a>LongAdder源码</h3><h4 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>
<h4 id="缓存行伪共享"><a href="#缓存行伪共享" class="headerlink" title="缓存行伪共享"></a>缓存行伪共享</h4><p>@Contended. 解决缓存行伪共享</p>
<p>一个缓存行可以放2个cell对象。有缓存行伪共享问题。 一个失效都跟着失效</p>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组</span></span><br><span class="line">    <span class="comment">// b 为基础值</span></span><br><span class="line">    <span class="comment">// x 为累加值</span></span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">    <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span></span><br><span class="line">    <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// uncontended 表示 cell 没有竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// as 还没有创建</span></span><br><span class="line">            as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 当前线程对应的 cell 还没有</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="longAccumulate"><a href="#longAccumulate" class="headerlink" title="longAccumulate"></a>longAccumulate</h5><p>有竞争时进入if条件,当前线程的 cell 累加失败时执行longAccumulate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,<span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 probe</span></span><br><span class="line">        ThreadLocalRandom.current();</span><br><span class="line">        <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collide 为 true 表示需要扩容</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">// 已经有了 cells</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还没有 cell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span></span><br><span class="line">                <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还没有 cells, 尝试给 cellsBusy 加锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span></span><br><span class="line">            <span class="comment">// 成功则 break;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上两种情况失败, 尝试给 base 累加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h4><p>获取最终结果通过 sum 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h1><p>DateTimeFormatter</p>
<p>String  ( char数组。9以后是字节数组)</p>
<ul>
<li>不可变类的使用 </li>
<li>不可变类设计 </li>
<li>无状态类设计</li>
</ul>
<p>创建副本避免共享。保护性拷贝</p>
<p>和享元模式配合</p>
<p>jdk中享元模式</p>
<p>StringTable </p>
<p>Byte Short Integer Long    valueOf()方法会重用对象。缓存-128-127。大于这个范围才会创建新对象</p>
<p>Character。缓存0-127</p>
<p>Integer 默认缓存-128-127。最小值不能变。最大值能用虚拟机参数改变. -Djava.lang.Integer.IntegerCache.high</p>
<p>Boolean 缓存TRUE FALSE</p>
<p>BigDecimal. BigInteger. 也用到了享元模式</p>
<h1 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h1><h2 id="设置final变量的原理"><a href="#设置final变量的原理" class="headerlink" title="设置final变量的原理"></a>设置final变量的原理</h2><p>分配空间。赋值。final保证其他线程只能看到赋值后的变量</p>
<p>Putfield字节码后有写屏障</p>
<h2 id="获取final变量的原理"><a href="#获取final变量的原理" class="headerlink" title="获取final变量的原理"></a>获取final变量的原理</h2><p>BIPUSH    没超过short类型最大值。直接复制到栈内存中   final</p>
<p>ldc  超过short类型最大值。 final   常量池</p>
<p>getstatic  不加final    效率差</p>
<p>Happens before</p>
<h1 id="单例模式写法"><a href="#单例模式写法" class="headerlink" title="单例模式写法"></a>单例模式写法</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><p>静态字段直接new对象</p>
<p>枚举</p>
<h2 id="懒汉"><a href="#懒汉" class="headerlink" title="懒汉"></a>懒汉</h2><p>Synchronized 直接加在方法上</p>
<p>双重检查锁</p>
<p>静态内部类</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>七大参数</strong></p>
<ol>
<li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li>
<li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li>
<li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li>
<li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li>
<li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li>
<li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol>
<li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li>
<li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li>
<li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li>
<li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li>
</ol>
</li>
</ol>
<h2 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a>Executors工具类</h2><p>Executors 工厂方法 可以创建四种线程池,</p>
<ol>
<li><p>有缺陷不建议生产上使用可能会发生内存溢出(阻塞队列任务过多或者创建线程数过多)</p>
</li>
<li><p>自己简单测试无所谓,可以使用</p>
</li>
</ol>
<h3 id="单线程池"><a href="#单线程池" class="headerlink" title="单线程池"></a>单线程池</h3><h3 id="固定大小线程池"><a href="#固定大小线程池" class="headerlink" title="固定大小线程池"></a>固定大小线程池</h3><h3 id="带缓冲线程池"><a href="#带缓冲线程池" class="headerlink" title="带缓冲线程池"></a>带缓冲线程池</h3><p>核心线程是0。非核心线程Integer.MAX_VALUE </p>
<p>SynchronousQueue</p>
<p>来任务就创建新线程</p>
<p>60s</p>
<h3 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h3><p>阻塞队列用DelayQueue.   内部PriorityQueue 而PriorityQueue是基于数组实现的堆。每次增加一个任务时间复杂度O(log n)</p>
<p>时间轮 O(1)。循环队列+链表</p>
<p>Timer 单线程  会有很大可能延迟。出现异常,剩下的任务都不能执行了</p>
<h4 id="延迟执行任务"><a href="#延迟执行任务" class="headerlink" title="延迟执行任务"></a>延迟执行任务</h4><h5 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h5><p>调整核心线程数大小和sleep时间测试 </p>
<p>核心线程数比提交任务大 任务延迟互不影响</p>
<p>核心线程数设置为1时,延迟受上一个提交任务的完成时间影响(取最大值)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        pool.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"task1"</span>);</span><br><span class="line">                <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">                sleep (<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"error:"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        pool.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"task2"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"error:"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h4 id="定时执行任务"><a href="#定时执行任务" class="headerlink" title="定时执行任务"></a>定时执行任务</h4><h5 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h5><p>取任务执行时间和延时时间最大值作为下一个任务的执行时间,和核心线程数的设置无关,核心线程数足够大也是这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">"start..."</span>);</span><br><span class="line">        pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            sleep (<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">"running..."</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h5 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h5><p>任务完成后再延时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        pool.scheduleWithFixedDelay (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"task1"</span>);</span><br><span class="line">                <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">                sleep (<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"error:"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                              <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>shutdown</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shutdownNow</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务列表作为返回值,并将队列中的任务清空</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 打断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tomcat线程池</p>
<p>可以自定义拒绝策略</p>
<ol>
<li>死等</li>
</ol>
<p>2) 带超时等待</p>
<p>3) 让调用者放弃任务执行</p>
<p>4) 让调用者抛出异常</p>
<p>5) 让调用者自己执行任务</p>
<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><p>非线程安全集合</p>
<h2 id="并发丢数据"><a href="#并发丢数据" class="headerlink" title="并发丢数据"></a>并发丢数据</h2><p>1.7,1.8  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">"a"</span>, <span class="keyword">new</span> Object()); <span class="comment">// 97  =&gt; 1</span></span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">"1"</span>, <span class="keyword">new</span> Object()); <span class="comment">// 49 =&gt; 1</span></span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println (map.size ());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以正常方式运行,可能不会出现问题</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190849514.png" alt="image-20240819084922235"></p>
<h3 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h3><p>在HashMap源码中加入条件断点</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190851685.png" alt="image-20240819085111412"></p>
<p>再依次走完线程t1,t2, 此时数据会覆盖</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190852270.png" alt="image-20240819085248093"></p>
<h2 id="并发死链"><a href="#并发死链" class="headerlink" title="并发死链"></a>并发死链</h2><p>1.7头插法,1.8 尾插法。用1.7会出现并发死链问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试 java 7 中哪些数字的 hash 结果相等</span></span><br><span class="line">        System.out.println(<span class="string">"长度为16时，桶下标为1的key"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash(i) % <span class="number">16</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"长度为32时，桶下标为1的key"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash(i) % <span class="number">32</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1, 35, 16, 50 当大小为16时，它们在一个桶内</span></span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">// 放 12 个元素</span></span><br><span class="line">        map.put(<span class="number">2</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">10</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">16</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">35</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"扩容前大小[main]:"</span>+map.size());</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">                map.put(<span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">                System.out.println(<span class="string">"扩容后大小[Thread-0]:"</span>+map.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">                map.put(<span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">                System.out.println(<span class="string">"扩容后大小[Thread-1]:"</span>+map.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>先加入12个元素,还没有触发扩容,当加入第13个元素时触发扩容,而此时有2个线程都要执行扩容操作</p>
<p>如果是单线程扩容最后结果</p>
<p>扩容前1号插槽</p>
<p>1-&gt;35-&gt;16</p>
<p>扩容后1号插槽</p>
<p>35-&gt;1</p>
<h3 id="debug调试-1"><a href="#debug调试-1" class="headerlink" title="debug调试"></a>debug调试</h3><p>Hashmap源码 transfer方法加条件断点</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191958517.png" alt="image-20240819195847384"></p>
<p>断点1条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newTable.length==<span class="number">32</span>&amp;&amp;</span><br><span class="line">        (</span><br><span class="line">Thread.currentThread ().getName ().equals (<span class="string">"Thread-0"</span>)||</span><br><span class="line">        Thread.currentThread ().getName ().equals (<span class="string">"Thread-1"</span>)      </span><br><span class="line">                )</span><br></pre></td></tr></table></figure>
<p>断点2条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread ().getName ().equals (<span class="string">"Thread-0"</span>)</span><br></pre></td></tr></table></figure>
<p>程序先停在断点1处,2个线程都会执行扩容操作,然后让线程1停在第二个断点处,线程2走完扩容操作</p>
<p>线程1的e和next变量</p>
<p>扩容前</p>
<p>e 1-&gt;35-&gt;16</p>
<p>next 35-&gt;16</p>
<p>扩容后</p>
<p>e   1-&gt;null </p>
<p>next   35-&gt;1-&gt;null</p>
<p>这时候HashMap中table已经是线程2扩容后的table,但线程1还没走完扩容操作,在这个场景下,for循环3次就出现了死循环链表,如下图所示</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192010738.png" alt="image-20240819201054506"></p>
<h1 id="ConcurrenthashMap源码"><a href="#ConcurrenthashMap源码" class="headerlink" title="ConcurrenthashMap源码"></a>ConcurrenthashMap源码</h1><h2 id="JDK-7-ConcurrentHashMap"><a href="#JDK-7-ConcurrentHashMap" class="headerlink" title="JDK 7 ConcurrentHashMap"></a>JDK 7 ConcurrentHashMap</h2><p>它维护了一个 segment 数组，每个 segment 对应一把锁 </p>
<ul>
<li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的 </li>
<li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化 </li>
</ul>
<h3 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        		concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// segmentShift 默认是 32 - 4 = 28</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="comment">// segmentMask 默认是 15 即 0000 0000 0000 1111</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        		initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        		++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        		cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 创建 segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">        (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment </p>
<p>例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位</p>
<h3 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h3><p>新增操作发生在扩容之后</p>
<p>segment继承ReentrantLock. put</p>
<h3 id="rehash-流程"><a href="#rehash-流程" class="headerlink" title="rehash 流程"></a>rehash 流程</h3><p>rehash是扩容时调用的方法</p>
<p>发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全</p>
<p>一部分直接移动。一部分新建</p>
<h3 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h3><p>get 时并未加锁，用了 UNSAFE 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新<br>表取内容</p>
<h3 id="size-计算流程"><a href="#size-计算流程" class="headerlink" title="size 计算流程"></a>size 计算流程</h3><ul>
<li>计算元素个数前，先不加锁计算两次，如果前后两次结果一样，认为个数正确返回 </li>
<li>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</li>
</ul>
<h2 id="JDK-8-ConcurrentHashMap"><a href="#JDK-8-ConcurrentHashMap" class="headerlink" title="JDK 8 ConcurrentHashMap"></a>JDK 8 ConcurrentHashMap</h2><h3 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="构造器分析-1"><a href="#构造器分析-1" class="headerlink" title="构造器分析"></a>构造器分析</h3><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p>
<p>get流程</p>
<p>put流程</p>
<p>默认覆盖</p>
<p>链表为单位扩容。发现-1 锁住链表头帮助扩容</p>
<h3 id="size-计算流程-1"><a href="#size-计算流程-1" class="headerlink" title="size 计算流程"></a>size 计算流程</h3><p>size 计算实际发生在 put，remove 改变集合元素的操作之中 </p>
<ul>
<li>没有竞争发生，向 baseCount 累加计数 </li>
<li><p>有竞争发生，新建 counterCells，向其中的一个 cell 累加计数 </p>
</li>
<li><ul>
<li>counterCells 初始有两个 cell </li>
<li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li>
</ul>
</li>
</ul>
<p>有误差。不是精确值(在计算过程中其他线程可能有操作影响)</p>
<p>transfer扩容</p>
<p>computeIfAbsent</p>
<p>1.7。 Reentrantlock. 16个小哈希表</p>
<p>头插法</p>
<p>1.8</p>
<p>尾插法。整个作为一个哈希表</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>thread有threadLocalMap-&gt;Entry数组 Entry有key和value. key是弱引用 指向threadlocal变量 当方法执行完,如果是用的线程池,线程还没有销毁,threadlocal变量是被弱引用指着的可以被垃圾回收,但是key和value还有强引用关系,此时会有内存泄漏</p>
<p><strong>作用</strong></p>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
</ul>
<p><strong>原理</strong></p>
<p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2/3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<p><strong>弱引用 key</strong></p>
<p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p>
<ul>
<li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li>
</ul>
<p><strong>内存释放时机</strong></p>
<ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>
<h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><p>Jol</p>
<p>无锁</p>
<p>偏向锁</p>
<p>轻量锁</p>
<p>重量锁</p>
<p>锁消除 synchronized块中锁的对象是局部变量,没有必要用synchronized</p>
<p>锁粗化  连续的synchronized块 并且锁的都是一个对象</p>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>ReentrantReadWriteLock</p>
<p>写锁降级</p>
<p>StampedLock.  升级</p>
<h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一种新的线程池</p>
<p>任务拆分。合并</p>
<p>提交给ForkJoin线程池的任务需要继承RecursiveTask或者RecursiveAction</p>
<p>RecursiveTask有返回值</p>
<p>RecursiveAction无返回值</p>
<p>二者都继承了ForkJoinTask</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>加入ForkJoinPool的任务类AddTask1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask1</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTask1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;"</span> + n + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"join() &#123;&#125;"</span>, n);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        AddTask1 t1 = <span class="keyword">new</span> AddTask1(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        t1.fork();</span><br><span class="line">        log.debug(<span class="string">"fork() &#123;&#125; + &#123;&#125;"</span>, n, t1);</span><br><span class="line">        <span class="keyword">int</span> result = n + t1.join();</span><br><span class="line">        log.debug(<span class="string">"join() &#123;&#125; + &#123;&#125; = &#123;&#125;"</span>, n, t1, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">        System.out.println(pool.invoke(<span class="keyword">new</span> AddTask1(<span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.851</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - fork() <span class="number">2</span> + &#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.851</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - fork() <span class="number">4</span> + &#123;<span class="number">3</span>&#125;</span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.851</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - fork() <span class="number">5</span> + &#123;<span class="number">4</span>&#125;</span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.851</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>] - fork() <span class="number">3</span> + &#123;<span class="number">2</span>&#125;</span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">1</span></span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">2</span> + &#123;<span class="number">1</span>&#125; = <span class="number">3</span></span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>] - join() <span class="number">3</span> + &#123;<span class="number">2</span>&#125; = <span class="number">6</span></span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - join() <span class="number">4</span> + &#123;<span class="number">3</span>&#125; = <span class="number">10</span></span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - join() <span class="number">5</span> + &#123;<span class="number">4</span>&#125; = <span class="number">15</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>AbstractQueuedSynchronizer的重要属性有</p>
<ul>
<li>private volatile int state;</li>
<li>private transient volatile Node head;</li>
<li>private transient volatile Node tail;</li>
</ul>
<p>两个内部类<strong>Node</strong>,<strong>ConditionObject</strong></p>
<ol>
<li><p>Node的prev,next和AQS自身的head,tail组成双向链表EntryList</p>
</li>
<li><p>ConditionObject自己维护Node类型引用firstWaiter,lastWaiter.和Node的nextWaiter字段构成单向链表WaitSet</p>
</li>
</ol>
<h3 id="EntryList"><a href="#EntryList" class="headerlink" title="EntryList"></a>EntryList</h3><p>AbstractQueuedSynchronizer有一个静态内部类Node,属性有</p>
<ul>
<li>volatile Thread thread;</li>
<li>volatile Node prev;</li>
<li>volatile Node next;</li>
<li>volatile int waitStatus;</li>
<li>Node nextWaiter;</li>
</ul>
<p>EntryList用prev,next</p>
<p>WaitSet用nextWaiter</p>
<h3 id="WaitSet"><a href="#WaitSet" class="headerlink" title="WaitSet"></a>WaitSet</h3><p>内部类ConditionObject,条件变量来实现等待、唤醒机制，支持多个条件变量</p>
<h3 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h3><ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁 <ul>
<li>getState - 获取 state 状态 </li>
<li>setState - 设置 state 状态 </li>
<li>compareAndSetState - cas 机制设置 state 状态 </li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
</ul>
<h3 id="需要子类实现的方法"><a href="#需要子类实现的方法" class="headerlink" title="需要子类实现的方法"></a>需要子类实现的方法</h3><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException） </p>
<ul>
<li>tryAcquire </li>
<li>tryRelease </li>
<li>tryAcquireShared </li>
<li>tryReleaseShared </li>
<li>isHeldExclusively</li>
</ul>
<h3 id="获取锁的姿势"><a href="#获取锁的姿势" class="headerlink" title="获取锁的姿势"></a>获取锁的姿势</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">     <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="释放锁的姿势"><a href="#释放锁的姿势" class="headerlink" title="释放锁的姿势"></a>释放锁的姿势</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">   <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现不可重入锁"><a href="#实现不可重入锁" class="headerlink" title="实现不可重入锁"></a>实现不可重入锁</h2><p>acquire调用tryAcquire,tryAcquire判断失败进入EntryList</p>
<p>release调用tryRelease,tryRelease成功唤醒EntryList上节点</p>
<h3 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占锁  同步器类</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">              <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isHeldExclusively())&#123;</span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">          setState(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h3><p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 释放锁  会唤醒线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 生成条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"locking..."</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"unlocking..."</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"locking..."</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"unlocking..."</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>AQS 要实现的功能目标 </p>
<ul>
<li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire </li>
<li>获取锁超时机制</li>
<li>通过打断取消机制 </li>
<li>独占机制及共享机制 </li>
<li>条件不满足时的等待机制 </li>
</ul>
<p>要点 </p>
<ul>
<li>原子维护 state 状态 </li>
<li>阻塞及恢复线程 </li>
<li>维护队列 </li>
</ul>
<p>阻塞恢复设计 </p>
<ul>
<li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细 </li>
<li>park 线程还可以通过 interrupt 打断</li>
</ul>
<p>队列设计 </p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/393192/1650080165361-18864833-42e6-47a3-beb0-d97886e8fe71.png" alt="img"></p>
<p><a href="https://cloud.tencent.com/developer/article/2031273" target="_blank" rel="noopener">ConditionObject源码解析</a></p>
<p>自定义锁</p>
<p>用AQS实现 的并发工具类</p>
<p>静态内部类Sync</p>
<p> FairSync</p>
<p>NonFairSync</p>
<p>Sync引用</p>
<h1 id="ReentrantLock源码。"><a href="#ReentrantLock源码。" class="headerlink" title="ReentrantLock源码。"></a>ReentrantLock源码。</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408201047785.png" alt="image-20240820104721523"></p>
<p>超时 打断 多条件变量 公平锁</p>
<h2 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h2><p>默认非公平</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NonfairSync 继承自 AQS </p>
<h3 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p>ReentrantLock.lock()直接调用NonfairSync.lock()</p>
<p>NonfairSync#lock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>加锁成功</strong>,设置state为1,exclusiveOwnerThread字段设置为加锁成功线程</p>
</li>
<li><p><strong>加锁失败</strong>,走else分支,调用acquire(1)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h5><ul>
<li>tryAcquire尝试加锁,最后调用nonfairTryAcquire(),如果state=0,尝试设置为1.state=1就看持有锁的是否是自己,是自己就走重入锁逻辑进行加锁,不是则返回false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h5><ul>
<li><p>tryAcquire失败先调用addWaiter创建Node节点加入双向链表,head和tail是NonfairSync中的字段,</p>
<p>head指向哨兵节点(节点没有线程,Node节点的thread字段是null),</p>
<p>tail指向最后一个节点,也就是当前节点(Node节点的thread字段是当前线程)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><ul>
<li><p>创建完Node节点后调用acquireQueued,这个时候先看一下自己所在的节点是不是head节点的后继,是的话再尝试加锁,失败了就调用shouldParkAfterFailedAcquire</p>
<ul>
<li><p>shouldParkAfterFailedAcquire将前驱节点waitStatus设置为-1,这次返回false.</p>
<p>再次尝试加锁,如果又失败这次shouldParkAfterFailedAcquire返回true,调用parkAndCheckInterrupt</p>
</li>
<li><p>parkAndCheckInterrupt 将现在的线程阻塞,处于waiting状态,可以被打断,</p>
<p>打断后调用interrupted清除打断标记,防止下次park会失败</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h6><p>下面是shouldParkAfterFailedAcquire,首先看前驱的waitStatus字段值,前驱是CANCELLED状态才大于0其他状态都小于0,</p>
<ol>
<li>如果前驱是CANCELLED状态,就找前面第一个不是取消状态的节点,设置不是取消状态的节点为当前节点的前驱,</li>
</ol>
<p>​        并且设置不是取消状态的节点后继为当前节点,忽略那些取消的节点</p>
<ol>
<li><p>设置前驱节点waitStatus字段值为SIGNAL,也就是-1,</p>
<p>如果进入时已经是-1直接返回true,否则返回false</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>waitStatus状态值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h6 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解锁流程"><a href="#解锁流程" class="headerlink" title="解锁流程"></a>解锁流程</h3><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h4><p>ReentrantLock.unlock()调用AQS的release方法,tryRelease由Sync实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h5><p>tryRelease 流程，如果成功 </p>
<ul>
<li>设置 exclusiveOwnerThread 为 null </li>
<li>state = 0</li>
</ul>
<p>tryRelease 流程，失败情况</p>
<ul>
<li><p>如果不是持有锁的线程解锁抛异常</p>
</li>
<li><p>可重入锁解锁state!=0就返回false</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h5><p>传入head指向的节点,唤醒下一个没有取消的节点</p>
<ol>
<li><p>通常是head指向节点的后继,执行unpark唤醒</p>
</li>
<li><p>如果后继取消,就从tail指向节点从后向前找head指向的第一个waitStatus不为CANCEL的Node节点,执行unpark唤醒</p>
</li>
<li>如果没有找到,则不执行unpark</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="解锁竞争成功"><a href="#解锁竞争成功" class="headerlink" title="解锁竞争成功"></a>解锁竞争成功</h4><ul>
<li>线程之前阻塞在parkAndCheckInterrupt,线程被唤醒的情况</li>
</ul>
<ol>
<li><p>可能是被打断,此时设置interrupted = true</p>
</li>
<li><p>解锁调用unpark</p>
</li>
</ol>
<ul>
<li>唤醒后再次尝试加锁,假设加锁成功<ul>
<li>断开之前的头节点,设置当前节点是头节点,并且当前节点thread字段设置为null</li>
<li>设置failed=false,返回打断标记(记录是否被打断过)</li>
</ul>
</li>
</ul>
<h4 id="解锁竞争失败"><a href="#解锁竞争失败" class="headerlink" title="解锁竞争失败"></a>解锁竞争失败</h4><p>非公平锁,可能有新来的线程还未加入EntryList直接加锁成功,导致被唤醒的线程尝试加锁失败,再次陷入阻塞</p>
<p>在acquireQueued的for循环中产生了异常,并且failed=true,则取消当前节点在EntryList的等待,调整链表结构</p>
<p>取消的逻辑代码</p>
<p>从当前节点向前找第一个waitStatus不是取消状态的节点,判断这个不是取消状态的节点waitStatus是不是-1,</p>
<p>是的话调整链表结构 不是取消状态的节点后继设置为当前节点的后继</p>
<p>不是就唤醒当前节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h2><p>通过state计数的增加减少来实现可重入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state-- </span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h2><h4 id="不可打断模式-默认"><a href="#不可打断模式-默认" class="headerlink" title="不可打断模式 (默认)"></a>不可打断模式 (默认)</h4><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p>
<p>被打断时只是记录下被打断过,等获得锁以后才继续向下运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h4><p>加锁过程可打断。被打断时直接抛 InterruptedException</p>
<p>Reentraantlock.lockInterruptibly()调用acquireInterruptibly</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="超时原理"><a href="#超时原理" class="headerlink" title="超时原理"></a>超时原理</h2><p>ReentrantLock调用带超时时间的tryLock方法,加锁过程支持超时,支持打断</p>
<h3 id="tryLock-timeout-unit"><a href="#tryLock-timeout-unit" class="headerlink" title="tryLock(timeout,unit)"></a>tryLock(timeout,unit)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tryAcquireNanos"><a href="#tryAcquireNanos" class="headerlink" title="tryAcquireNanos"></a>tryAcquireNanos</h4><p>先调用tryAcquire尝试加锁,加锁失败调用doAcquireNanos</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="doAcquireNanos"><a href="#doAcquireNanos" class="headerlink" title="doAcquireNanos"></a>doAcquireNanos</h5><p>创建Node节点,放到EntryList最后一个节点</p>
<p>和之前最大区别在于<code>LockSupport.parkNanos(this, nanosTimeout);</code></p>
<p>所以在加锁过程中支持超时,同样在源码中也可看出加锁过程支持打断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h2><p>队列外线程发现 队列中有等待线程那就不会直接抢占锁, 并入队; 从而先到先得,彰显公平</p>
<p>与非公平锁主要区别在于 tryAcquire 方法的实现,先检查 AQS 队列中是否有前驱节点, 没有才去竞争</p>
<h3 id="tryAcquire-1"><a href="#tryAcquire-1" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408201757013.png" alt="image-20240820175724751"></p>
<h4 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            (</span><br><span class="line">            <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">            s.thread != Thread.currentThread()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">(s = h.next) == null</font> 这个条件成立是其他线程在<strong>enq</strong>方法中执行完<code>compareAndSetTail(t, node)</code>,还没有执行<code>t.next = node;</code></p>
<p>这时满足head和tail指向不同节点,但是head.next还没设置,所以<strong>head.next=null</strong></p>
<p><strong>hasQueuedPredecessors</strong>返回true表示其他线程获取锁优先级高(先进入EntryList),可以实现按先进入EntryList的线程先获取锁,实现公平</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>ConditionObject</p>
<h3 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">long</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h4><p>创建Node节点,设置waitStatus=CONDITION(waitStatus=-2),</p>
<ol>
<li><p>如果ConditionObject之前没有节点,就把firstWaiter指向当前节点,</p>
</li>
<li><p>lastWaiter指向当前节点</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// 所有已取消的 Node 从队列链表删除</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="WaitSet和EntryList的区别"><a href="#WaitSet和EntryList的区别" class="headerlink" title="WaitSet和EntryList的区别"></a>WaitSet和EntryList的区别</h5><ol>
<li>EntryList双向链表,WaitSet单向链表</li>
<li>EntryList的head指向哨兵节点,WaitSet的firstWaiter指向真正节点</li>
<li>EntryList中head==tail时说明EntryList没有节点,而firstWaiter==lastWaiter可能没有节点或者有一个节点</li>
<li>一般情况下,EntryList中Node节点waitStatus除了最后一个节点是0,其他都是-1;WaitSet中Node节点waitStatus=-2</li>
<li>EntryList中新加入Node节点要把之前最后一个节点的waitStatus设置为-1(如果最后一个节点的waitStatus是取消,就不设置),</li>
<li>WaitSet只是将节点放到最后一个位置</li>
</ol>
<h4 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h4><p>解锁并唤醒EntryList中的Node节点代表的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> savedState = getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="park"><a href="#park" class="headerlink" title="park"></a>park</h4><p>调用<code>LockSupport.park(this)</code>使当前线程陷入阻塞</p>
<h4 id="acquireQueued-1"><a href="#acquireQueued-1" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><ul>
<li><p>线程在park过程中被打断</p>
</li>
<li><p>持有锁线程解锁 会执行unpack</p>
</li>
<li><p>在signal流程的transferForSignal过程中最后一个if条件满足会执行unpack</p>
</li>
</ul>
<p>在遇到上述情况后线程继续执行acquireQueued尝试获取锁</p>
<h3 id="signal流程"><a href="#signal流程" class="headerlink" title="signal流程"></a>signal流程</h3><p>signal判断当前线程是否持有锁(有权限),没有就抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h4><p>判断当前线程持有锁调用doSignal方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span></span><br><span class="line">            !transferForSignal(first) &amp;&amp;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            (first = firstWaiter) != <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h6><p>transferForSignal把WaitSet第一个节点转移到EntryList最后一个节点,</p>
<p>如果当前节点是取消状态(超时),就尝试把WaitSet下一个节点转移到EntryList最后一个节点</p>
<p>如果加入EntryList后发现前驱被取消或者前驱的waitStatus设置-1失败,就唤醒这个节点的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 上一个节点被取消</span></span><br><span class="line">            ws &gt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">            !compareAndSetWaitStatus(p, ws, Node.SIGNAL) </span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p>读写锁ReentrantReadWriteLock并不是读写分离，它只允许读读共存，而读写和写写依然是互斥的， 大多实际场景是“读/读”线程间并不存在互斥关系，只有”读/写”线程或”写/写”线程间的操作需要互斥的。因此引入ReentrantReadWriteLock</p>
<p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select …<br>from … lock in share mode</p>
<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"获取读锁..."</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"读取"</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"释放读锁..."</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"获取写锁..."</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"写入"</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"释放写锁..."</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试 读锁-读锁 可以并发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.read();</span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.read();</span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">05.970</span> c.DataContainer [t2] - 获取读锁...</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">05.970</span> c.DataContainer [t1] - 获取读锁...</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">05.971</span> c.DataContainer [t2] - 读取</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">05.971</span> c.DataContainer [t1] - 读取</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">06.974</span> c.DataContainer [t1] - 释放读锁...</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">06.975</span> c.DataContainer [t2] - 释放读锁...</span><br></pre></td></tr></table></figure>
<p>测试 读锁-写锁 相互阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.read();</span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.write();</span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">测试 写锁-写锁 相互阻塞</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.write();</span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.write();</span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读锁不支持条件变量,写锁支持条件变量</span><br><span class="line"></span><br><span class="line">重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</span><br><span class="line"></span><br><span class="line">重入时降级支持：即持有写锁的情况下去获取读锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以先获得写锁再获得读锁</span><br><span class="line"></span><br><span class="line">不可以先获得读锁再获得写锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">写锁降级为读锁</span><br><span class="line"></span><br><span class="line">(获取写锁 操作 获取读锁 释放写锁 释放读锁)</span><br><span class="line"></span><br><span class="line">持有写锁的线程可能执行写操作后,还有一些读取操作,当前线程希望拿到的数据是最新的,这个时候可以降级成为读锁,不影响当前线程获取最新数据,同时其他想获取读锁的读线程不会阻塞,提高了并发度.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ReentrantReadWriteLock原理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">默认非公平</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 <span class="number">16</span> 位，而读锁</span><br><span class="line">使用的是 state 的高 <span class="number">16</span> 位</span><br><span class="line"></span><br><span class="line">t2 执行 r.lock，这时进入读锁的 sync.acquireShared(<span class="number">1</span>) 流程，首先会进入 tryAcquireShared 流程。如果有写</span><br><span class="line">锁占据，那么 tryAcquireShared 返回 -<span class="number">1</span> 表示失败</span><br><span class="line"></span><br><span class="line">tryAcquireShared 返回值表示</span><br><span class="line">-<span class="number">1</span> 表示失败</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> 表示成功，但后继节点不会继续唤醒</span><br><span class="line">正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>和大于<span class="number">1</span>会在信号量Semaphore用到,在这里就是-<span class="number">1</span>表示失败,<span class="number">1</span>表示成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-<span class="number">1</span>改成<span class="number">0</span>避免其他线程的干扰</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读锁-读锁并发原理</span><br><span class="line"></span><br><span class="line">如果此时加的是读锁,可以继续加读锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解锁时会唤醒在EntryList的线程</span><br><span class="line"></span><br><span class="line">获取读锁线程被唤醒时可以看它所在节点的下一个是不是共享类型的节点(获取读锁的线程),如果是可以把它表示的线程唤醒,被唤醒的线程可以继续执行这个操作,直到遇到了不是共享类型的节点或者已经到了链表尾部</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读锁可重入</span><br><span class="line"></span><br><span class="line">`cachedHoldCounter` 是一个用于缓存当前线程持有的读锁数量的计数器</span><br><span class="line"></span><br><span class="line">获取读锁的操作会增加该计数器，而释放读锁的操作会减少该计数器。通过使用 `cachedHoldCounter`，可以快速检查当前线程持有的读锁数量，而不必每次都去查找更复杂的数据结构（如 `readHolds`）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">readHolds用于存储每个线程持有的读锁数量。每个线程都有自己独立的 `readHolds` 实例</span><br><span class="line"></span><br><span class="line">- `cachedHoldCounter` 主要用于优化性能，通过缓存当前线程持有的读锁数量，减少对readHolds的访问。</span><br><span class="line">- `readHolds` 则用于实现线程安全的读锁计数，支持可重入性，确保每个线程能够正确管理其持有的读锁数量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">写锁上锁流程</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 尝试获得写锁失败</span></span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">            <span class="comment">// 进入 AQS 队列阻塞</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得低 16 位, 代表写锁的 state 计数</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// c != 0 and w == 0 表示有读锁, 或者</span></span><br><span class="line">                w == <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">// 如果 exclusiveOwnerThread 不是自己</span></span><br><span class="line">                current != getExclusiveOwnerThread()</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 获得锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写锁计数超过低 16 位, 报异常</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 写锁重入, 获得锁成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 判断写锁是否该阻塞, 或者</span></span><br><span class="line">            writerShouldBlock() ||</span><br><span class="line">            <span class="comment">// 尝试更改计数失败</span></span><br><span class="line">            !compareAndSetState(c, c + acquires)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 获得锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁成功</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写锁释放流程"><a href="#写锁释放流程" class="headerlink" title="写锁释放流程"></a>写锁释放流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试释放写锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// unpark AQS 中等待的线程</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">        <span class="comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free) &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读锁上锁流程"><a href="#读锁上锁流程" class="headerlink" title="读锁上锁流程"></a>读锁上锁流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果是其它线程持有写锁, 获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> ( </span><br><span class="line">            exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span></span><br><span class="line">            !readerShouldBlock() &amp;&amp;</span><br><span class="line">            <span class="comment">// 小于读锁计数, 并且</span></span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            <span class="comment">// 尝试增加计数成功</span></span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span></span><br><span class="line">    <span class="comment">// true 则该阻塞, false 则不阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再一次尝试获取读锁</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ㈠</span></span><br><span class="line">                        <span class="comment">// r 表示可用资源数, 在这里总是 1 允许传播</span></span><br><span class="line">                        <span class="comment">//（唤醒 AQS 中下一个 Share 节点）</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 当前线程</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 设置自己为 head</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">        <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) &#123;</span><br><span class="line">                <span class="comment">// 进入 ㈡</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 下一个节点 unpark 如果成功获取读锁</span></span><br><span class="line">                    <span class="comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读锁释放流程"><a href="#读锁释放流程" class="headerlink" title="读锁释放流程"></a>读锁释放流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                <span class="comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span></span><br><span class="line">                <span class="comment">// 计数为 0 才是真正释放</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE </span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span></span><br><span class="line">                <span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写锁线程饥饿</p>
<p>一旦读操作比较多的时候，想要获取写锁就变得比较困难了，假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了 因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写</p>
<p>非公平模式,当前是持有读锁,那在EntryList外面的想获取读锁的线程可以直接获取读锁,但写锁只能等读锁释放</p>
<p>可以用公平读写锁,但会降低效率,如果写锁线程饥饿问题严重可以考虑用StampedLock</p>
<h1 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h1><p>StampedLock(后面详细讲解)，会发现它改进之处在于：读的过程中也允许获取写锁介入(相当牛B，读和写两个操作也让你“共享”(注意引号))，这样会导致我们读的数据就可能不一致！所以，需要额外的方法来判断读的过程中是否有写入，这是一种乐观的读锁，O(∩_∩)O哈哈~。 显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行</p>
<p>StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化。</p>
<p>进一步优化读性能</p>
<p>邮戳锁 - 也叫票据锁</p>
<h3 id="它是由锁饥饿问题引出"><a href="#它是由锁饥饿问题引出" class="headerlink" title="它是由锁饥饿问题引出"></a>它是由锁饥饿问题引出</h3><p>可以解决写锁线程饥饿</p>
<h4 id="StampedLock有三种访问模式"><a href="#StampedLock有三种访问模式" class="headerlink" title="StampedLock有三种访问模式"></a>StampedLock有三种访问模式</h4><ol>
<li>Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似</li>
<li>Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似</li>
<li>Optimistic reading（乐观读模式）：无锁机制，类似于数据库中的乐观锁，很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式</li>
</ol>
<p>ReentrantReadWriteLock的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。<br>但是，StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，<br>所以，在获取乐观读锁后，还需要对结果进行校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">"=====写线程准备修改"</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            number = number + <span class="number">13</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">"=====写线程结束修改"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.readLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t come in readlock block,4 seconds continue..."</span>);</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 正在读取中......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> result = number;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">" 获得成员变量值result："</span> + result);</span><br><span class="line">            System.out.println(<span class="string">"写线程没有修改值，因为 stampedLock.readLock()读的时候，不可以写，读写互斥"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乐观读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryOptimisticRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">int</span> result = number;</span><br><span class="line">        <span class="comment">//间隔4秒钟，我们很乐观的认为没有其他线程修改过number值，实际靠判断。</span></span><br><span class="line">        System.out.println(<span class="string">"4秒前stampedLock.validate值(true无修改，false有修改)"</span>+<span class="string">"\t"</span>+stampedLock.validate(stamp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 正在读取中......"</span>+i+</span><br><span class="line">                    <span class="string">"秒后stampedLock.validate值(true无修改，false有修改)"</span>+<span class="string">"\t"</span></span><br><span class="line">                    +stampedLock.validate(stamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stampedLock.validate(stamp)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"有人动过--------存在写操作！"</span>);</span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"从乐观读 升级为 悲观读"</span>);</span><br><span class="line">                result = number;</span><br><span class="line">                System.out.println(<span class="string">"重新悲观读锁通过获取到的成员变量值result："</span> + result);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t finally value: "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StampedLockDemo resource = <span class="keyword">new</span> StampedLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            resource.read();</span><br><span class="line">            <span class="comment">//resource.tryOptimisticRead();</span></span><br><span class="line">        &#125;,<span class="string">"readThread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2秒钟时乐观读失败，6秒钟乐观读取成功resource.tryOptimisticRead();，修改切换演示</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(6); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            resource.write();</span><br><span class="line">        &#125;,<span class="string">"writeThread"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StampedLock的缺点"><a href="#StampedLock的缺点" class="headerlink" title="StampedLock的缺点"></a>StampedLock的缺点</h3><ul>
<li>StampedLock 不支持重入，没有Re开头</li>
<li>StampedLock 的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。</li>
</ul>
<h1 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h1><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>限制同时访问共享资源的线程上限</p>
<h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">"running..."</span>);</span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">"end..."</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">39</span>:<span class="number">59.977</span> c.TestSemaphore [Thread-<span class="number">0</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">39</span>:<span class="number">59.977</span> c.TestSemaphore [Thread-<span class="number">2</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">39</span>:<span class="number">59.977</span> c.TestSemaphore [Thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.984</span> c.TestSemaphore [Thread-<span class="number">0</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.985</span> c.TestSemaphore [Thread-<span class="number">1</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.984</span> c.TestSemaphore [Thread-<span class="number">2</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.985</span> c.TestSemaphore [Thread-<span class="number">3</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.985</span> c.TestSemaphore [Thread-<span class="number">4</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.985</span> c.TestSemaphore [Thread-<span class="number">5</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.988</span> c.TestSemaphore [Thread-<span class="number">5</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.988</span> c.TestSemaphore [Thread-<span class="number">3</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.989</span> c.TestSemaphore [Thread-<span class="number">6</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.989</span> c.TestSemaphore [Thread-<span class="number">8</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.989</span> c.TestSemaphore [Thread-<span class="number">4</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.990</span> c.TestSemaphore [Thread-<span class="number">7</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">02.991</span> c.TestSemaphore [Thread-<span class="number">7</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">02.992</span> c.TestSemaphore [Thread-<span class="number">9</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">02.993</span> c.TestSemaphore [Thread-<span class="number">6</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">02.994</span> c.TestSemaphore [Thread-<span class="number">8</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">03.996</span> c.TestSemaphore [Thread-<span class="number">9</span>] - end...</span><br></pre></td></tr></table></figure>
<h3 id="Semaphore原理"><a href="#Semaphore原理" class="headerlink" title="Semaphore原理"></a>Semaphore原理</h3><p>基于AQS实现</p>
<h4 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h4><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h5><h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>可以复用对象,不像CountDownLatch要重新创建对象</p>
<h3 id="简单使用-2"><a href="#简单使用-2" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, ()-&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"task1, task2 finish..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// task1  task2  task1</span></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"task1 begin..."</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await(); <span class="comment">// 2-1=1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"task2 begin..."</span>);</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await(); <span class="comment">// 1-1=0</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">29.732</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">29.732</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - task2 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">29.732</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - task1 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">30.739</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1, task2 finish...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">30.739</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - task2 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">30.739</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">31.744</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1, task2 finish...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">31.744</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task2 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">33.749</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1, task2 finish...</span><br></pre></td></tr></table></figure>
<h3 id="CyclicBarrier原理"><a href="#CyclicBarrier原理" class="headerlink" title="CyclicBarrier原理"></a>CyclicBarrier原理</h3><p>借助ReentrantLock实现,先减,减到0后会唤醒其他等待线程,然后重置计数为初始值</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>parties用于恢复初始值</p>
<p>count是实际减的值,减到0会用parties再重置为初始值</p>
<p>barrierCommand是减到0时执行的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="dowait"><a href="#dowait" class="headerlink" title="dowait"></a>dowait</h4><p>await方法会调用dowait,主要逻辑都在这里</p>
<p>先减,没有减到0时,trip条件变量执行await在WaitSet等待</p>
<p>减到0时</p>
<ol>
<li><p>command.run(). 执行barrierAction任务</p>
</li>
<li><p>nextGeneration  </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="nextGeneration"><a href="#nextGeneration" class="headerlink" title="nextGeneration"></a>nextGeneration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒计时锁,用于线程同步,等待所有线程完成倒计时</p>
<h3 id="简单使用-3"><a href="#简单使用-3" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"begin..."</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">            log.debug(<span class="string">"end...&#123;&#125;"</span>, latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"begin..."</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">            log.debug(<span class="string">"end...&#123;&#125;"</span>, latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"begin..."</span>);</span><br><span class="line">            sleep(<span class="number">1.5</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">            log.debug(<span class="string">"end...&#123;&#125;"</span>, latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"waiting..."</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        log.debug(<span class="string">"wait end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">08.027</span> c.TestCountDownLatch [Thread-<span class="number">0</span>] - begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">08.027</span> c.TestCountDownLatch [Thread-<span class="number">2</span>] - begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">08.027</span> c.TestCountDownLatch [Thread-<span class="number">1</span>] - begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">08.027</span> c.TestCountDownLatch [main] - waiting...</span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">09.034</span> c.TestCountDownLatch [Thread-<span class="number">0</span>] - end...<span class="number">2</span></span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">09.534</span> c.TestCountDownLatch [Thread-<span class="number">2</span>] - end...<span class="number">1</span></span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">10.031</span> c.TestCountDownLatch [Thread-<span class="number">1</span>] - end...<span class="number">0</span></span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">10.032</span> c.TestCountDownLatch [main] - wait end...</span><br></pre></td></tr></table></figure>
<h3 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h3><p>基于AQS实现</p>
<p>CountDownLatch实现</p>
<p>tryAcquireShared</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>countDown</p>
<p>state减到0时唤醒EntryList节点的线程</p>
<p>await</p>
<p>state!=0 当前线程在EntryList阻塞</p>
<h1 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h1><p>ConcurrentHashMap</p>
<p>ArrayBlockingQueue.  Object数组。ReentrantLock   notEmpty  notFull条件变量</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>单向链表带哨兵节点dummy  基于ReentrantLock实现</p>
<p>两把锁 putLock takeLock</p>
<p>条件变量 notFull  notEmpty分别由两把锁创建</p>
<h3 id="基本的入队出队"><a href="#基本的入队出队" class="headerlink" title="基本的入队出队"></a>基本的入队出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">          E item;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 下列三种情况之一</span></span><br><span class="line"><span class="comment">          * - 真正的后继节点</span></span><br><span class="line"><span class="comment">          * - 自己, 发生在出队时</span></span><br><span class="line"><span class="comment">          * - null, 表示是没有后继节点, 是最后了</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          Node&lt;E&gt; next;</span><br><span class="line">          Node(E x) &#123; item = x; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Current number of elements */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of linked list.</span></span><br><span class="line"><span class="comment">     * Invariant: head.item == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of linked list.</span></span><br><span class="line"><span class="comment">     * Invariant: last.next == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>初始化LinkedBlockingQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>last = head = new Node<e>(null); Dummy 节点用来占位，item 为 null</e></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221514463.png" alt="image-20240822151419353"></p>
<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><p>当一个节点入队 last = last.next = node;</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221514464.png" alt="image-20240822151440366"></p>
<p>再来一个节点入队 last = last.next = node;</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221515767.png" alt="image-20240822151510677"></p>
<h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; h = head;</span><br><span class="line">Node&lt;E&gt; first = h.next;</span><br><span class="line">h.next = h; <span class="comment">// help GC</span></span><br><span class="line">head = first;</span><br><span class="line">E x = first.item;</span><br><span class="line">first.item = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>
<p>h = head</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221516077.png" alt="image-20240822151621937"></p>
<p>first = h.next</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221517247.png" alt="image-20240822151714116"></p>
<p>h.next = h</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221517407.png" alt="image-20240822151758307"></p>
<p>head = first</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221519084.png" alt="image-20240822151917986"></p>
<p>E x = first.item;<br>first.item = null;<br>return x;</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221519846.png" alt="image-20240822151941712"></p>
<h3 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h3><p>高明之处在于用了两把锁和 dummy 节点</p>
<ul>
<li><p>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</p>
</li>
<li><p>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p>
<ul>
<li><p>消费者与消费者线程仍然串行</p>
</li>
<li><p>生产者与生产者线程仍然串行</p>
</li>
</ul>
</li>
</ul>
<p>线程安全分析</p>
<ul>
<li><p>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是</p>
<p>head 节点的线程安全。两把锁保证了入队和出队没有竞争</p>
</li>
<li><p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p>
</li>
<li><p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 用户 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>
<p>put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="comment">// count 用来维护元素计数</span></span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 满了等待</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 倒过来读就好: 等待 notFull</span></span><br><span class="line">            notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有空位, 入队且计数加一</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        			putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列中有一个元素, 叫醒 take 线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span></span><br><span class="line">            signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">        		notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    		takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span></span><br><span class="line">    <span class="comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由 put 唤醒 put 是为了避免信号不足,</p>
<p>由 take 唤醒 take 也是为了避免信号不足</p>
</blockquote>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较<br>Linked 支持有界，Array 强制有界<br>Linked 实现是链表，Array 实现是数组<br>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组<br>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的<br>Linked 两把锁，Array 一把锁</p>
<p>ConcurrentLinkedQueue.  单向链表。 cas</p>
<p>CopyOnWriteArrayList</p>
<p>synchronizedList</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/搭建博客/" rel="tag"># 搭建博客</a>
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
            
              <div>
                
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

              </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/p/8vugi/" rel="next" title="JVM基本概念">
                <i class="fa fa-chevron-left"></i> JVM基本概念
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/p/8vugk/" rel="prev" title="设计模式知识梳理">
                设计模式知识梳理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NDI2Ni8yMDc5OQ"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/photo.jpg" alt="魔圣">
            
              <p class="site-author-name" itemprop="name">魔圣</p>
              <div class="site-description motion-element" itemprop="description">二十四桥明月夜，玉人何处教吹箫</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">147</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/aaaa3293823524" title="GitHub &rarr; https://github.com/aaaa3293823524" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:3293823524@qq.com" title="E-Mail &rarr; mailto:3293823524@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.baidu.com" title="http://www.baidu.com" rel="noopener" target="_blank">百度</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU结构"><span class="nav-number">1.</span> <span class="nav-text">CPU结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算术逻辑单元"><span class="nav-number">1.0.1.</span> <span class="nav-text">算术逻辑单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制单元"><span class="nav-number">1.0.2.</span> <span class="nav-text">控制单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器"><span class="nav-number">1.0.3.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">1.0.4.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总线接口单元"><span class="nav-number">1.0.5.</span> <span class="nav-text">总线接口单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前端"><span class="nav-number">1.0.6.</span> <span class="nav-text">前端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行单元"><span class="nav-number">1.0.7.</span> <span class="nav-text">执行单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后端"><span class="nav-number">1.0.8.</span> <span class="nav-text">后端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点单元"><span class="nav-number">1.0.9.</span> <span class="nav-text">浮点单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支预测单元"><span class="nav-number">1.0.10.</span> <span class="nav-text">分支预测单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理单元"><span class="nav-number">1.0.11.</span> <span class="nav-text">内存管理单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入输出控制器"><span class="nav-number">1.0.12.</span> <span class="nav-text">输入输出控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟与控制逻辑"><span class="nav-number">1.0.13.</span> <span class="nav-text">时钟与控制逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#现代CPU架构特点"><span class="nav-number">1.0.14.</span> <span class="nav-text">现代CPU架构特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.0.15.</span> <span class="nav-text">总结</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Unsafe"><span class="nav-number">2.</span> <span class="nav-text">Unsafe</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射获取Unsafe对象"><span class="nav-number">2.1.</span> <span class="nav-text">反射获取Unsafe对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsafe实现原子整数"><span class="nav-number">2.2.</span> <span class="nav-text">Unsafe实现原子整数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java创建进程方式"><span class="nav-number">3.</span> <span class="nav-text">java创建进程方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-使用-ProcessBuilder"><span class="nav-number">3.0.1.</span> <span class="nav-text">1. 使用 ProcessBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用-Runtime"><span class="nav-number">3.0.2.</span> <span class="nav-text">2. 使用 Runtime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">3.0.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程通信方式"><span class="nav-number">4.</span> <span class="nav-text">进程通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管道"><span class="nav-number">4.0.1.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列"><span class="nav-number">4.0.2.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享内存"><span class="nav-number">4.0.3.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-number">4.0.4.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#套接字"><span class="nav-number">4.0.5.</span> <span class="nav-text">套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号"><span class="nav-number">4.0.6.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程过程调用"><span class="nav-number">4.0.7.</span> <span class="nav-text">远程过程调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存映射文件"><span class="nav-number">4.0.8.</span> <span class="nav-text">内存映射文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统"><span class="nav-number">4.0.9.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">4.0.10.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#匿名管道和命名管道区别"><span class="nav-number">5.</span> <span class="nav-text">匿名管道和命名管道区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名方式"><span class="nav-number">5.0.1.</span> <span class="nav-text">命名方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">5.0.2.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建和使用"><span class="nav-number">5.0.3.</span> <span class="nav-text">创建和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久性"><span class="nav-number">5.0.4.</span> <span class="nav-text">持久性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">5.0.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建线程"><span class="nav-number">6.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程状态"><span class="nav-number">7.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#上下文切换"><span class="nav-number">8.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java对象内存布局和对象头"><span class="nav-number">9.</span> <span class="nav-text">Java对象内存布局和对象头</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象在堆内存中布局"><span class="nav-number">9.1.</span> <span class="nav-text">对象在堆内存中布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象头多大"><span class="nav-number">9.1.0.1.</span> <span class="nav-text">对象头多大</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例数据"><span class="nav-number">9.1.1.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对齐填充"><span class="nav-number">9.1.2.</span> <span class="nav-text">对齐填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized的性能变化"><span class="nav-number">9.2.</span> <span class="nav-text">Synchronized的性能变化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无锁"><span class="nav-number">9.2.1.</span> <span class="nav-text">无锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-number">9.2.2.</span> <span class="nav-text">偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁的撤销"><span class="nav-number">9.2.2.1.</span> <span class="nav-text">偏向锁的撤销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁"><span class="nav-number">9.2.3.</span> <span class="nav-text">轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">9.2.3.1.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量锁与偏向锁的区别和不同"><span class="nav-number">9.2.3.2.</span> <span class="nav-text">轻量锁与偏向锁的区别和不同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-1"><span class="nav-number">9.2.4.</span> <span class="nav-text"> </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重量级锁"><span class="nav-number">9.2.5.</span> <span class="nav-text">重量级锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他优化"><span class="nav-number">9.3.</span> <span class="nav-text">其他优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JIT编译器对锁的优化"><span class="nav-number">9.4.</span> <span class="nav-text">JIT编译器对锁的优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#死锁"><span class="nav-number">10.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#活锁"><span class="nav-number">11.</span> <span class="nav-text">活锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#饥饿"><span class="nav-number">12.</span> <span class="nav-text">饥饿</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全问题"><span class="nav-number">13.</span> <span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全的实现方式"><span class="nav-number">13.0.1.</span> <span class="nav-text">线程安全的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">13.0.1.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全类"><span class="nav-number">13.0.2.</span> <span class="nav-text">线程安全类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变类线程安全性"><span class="nav-number">13.0.3.</span> <span class="nav-text">不可变类线程安全性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#interrupt"><span class="nav-number">14.</span> <span class="nav-text">interrupt</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#wait-amp-notify"><span class="nav-number">15.</span> <span class="nav-text">wait&amp;notify</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#park-amp-unpark"><span class="nav-number">16.</span> <span class="nav-text">park&amp;unpark</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代码示例"><span class="nav-number">16.1.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-number">16.2.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#await-amp-signal"><span class="nav-number">17.</span> <span class="nav-text">await&amp;signal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步模式之顺序控制"><span class="nav-number">18.</span> <span class="nav-text">同步模式之顺序控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序打印"><span class="nav-number">18.1.</span> <span class="nav-text">顺序打印</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-amp-notify-1"><span class="nav-number">18.1.1.</span> <span class="nav-text">wait &amp;notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#park-amp-unpark-1"><span class="nav-number">18.1.2.</span> <span class="nav-text">park&amp;unpark</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交替输出"><span class="nav-number">18.2.</span> <span class="nav-text">交替输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-amp-notify-2"><span class="nav-number">18.2.1.</span> <span class="nav-text">wait &amp;notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#await-amp-signal-1"><span class="nav-number">18.2.2.</span> <span class="nav-text">await.&amp;signal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#park-amp-unpack"><span class="nav-number">18.2.3.</span> <span class="nav-text">park&amp;unpack</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#两阶段终止"><span class="nav-number">19.</span> <span class="nav-text">两阶段终止</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#保护性暂停模式"><span class="nav-number">20.</span> <span class="nav-text">保护性暂停模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步模式之-Balking-犹豫"><span class="nav-number">21.</span> <span class="nav-text">同步模式之 Balking(犹豫)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU流水线和指令级并行"><span class="nav-number">22.</span> <span class="nav-text">CPU流水线和指令级并行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-CPU流水线（Pipeline）"><span class="nav-number">22.1.</span> <span class="nav-text">1. CPU流水线（Pipeline）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流水线的基本工作原理："><span class="nav-number">22.1.1.</span> <span class="nav-text">流水线的基本工作原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例说明："><span class="nav-number">22.1.2.</span> <span class="nav-text">举例说明：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点："><span class="nav-number">22.1.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点："><span class="nav-number">22.1.4.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-指令级并行（ILP）"><span class="nav-number">22.2.</span> <span class="nav-text">2. 指令级并行（ILP）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ILP的实现方式："><span class="nav-number">22.2.1.</span> <span class="nav-text">ILP的实现方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例说明：-1"><span class="nav-number">22.2.2.</span> <span class="nav-text">举例说明：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点：-1"><span class="nav-number">22.2.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点：-1"><span class="nav-number">22.2.4.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">22.2.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU执行单元"><span class="nav-number">22.3.</span> <span class="nav-text">CPU执行单元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不同类型的执行单元："><span class="nav-number">22.3.1.</span> <span class="nav-text">不同类型的执行单元：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#支持流水线的处理器"><span class="nav-number">22.4.</span> <span class="nav-text">支持流水线的处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-2"><span class="nav-number">22.4.1.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件支持"><span class="nav-number">22.4.1.1.</span> <span class="nav-text">硬件支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软件优化"><span class="nav-number">22.4.1.2.</span> <span class="nav-text">软件优化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可见性"><span class="nav-number">23.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#退不出的循环"><span class="nav-number">23.1.</span> <span class="nav-text">退不出的循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序分析"><span class="nav-number">23.1.1.</span> <span class="nav-text">程序分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方法"><span class="nav-number">23.1.2.</span> <span class="nav-text">解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#有序性"><span class="nav-number">24.</span> <span class="nav-text">有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指令重排序导致诡异的结果"><span class="nav-number">24.1.</span> <span class="nav-text">指令重排序导致诡异的结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决方法-1"><span class="nav-number">24.2.</span> <span class="nav-text">解决方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile原理"><span class="nav-number">25.</span> <span class="nav-text">volatile原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile保证可见性"><span class="nav-number">25.1.</span> <span class="nav-text">volatile保证可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-3"><span class="nav-number">25.1.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile保证有序性"><span class="nav-number">25.2.</span> <span class="nav-text">volatile保证有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile应用"><span class="nav-number">25.2.1.</span> <span class="nav-text">volatile应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原子性"><span class="nav-number">26.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS概述"><span class="nav-number">26.1.</span> <span class="nav-text">CAS概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和CAS比较"><span class="nav-number">26.2.</span> <span class="nav-text">synchronized和CAS比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS-的特点"><span class="nav-number">26.3.</span> <span class="nav-text">CAS 的特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Happens-Before规则"><span class="nav-number">27.</span> <span class="nav-text">Happens Before规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原子操作类"><span class="nav-number">28.</span> <span class="nav-text">原子操作类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子整型"><span class="nav-number">28.1.</span> <span class="nav-text">原子整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子数组"><span class="nav-number">28.2.</span> <span class="nav-text">原子数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子引用"><span class="nav-number">28.3.</span> <span class="nav-text">原子引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA问题"><span class="nav-number">28.3.1.</span> <span class="nav-text">ABA问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子字段更新器"><span class="nav-number">28.4.</span> <span class="nav-text">原子字段更新器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子累加器"><span class="nav-number">28.5.</span> <span class="nav-text">原子累加器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LongAccumulator"><span class="nav-number">28.5.1.</span> <span class="nav-text">LongAccumulator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例代码"><span class="nav-number">28.5.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码解释"><span class="nav-number">28.5.3.</span> <span class="nav-text">代码解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行结果"><span class="nav-number">28.5.4.</span> <span class="nav-text">运行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项-1"><span class="nav-number">28.5.5.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LongAdder源码"><span class="nav-number">28.5.6.</span> <span class="nav-text">LongAdder源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重要字段"><span class="nav-number">28.5.6.1.</span> <span class="nav-text">重要字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存行伪共享"><span class="nav-number">28.5.6.2.</span> <span class="nav-text">缓存行伪共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add"><span class="nav-number">28.5.6.3.</span> <span class="nav-text">add</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#longAccumulate"><span class="nav-number">28.5.6.3.1.</span> <span class="nav-text">longAccumulate</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sum"><span class="nav-number">28.5.6.4.</span> <span class="nav-text">sum</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不可变"><span class="nav-number">29.</span> <span class="nav-text">不可变</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final原理"><span class="nav-number">30.</span> <span class="nav-text">final原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设置final变量的原理"><span class="nav-number">30.1.</span> <span class="nav-text">设置final变量的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取final变量的原理"><span class="nav-number">30.2.</span> <span class="nav-text">获取final变量的原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单例模式写法"><span class="nav-number">31.</span> <span class="nav-text">单例模式写法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#饿汉"><span class="nav-number">31.1.</span> <span class="nav-text">饿汉</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#懒汉"><span class="nav-number">31.2.</span> <span class="nav-text">懒汉</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程池"><span class="nav-number">32.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Executors工具类"><span class="nav-number">32.1.</span> <span class="nav-text">Executors工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单线程池"><span class="nav-number">32.1.1.</span> <span class="nav-text">单线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定大小线程池"><span class="nav-number">32.1.2.</span> <span class="nav-text">固定大小线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带缓冲线程池"><span class="nav-number">32.1.3.</span> <span class="nav-text">带缓冲线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务调度线程池"><span class="nav-number">32.1.4.</span> <span class="nav-text">任务调度线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#延迟执行任务"><span class="nav-number">32.1.4.1.</span> <span class="nav-text">延迟执行任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#schedule"><span class="nav-number">32.1.4.1.1.</span> <span class="nav-text">schedule</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定时执行任务"><span class="nav-number">32.1.4.2.</span> <span class="nav-text">定时执行任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#scheduleAtFixedRate"><span class="nav-number">32.1.4.2.1.</span> <span class="nav-text">scheduleAtFixedRate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scheduleWithFixedDelay"><span class="nav-number">32.1.4.2.2.</span> <span class="nav-text">scheduleWithFixedDelay</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提交任务"><span class="nav-number">32.2.</span> <span class="nav-text">提交任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关闭线程池"><span class="nav-number">32.3.</span> <span class="nav-text">关闭线程池</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap源码"><span class="nav-number">33.</span> <span class="nav-text">HashMap源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发丢数据"><span class="nav-number">33.1.</span> <span class="nav-text">并发丢数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#debug调试"><span class="nav-number">33.1.1.</span> <span class="nav-text">debug调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发死链"><span class="nav-number">33.2.</span> <span class="nav-text">并发死链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序分析-1"><span class="nav-number">33.2.1.</span> <span class="nav-text">程序分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debug调试-1"><span class="nav-number">33.2.2.</span> <span class="nav-text">debug调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ConcurrenthashMap源码"><span class="nav-number">34.</span> <span class="nav-text">ConcurrenthashMap源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-7-ConcurrentHashMap"><span class="nav-number">34.1.</span> <span class="nav-text">JDK 7 ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器分析"><span class="nav-number">34.1.1.</span> <span class="nav-text">构造器分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put流程"><span class="nav-number">34.1.2.</span> <span class="nav-text">put流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rehash-流程"><span class="nav-number">34.1.3.</span> <span class="nav-text">rehash 流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get流程"><span class="nav-number">34.1.4.</span> <span class="nav-text">get流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#size-计算流程"><span class="nav-number">34.1.5.</span> <span class="nav-text">size 计算流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-8-ConcurrentHashMap"><span class="nav-number">34.2.</span> <span class="nav-text">JDK 8 ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重要属性和内部类"><span class="nav-number">34.2.1.</span> <span class="nav-text">重要属性和内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重要方法"><span class="nav-number">34.2.2.</span> <span class="nav-text">重要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器分析-1"><span class="nav-number">34.2.3.</span> <span class="nav-text">构造器分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#size-计算流程-1"><span class="nav-number">34.2.4.</span> <span class="nav-text">size 计算流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">35.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#锁升级"><span class="nav-number">36.</span> <span class="nav-text">锁升级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读写锁"><span class="nav-number">37.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ForkJoin"><span class="nav-number">38.</span> <span class="nav-text">ForkJoin</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">38.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单使用"><span class="nav-number">38.2.</span> <span class="nav-text">简单使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS"><span class="nav-number">39.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">39.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EntryList"><span class="nav-number">39.1.1.</span> <span class="nav-text">EntryList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WaitSet"><span class="nav-number">39.1.2.</span> <span class="nav-text">WaitSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#state属性"><span class="nav-number">39.1.3.</span> <span class="nav-text">state属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#需要子类实现的方法"><span class="nav-number">39.1.4.</span> <span class="nav-text">需要子类实现的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取锁的姿势"><span class="nav-number">39.1.5.</span> <span class="nav-text">获取锁的姿势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#释放锁的姿势"><span class="nav-number">39.1.6.</span> <span class="nav-text">释放锁的姿势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现不可重入锁"><span class="nav-number">39.2.</span> <span class="nav-text">实现不可重入锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义同步器"><span class="nav-number">39.2.1.</span> <span class="nav-text">自定义同步器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义锁"><span class="nav-number">39.2.2.</span> <span class="nav-text">自定义锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试"><span class="nav-number">39.2.3.</span> <span class="nav-text">测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantLock源码。"><span class="nav-number">40.</span> <span class="nav-text">ReentrantLock源码。</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#非公平锁实现原理"><span class="nav-number">40.1.</span> <span class="nav-text">非公平锁实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加锁流程"><span class="nav-number">40.1.1.</span> <span class="nav-text">加锁流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lock"><span class="nav-number">40.1.1.1.</span> <span class="nav-text">lock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#tryAcquire"><span class="nav-number">40.1.1.1.1.</span> <span class="nav-text">tryAcquire</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#addWaiter"><span class="nav-number">40.1.1.1.2.</span> <span class="nav-text">addWaiter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#acquireQueued"><span class="nav-number">40.1.1.1.3.</span> <span class="nav-text">acquireQueued</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#shouldParkAfterFailedAcquire"><span class="nav-number">40.1.1.1.3.1.</span> <span class="nav-text">shouldParkAfterFailedAcquire</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#parkAndCheckInterrupt"><span class="nav-number">40.1.1.1.3.2.</span> <span class="nav-text">parkAndCheckInterrupt</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解锁流程"><span class="nav-number">40.1.2.</span> <span class="nav-text">解锁流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unlock"><span class="nav-number">40.1.2.1.</span> <span class="nav-text">unlock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#tryRelease"><span class="nav-number">40.1.2.1.1.</span> <span class="nav-text">tryRelease</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unparkSuccessor"><span class="nav-number">40.1.2.1.2.</span> <span class="nav-text">unparkSuccessor</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解锁竞争成功"><span class="nav-number">40.1.2.2.</span> <span class="nav-text">解锁竞争成功</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解锁竞争失败"><span class="nav-number">40.1.2.3.</span> <span class="nav-text">解锁竞争失败</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可重入原理"><span class="nav-number">40.2.</span> <span class="nav-text">可重入原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可打断原理"><span class="nav-number">40.3.</span> <span class="nav-text">可打断原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不可打断模式-默认"><span class="nav-number">40.3.0.1.</span> <span class="nav-text">不可打断模式 (默认)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可打断模式"><span class="nav-number">40.3.0.2.</span> <span class="nav-text">可打断模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超时原理"><span class="nav-number">40.4.</span> <span class="nav-text">超时原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tryLock-timeout-unit"><span class="nav-number">40.4.1.</span> <span class="nav-text">tryLock(timeout,unit)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tryAcquireNanos"><span class="nav-number">40.4.1.1.</span> <span class="nav-text">tryAcquireNanos</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#doAcquireNanos"><span class="nav-number">40.4.1.1.1.</span> <span class="nav-text">doAcquireNanos</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公平锁实现原理"><span class="nav-number">40.5.</span> <span class="nav-text">公平锁实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tryAcquire-1"><span class="nav-number">40.5.1.</span> <span class="nav-text">tryAcquire</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hasQueuedPredecessors"><span class="nav-number">40.5.1.1.</span> <span class="nav-text">hasQueuedPredecessors</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件变量"><span class="nav-number">40.6.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#await流程"><span class="nav-number">40.6.1.</span> <span class="nav-text">await流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#addConditionWaiter"><span class="nav-number">40.6.1.1.</span> <span class="nav-text">addConditionWaiter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WaitSet和EntryList的区别"><span class="nav-number">40.6.1.1.1.</span> <span class="nav-text">WaitSet和EntryList的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fullyRelease"><span class="nav-number">40.6.1.2.</span> <span class="nav-text">fullyRelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#park"><span class="nav-number">40.6.1.3.</span> <span class="nav-text">park</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acquireQueued-1"><span class="nav-number">40.6.1.4.</span> <span class="nav-text">acquireQueued</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal流程"><span class="nav-number">40.6.2.</span> <span class="nav-text">signal流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#doSignal"><span class="nav-number">40.6.2.1.</span> <span class="nav-text">doSignal</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#transferForSignal"><span class="nav-number">40.6.2.1.0.1.</span> <span class="nav-text">transferForSignal</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">41.</span> <span class="nav-text">ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#写锁释放流程"><span class="nav-number">41.0.1.</span> <span class="nav-text">写锁释放流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读锁上锁流程"><span class="nav-number">41.0.2.</span> <span class="nav-text">读锁上锁流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读锁释放流程"><span class="nav-number">41.0.3.</span> <span class="nav-text">读锁释放流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#StampedLock"><span class="nav-number">42.</span> <span class="nav-text">StampedLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#它是由锁饥饿问题引出"><span class="nav-number">42.0.1.</span> <span class="nav-text">它是由锁饥饿问题引出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StampedLock有三种访问模式"><span class="nav-number">42.0.1.1.</span> <span class="nav-text">StampedLock有三种访问模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock的缺点"><span class="nav-number">42.0.2.</span> <span class="nav-text">StampedLock的缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步工具类"><span class="nav-number">43.</span> <span class="nav-text">同步工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">43.1.</span> <span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单使用-1"><span class="nav-number">43.1.1.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore原理"><span class="nav-number">43.1.2.</span> <span class="nav-text">Semaphore原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加锁解锁流程"><span class="nav-number">43.1.2.1.</span> <span class="nav-text">加锁解锁流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#acquire"><span class="nav-number">43.1.2.1.1.</span> <span class="nav-text">acquire</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#release"><span class="nav-number">43.1.2.1.2.</span> <span class="nav-text">release</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">43.2.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单使用-2"><span class="nav-number">43.2.1.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier原理"><span class="nav-number">43.2.2.</span> <span class="nav-text">CyclicBarrier原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">43.2.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dowait"><span class="nav-number">43.2.2.2.</span> <span class="nav-text">dowait</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#nextGeneration"><span class="nav-number">43.2.2.2.1.</span> <span class="nav-text">nextGeneration</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">43.3.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单使用-3"><span class="nav-number">43.3.1.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch原理"><span class="nav-number">43.3.2.</span> <span class="nav-text">CountDownLatch原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全集合"><span class="nav-number">44.</span> <span class="nav-text">线程安全集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">44.1.</span> <span class="nav-text">LinkedBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的入队出队"><span class="nav-number">44.1.1.</span> <span class="nav-text">基本的入队出队</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化-1"><span class="nav-number">44.1.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#入队"><span class="nav-number">44.1.1.2.</span> <span class="nav-text">入队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#出队"><span class="nav-number">44.1.1.3.</span> <span class="nav-text">出队</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加锁分析"><span class="nav-number">44.1.2.</span> <span class="nav-text">加锁分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能比较"><span class="nav-number">44.1.3.</span> <span class="nav-text">性能比较</span></a></li></ol></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">魔圣</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  
    <script>
  window.livereOptions = {
    refer: 'p/8vugj/'
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
