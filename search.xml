<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[java的native方法]]></title>
      <url>/p/8wh2g/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JNI</p>
<p>在运行时，native方法是通过动态链接库（在Windows上是.dll文件，在Linux上是.so文件,macos是.dylib文件）加载的</p>
<p>在jdk17 中 src/java.base/share/native/libjava</p>
<p>jdk8中看<a href="https://hg.openjdk.org/。" target="_blank" rel="noopener">https://hg.openjdk.org/。</a>  src/share/native</p>
<p>jdk hashCode方法</p>
<p><a href="https://blog.csdn.net/fengting1995/article/details/121186166" target="_blank" rel="noopener">https://blog.csdn.net/fengting1995/article/details/121186166</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Zookeeper工具类]]></title>
      <url>/p/8wgng/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>zookeeper基本操作</p>
<ul>
<li>连接zookeeper</li>
<li>创建节点</li>
<li>设置节点的数据</li>
<li>获取节点的数据</li>
<li>监听器</li>
</ul>
<p>可以用Curator进行封装成工具类方便自己以后使用</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git命令]]></title>
      <url>/p/8wfvg/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ssh -T git@github.com</p>
<p>git remote set-url origin git@github.com:用户名/仓库名.git</p>
<p>git remote -v</p>
<p>使用steam++加速GitHub前需要执行下面命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+w /etc/hosts</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java IO总结]]></title>
      <url>/p/8wfvf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同步和异步</p>
<p>是否当前线程获得结果,对结果进行处理</p>
<p>阻塞和非阻塞</p>
<p>在内核数据未准备好时系统调用会使线程阻塞是阻塞io,否则是非阻塞io,内核拷贝阶段阻塞io和非阻塞io线程都要等待</p>
<h1 id="MappedByteBuffer和DirectByteBuffer"><a href="#MappedByteBuffer和DirectByteBuffer" class="headerlink" title="MappedByteBuffer和DirectByteBuffer"></a>MappedByteBuffer和DirectByteBuffer</h1><p>MappedByteBuffer是一个抽象类，继承自ByteBuffer</p>
<p>Map映射实现<br>映射是通过FileChannel提供的map方法把文件映射到虚拟内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射</p>
<p>map函数的作用是把文件映射到内存中，获得内存地址addr，然后通过这个addr构造MappedByteBuffer类</p>
<p>DirectByteBuffer继承了MappedByteBuffer</p>
<p>MappedByteBuffer. FileChannel</p>
<p>当我们使用 HeapByteBuffer 传入 FileChannel 的 read or write 方法对文件进行读写时，JDK 会首先创建一个临时的 DirectByteBuffer，对于 <code>FileChannel#read</code> 来说，JDK 在 native 层会将 read 系统调用从文件中读取的内容首先存放到这个临时的 DirectByteBuffer 中，然后在拷贝到 HeapByteBuffer 中返回。</p>
<p>对于 <code>FileChannel#write</code> 来说，JDK 会首先将 HeapByteBuffer 中的待写入数据拷贝到临时的 DirectByteBuffer 中，然后在 native 层通过 write 系统调用将 DirectByteBuffer 中的数据写入到文件的 page cache 中</p>
<p>MappedByteBuffer 适合频繁读取小数据量的场景</p>
<p>FileChannel 适合大数据量的批量读取场景</p>
<p>MappedByteBuffer 的缺页中断是平均每 4K 触发一次，而 FileChannel 的系统调用开销则是每次都会触发。当两者单次按照小数据量读取 1G 文件的时候，MappedByteBuffer 的缺页中断较少触发，而 FileChannel 的系统调用却在频繁触发，所以在这种情况下，FileChannel 的系统调用是主要的性能瓶颈</p>
<p>当单次读写的数据量越来越大的时候，FileChannel 调用的次数就会越来越少，<strong>这时候缺页中断就会成为 MappedByteBuffer 的性能瓶颈，到某一个点之后，FileChannel 就会反超 MappedByteBuffer。因此当我们需要高吞吐量读写文件的时候 FileChannel 反而是最合适的</strong></p>
<p>内存映射文件和直接内存</p>
<p>内存映射文件:文件映射到进程虚拟地址空间,页表建立虚拟内存和物理内存的映射关系,每次读写文件不需要上下文切换,但是初始建立页表映射关系  缺页中断的处理，因此也会有<strong>两次上下文切换</strong>的开销</p>
<p>直接内存:可以不借助</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker基本命令]]></title>
      <url>/p/8wf8p/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>镜像 分层文件系统  bootfs  rootfs</p>
<p>创建网络</p>
<p>docker network create</p>
<p>Docker  pull</p>
<p>docker run -it  —name  </p>
<p>—restart=always.  Docker启动时启动容器</p>
<p>-v.    容器卷</p>
<p>-p。  端口映射</p>
<p>docker commit </p>
<p>docker save -o</p>
<p>docker load -i</p>
<p>dockerfile制作镜像 </p>
<p>docker build -f   文件路径  -t 镜像名 .</p>
<p>docker compose up -d</p>
<h1 id="docker镜像源"><a href="#docker镜像源" class="headerlink" title="docker镜像源"></a>docker镜像源</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"https://hub-mirror.c.163.com"</span>,</span><br><span class="line">    <span class="string">"https://kfwkfulq.mirror.aliyuncs.com"</span>,</span><br><span class="line">    <span class="string">"https://2lqq34jg.mirror.aliyuncs.com"</span>,</span><br><span class="line">    <span class="string">"https://pee6w651.mirror.aliyuncs.com"</span>,</span><br><span class="line">    <span class="string">"http://ovfftd6p.mirror.aliyuncs.com"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span>,</span><br><span class="line">    <span class="string">"https://s16ry9y6.mirror.aliyuncs.com"</span>,</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span>,</span><br><span class="line">    <span class="string">"https://docker.mirrors.tuna.tsinghua.edu.cn"</span>,</span><br><span class="line">    <span class="string">"https://docker.mirrors.ustc.edu.cn"</span></span><br></pre></td></tr></table></figure>
<h1 id="docker存储空间不足问题解决"><a href="#docker存储空间不足问题解决" class="headerlink" title="docker存储空间不足问题解决"></a>docker存储空间不足问题解决</h1><p>no space left on device</p>
<p>启动失败</p>
<p>默认64G</p>
<p>数据目录</p>
<p>~/Library/Containers/com.docker.docker/</p>
<p>杀死docker进程</p>
<p>ps -ef|grep docker|awk ‘{print $2}’|xargs kill -9</p>
<p>配置文件</p>
<p>~/.docker/daemon.json</p>
<h1 id="macOS-上使用的虚拟硬盘文件路径"><a href="#macOS-上使用的虚拟硬盘文件路径" class="headerlink" title="macOS 上使用的虚拟硬盘文件路径"></a>macOS 上使用的虚拟硬盘文件路径</h1><p>~/Library/Containers/com.docker.docker/Data/vms/0/data/Docker.raw</p>
<p>因为Docker Desktop 一直处于starting，所以我们无法直接去修改。这里分三步走：</p>
<ol>
<li><p>首先我们将Docker.raw复制一份保留起来，防止误操作（这里单纯是防止误操作）。<br>我们在强制退出Docker Desktop。直接修改虚拟硬盘文件路径下的Docker.raw名称，比如Docker_copy.raw。</p>
</li>
<li><p>再重启Docker Desktop。你会发现Docker Desktop可以正常启动，但是镜像和容器都不见了，因为加载不到旧的Docker.raw，所以原先的目录下新生成了一个新的Docker.raw。</p>
</li>
<li>我们将Settings-&gt;Resource-&gt;Virtual disk limit选项设置为128G或者更大的值，并将新生成的Docker.raw删除，Docker_copy.raw改回Docker.raw，并重启，这时候即可解决问题</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译openjdk]]></title>
      <url>/p/8weya/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在ubuntu docker,centos虚拟机和mac m1本地尝试编译<strong>openjdk8</strong>,但是因为机器是Mac m1,是arm架构的,并且jdk8出现的也比较早,坑很多,版本之类的问题,检查内核,超过十年等等.如果用其他机器编译应该会顺利很多,在尝试了编译<strong>openjdk8</strong>失败后就选择了编译<strong>open jdk17</strong></p>
<p><a href="https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.8.1%2B1/OpenJDK17U-jdk-sources_17.0.8.1_1.tar.gz" target="_blank" rel="noopener">openjdk17源码下载</a></p>
<p>参考:</p>
<p><a href="https://xie.infoq.cn/article/62e1635e0e9db1d091ec0ab16" target="_blank" rel="noopener">https://xie.infoq.cn/article/62e1635e0e9db1d091ec0ab16</a></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><code>CLion 2021.1.3</code></p>
<p>可能是clion版本问题,用clion调试会进入到汇编代码里</p>
<p>用vscode是ok的</p>
<h2 id="调试java-version"><a href="#调试java-version" class="headerlink" title="调试java -version"></a>调试java -version</h2><p>我把源码目录名字改成了jdk-17-src</p>
<p>vscode下载参考里面的插件,创建调试的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"lldb"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Debug"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/build/macosx-aarch64-server-slowdebug/jdk/bin/java"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [<span class="string">"-version"</span>],</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"lldb"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Debug Test"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/build/macosx-aarch64-server-slowdebug/jdk/bin/java"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [<span class="string">"Test"</span>],</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version <span class="string">"17.0.8.1-internal"</span> <span class="number">2023</span>-<span class="number">08</span>-<span class="number">24</span></span><br><span class="line"><span class="function">OpenJDK Runtime <span class="title">Environment</span> <span class="params">(slowdebug build <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>-internal+<span class="number">0</span>-adhoc.zhangxuefeng.jdk<span class="number">-17</span>-src)</span></span></span><br><span class="line"><span class="function">OpenJDK 64-Bit Server <span class="title">VM</span> <span class="params">(slowdebug build <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>-internal+<span class="number">0</span>-adhoc.zhangxuefeng.jdk<span class="number">-17</span>-src, mixed mode)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="调试java代码"><a href="#调试java代码" class="headerlink" title="调试java代码"></a>调试java代码</h2><h3 id="写测试代码"><a href="#写测试代码" class="headerlink" title="写测试代码"></a>写测试代码</h3><p>进入源码目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/zhangxuefeng/Downloads/jdk-<span class="number">17</span>-src</span><br></pre></td></tr></table></figure>
<p>创建java文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi Test.java</span><br></pre></td></tr></table></figure>
<p>写Test.java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"before hello"</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"after hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用编译好的openjdk17源码对Test.java进行编译,生成Test.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Users/zhangxuefeng/Downloads/jdk-<span class="number">17</span>-src/build/macosx-aarch64-server-slowdebug/jdk/bin/javac</span><br><span class="line">  Test.java</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291140701.png" alt="image-20240829114009633"></p>
<p>可以用编译好的javac运行Test</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/zhangxuefeng/Downloads/jdk-<span class="number">17</span>-src/build/macosx-aarch64-server-slowdebug/jdk/bin/java Test</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291206882.png" alt="image-20240829120635808"></p>
<h3 id="加断点"><a href="#加断点" class="headerlink" title="加断点"></a>加断点</h3><p>src/java.base/share/native/launcher/main.c 加断点</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291207072.png" alt="image-20240829120756997"></p>
<p>src/java.base/share/native/libjli/java.c 加断点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">JavaMain(<span class="keyword">void</span>* _args)</span><br><span class="line">&#123;</span><br><span class="line">    JavaMainArgs *args = (JavaMainArgs *)_args;</span><br><span class="line">    <span class="keyword">int</span> argc = args-&gt;argc;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面加了一行代码<code>printf(&quot;salk cutom jdk17u \n&quot;);</code></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291208134.png" alt="image-20240829120830065"></p>
<h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>按绿色按钮可进行调试</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291209447.png" alt="image-20240829120956347"></p>
<p><strong>调试效果</strong></p>
<p>断点1</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291211312.png" alt="image-20240829121127207"></p>
<p>断点2</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291212873.png" alt="image-20240829121202776"></p>
<p>输出</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291213180.png" alt="image-20240829121348069"></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[汇编环境搭建]]></title>
      <url>/p/8wewj/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mac-m1运行c代码"><a href="#mac-m1运行c代码" class="headerlink" title="mac m1运行c代码"></a>mac m1运行c代码</h1><p>创建hello.c文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hello.c</span><br></pre></td></tr></table></figure>
<p>输入下面c代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    printf(<span class="string">"Hello %s!\n"</span>, <span class="string">"Richard"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 -S 参数就是告诉编译器把源代码编译成汇编代码，而 -O2 参数告诉编译器进行 2 级优化，这样生成的汇编代码会短一些</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -O2 hello.c -o hello.s</span><br></pre></td></tr></table></figure>
<p>用汇编器编译成目标文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p>链接成可执行文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>
<p>运行程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291132222.png" alt="image-20240829113229155"></p>
<h1 id="mac-m1搭建汇编环境"><a href="#mac-m1搭建汇编环境" class="headerlink" title="mac m1搭建汇编环境"></a>mac m1搭建汇编环境</h1><p><strong>vscode+MASM/TASM+DOSbox</strong></p>
<ol>
<li>搜索MASM/TASM并下载</li>
<li>brew install dosbox-x</li>
<li>打开VSCode DOSBox的插件设置，把第一行的dosbox改成<code>open -a dosbox --args</code></li>
<li>创建一个asm，右键运行asm文件，看到hello world就算成功了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data SEGMENT</span><br><span class="line">    hello  DB <span class="string">'Hello World!$'</span> ;注意要以$结束</span><br><span class="line">data ENDS</span><br><span class="line">code SEGMENT</span><br><span class="line">    ASSUME CS:CODE,DS:DATA</span><br><span class="line">start:</span><br><span class="line">    MOV AX,data  ;将data首地址赋值给AX                </span><br><span class="line">    MOV DS,AX    ;将AX赋值给DS,使DS指向data</span><br><span class="line">    LEA DX,hello ;使DX指向hello首地址</span><br><span class="line">    MOV AH,<span class="number">09</span>h   ;给AH设置参数<span class="number">09</span>H</span><br><span class="line">    INT <span class="number">21</span>h      ;执行AH中设置的<span class="number">09</span>H号功能。输出DS指向的DX指向的字符串hello</span><br><span class="line">    MOV AX,<span class="number">4</span>C00h ;给AH设置参数<span class="number">4</span>C00h</span><br><span class="line">    <span class="keyword">int</span> <span class="number">21</span>h      ;调用<span class="number">4</span>C00h号功能，结束程序</span><br><span class="line">code ENDS</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291056052.png" alt="image-20240829105652936"></p>
<p>参考:</p>
<p><a href="https://blog.csdn.net/qq_37756660/article/details/138059052" target="_blank" rel="noopener">https://blog.csdn.net/qq_37756660/article/details/138059052</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/573194123" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/573194123</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux源码环境搭建]]></title>
      <url>/p/8wazf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux-swap分区"><a href="#Linux-swap分区" class="headerlink" title="Linux swap分区"></a>Linux swap分区</h1><p>Linux 的 swappiness 参数用于控制虚拟内存 （交换分区） swap 的使用。 swappiness 参数的默认值是 60，也就是说<strong>当物理内存使用率达到 40 时</strong>，开始使用虚拟内存 （交换分区） swap。 当 swappiness 参数的值是 0 时，则只有当物理机内存耗尽了以后才会使用虚拟内存 （交换分区） swap。 当 swappiness 参数的值是 100 时，则立刻使用虚拟内存 （交换分区） swap</p>
<p><strong>交换分区常用的参数介绍</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">交换分区：</span><br><span class="line">      mkswap 格式化为虚拟内存</span><br><span class="line">      -L <span class="selector-tag">label</span> 指定卷标</span><br><span class="line">      swapon 启动虚拟内存</span><br><span class="line">      -<span class="selector-tag">a</span> 启动所有的虚拟分区</span><br><span class="line">      -p：指定优先级</span><br><span class="line">      swapoff 关闭虚拟内存</span><br><span class="line">      更多参数请参考man mkswap</span><br></pre></td></tr></table></figure>
<p><strong>cat /proc/sys/vm/swappiness</strong></p>
<p>临时调整swappiness的方法 sysctl vm.swappiness=1.   重启会恢复默认值</p>
<p>永久调整swappiness的方法  echo “vm.swappiness=1” &gt;&gt; /etc/sysctl.conf*<em>*</em></p>
<p><strong>Linux清除swap方法</strong> </p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408292049619.png" alt="image-20240829204926525"></p>
<p><strong>更好的Linux磁盘缓存和性能</strong></p>
<p><strong>vm.dirty_background_ratio</strong></p>
<p><strong>vm.dirty_ratio</strong></p>
<p>linux管道</p>
<p><a href="https://young-flash.github.io/2021/12/11/父子进程通过 pipe(" target="_blank" rel="noopener">父子进程通过 pipe() 管道通信时一方需关闭读端另一方需关闭写端 - Blog of Flash (young-flash.github.io)</a> 管道通信时一方需关闭读端另一方需关闭写端/#:~:text=管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd 和fd ）都保持打开。,一对这样的文件描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭fd ，另一个关闭fd 。)</p>
<p>Cache(静态随机存储器)</p>
<p>内存(动态随机存储器)</p>
<p>机械硬盘(磁盘)</p>
<p>固态硬盘(闪存)</p>
<p>u盘(闪存)</p>
<h1 id="MBR和GPT"><a href="#MBR和GPT" class="headerlink" title="MBR和GPT"></a>MBR和GPT</h1><p>MBR和GPT是分区格式,第一个扇区主要有开机管理程序和分区表两个部分,</p>
<p>MBR用BIOS引导读取开机管理程序</p>
<p>GPT用UEFI引导读取开机管理程序</p>
<p>权限与属性放置到 inode 中， 至于实际数据则放置到 data block 区块</p>
<p> 超级块记录文件系统整体信息</p>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>条件判断 if then fi</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式一 ]; then</span><br><span class="line">当条件判断式一成立时， 可以进行的指令工作内容；</span><br><span class="line">elif [ 条件判断式二 ]; then</span><br><span class="line">当条件判断式二成立时， 可以进行的指令工作内容；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">当条件判断式一与二均不成立时， 可以进行的指令工作内容；</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>类似switch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $&#123;<span class="number">1</span>&#125; in</span><br><span class="line"><span class="string">"hello"</span>）</span><br><span class="line">echo <span class="string">"Hello, how are you ?"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">""</span>）</span><br><span class="line">echo <span class="string">"You MUST input parameters, ex&amp;gt; &#123;$&#123;0&#125; someword&#125;"</span></span><br><span class="line">;;</span><br><span class="line">*） # 其实就相当于万用字符， 0~无穷多个任意字符之意！</span><br><span class="line">echo <span class="string">"Usage $&#123;0&#125; &#123;hello&#125;"</span></span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序段落</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> in con1 con2 con3 ...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> （ （ i=<span class="number">1</span>; i&lt;=$&#123;nu&#125;; i=i+<span class="number">1</span> ） ）</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">s=$（ （ $&#123;s&#125;+$&#123;i&#125;） ）</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>shell script 的追踪与 debug</p>
<p>-n. 检查是否有语法问题</p>
<p>-x  将执行过程列出来</p>
<p>RAID</p>
<p>将多个较小的磁盘整合成为一个<br>较大的磁盘设备； 而这个较大的磁盘功能可不止是储存而已， 他还具有数据保护的功能</p>
<p>例行性工作调度</p>
<p>at.       atd</p>
<p>crontab    /etc/crontab.  crond</p>
<p>crontab -e</p>
<p>查询 crontab -l</p>
<p>删除 crontab -r</p>
<p>/etc/crontab, /etc/cron.d/<em> /var/spool/cron/</em>,</p>
<p>Jobs 后台运行的线程。</p>
<p>bg %jobnumber. 后台暂停的线程运行</p>
<p>静态的 ps 或者是动态的 top</p>
<p>仅观察自己的 bash 相关程序： ps -l</p>
<p>我们自己的 bash PID 可由 $$ 变量取得， 请使用 top 持续观察该 PID</p>
<p>echo $$</p>
<p>top -d 2 -p 进程id.   (-d是更新时间间隔 默认5s)</p>
<p>P cpu排序</p>
<p>M 内存排序</p>
<p>pstree -up 进程id</p>
<p>信号2.  ctrl+c</p>
<p>信号19。ctrl+z</p>
<p>启动被终止的程序   SIGHUP 信号1</p>
<p>kill -SIGHUP $（ ps aux | grep ‘rsyslogd’ | grep -v ‘grep’| awk ‘{print $2}’）</p>
<p>删除程序 kill<br>删除服务killall</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -<span class="number">9</span> httpd</span><br></pre></td></tr></table></figure>
<p>free ： 观察内存使用情况</p>
<p>直接输入 free 时， 显示的单位是 KBytes， 我们可以使用 b（ Bytes） , m（ MBytes）<br>k（ KBytes） , 及 g（ GBytes） 来显示单位喔！ 也可以直接让系统自己指定单位 （ -h）</p>
<p>free -m  、以MB作为单位输出</p>
<p>free -s 2  2秒钟输出一次</p>
<p>free -c 2 输出2次</p>
<p>uptime： 观察系统启动时间与工作负载</p>
<p>netstat ： 追踪网络或插槽档</p>
<p>dmesg ： 分析核心产生的讯息</p>
<p>vmstat ： 侦测系统资源变化.  vmstat 可以侦测“ CPU / 内存 / 磁盘输入输出状态 ”等等，</p>
<p>vmstat 1 3.    统计目前主机 CPU 状态， 每秒一次， 共计三次！</p>
<p>有的时候我想要知道我的程序到底在这次启动过程中打开了多少文件， 可以利用 fuser 来观察</p>
<p>找出目前所在目录的使用 PID/所属帐号/权限</p>
<p>fuser -uv .</p>
<p>lsof ： 列出被程序所打开的文件文件名</p>
<p>pidof ： 找出某支正在执行的程序的 PID</p>
<p>netstat -tlunp</p>
<p>grub2是boot loader</p>
<p>当你按下电源按键后计算机硬件会主动的读取 BIOS 或 UEFI BIOS 来载入硬件信息及<br>进行硬件系统的自我测试， 之后系统会主动的去读取第一个可开机的设备 （ 由 BIOS 设置<br>的） ， 此时就可以读入开机管理程序了</p>
<p>开机管理程序可以指定使用哪个核心文件来开机， 并实际载入核心到内存当中解压缩与执<br>行， 此时核心就能够开始在内存内活动， 并侦测所有硬件信息与载入适当的驱动程序来使整<br>部主机开始运行， 等到核心侦测硬件与载入驱动程序完毕后， 一个最阳春的操作系统就开始<br>在你的 PC 上面跑了。<br>主机系统开始运行后， 此时 Linux 才会调用外部程序开始准备软件执行的环境， 并且实际的<br>载入所有系统运行所需要的软件程序哩！ 最后系统就会开始等待你的登陆与操作啦</p>
<p>boot loader 可以载入 kernel 与 initramfs</p>
<p>然后在内存中让 initramfs 解压缩成<br>为根目录， kernel 就能够借此载入适当的驱动程序， 最终释放虚拟文件系统， 并挂载实际的<br>根目录文件系统， 就能够开始后续的正常开机流程</p>
<h1 id="yum安装软件"><a href="#yum安装软件" class="headerlink" title="yum安装软件"></a>yum安装软件</h1><p>srpm</p>
<p>—rebuild</p>
<p>—recompile 这个动作会直接的“编译”“打包”并且“安装”啰！ 请注意， rebuild 仅“编译并打<br>包”而已， 而 recompile 不但进行编译跟打包， 还同时进行“安装”了</p>
<p>rpmbuild —recompile </p>
<p>rpm -ivh   —prefix=  安装。</p>
<p>rpm -qa。  查询</p>
<p>rpm -qi</p>
<p>rpm -e.   —nodeps 来强制移除</p>
<p>rpm —rebuilddb. 重建数据库</p>
<p>配置yum源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">rm -rf .<span class="comment">/*</span></span><br><span class="line"><span class="comment">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.huaweicloud.com/repository/conf/CentOS-AltArch-7.repo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">yum clean all</span></span><br><span class="line"><span class="comment">yum makecache</span></span><br></pre></td></tr></table></figure>
<p>参考:</p>
<p><a href="https://mirrors.huaweicloud.com/mirrorDetail/5ec1f784c1bbdcb43010ab9f?mirrorName=centos-altarch&amp;catalog=os" target="_blank" rel="noopener">https://mirrors.huaweicloud.com/mirrorDetail/5ec1f784c1bbdcb43010ab9f?mirrorName=centos-altarch&amp;catalog=os</a></p>
<p>Source Insight</p>
<p>docker调试</p>
<p>拉取镜像<br>docker pull —platform=linux/amd64 ubuntu:20.04</p>
<p>docker pull —platform=linux/x86_64 ubuntu:20.04</p>
<p>docker pull —platform=linux/x86_64 ubuntu:14.04</p>
<p>docker run -i -t —name ubuntu14.04 ubuntu:14.04 /bin/bash</p>
<p>-i:可以输入进行交互<br>-t:终端交互<br>-name:指定容器名称为ubuntu20.04<br>-ubuntu:20.04:指定使用的镜像<br>-bash:指定容器启动使用的应用<br>-3.查看ubuntu系统版本 cat /etc/issue)<br>-4.配置ubuntu)<br>-control d  # 退出容器)<br>-docker start -i ubuntu20.04  # -i启动容器，可以进入终端交互)<br>-apt-get update  # 更新软件源信息)<br>-docker pull ubuntu:latest #拉取最新ubuntu最新镜像</p>
<p>docker run —rm —privileged multiarch/qemu-user-static —reset -p yes</p>
<p>Docker编译 </p>
<p>Mac OS qemu跑</p>
<p>docker exec -it —privileged ubuntu14.04 /bin/bash</p>
<p>qemu-system-x86_64 -curses -kernel ../../arch/x86/boot/bzImage -initrd ../rootfs.img</p>
<p>sudo /etc/init.d/ssh start</p>
<p>cd /root/linux-5.0.1/kernel_test/test_epoll_thundering_herd</p>
<p>qemu-system-x86_64 -curses -kernel ../../arch/x86/boot/bzImage -initrd ../rootfs.img -append nokaslr -S -s</p>
<p>这里的 -s 和 -S 选项用于启用 GDB 调试</p>
<p>target remote :1234<br>连接到 QEMU 的 GDB 服务器</p>
<p>在 GDB 中使用 bt 命令可以打印出当前线程的调用栈（backtrace），这对于调试程序时查看函数调用的历史非常有用</p>
<p>l  列出源码</p>
<p>step/s 进入 退出函数</p>
<ul>
<li>使用 <code>step</code> 进入函数。</li>
<li>使用 <code>finish</code> 退出函数并继续执行。</li>
<li>使用 <code>return</code> 可以在函数内部强制返回</li>
</ul>
<p>until 行号。 到指定行</p>
<p>cd ~/Desktop/linux-5.0.1/kernel_test/test_epoll_thundering_herd</p>
<p>qemu-system-x86_64 -kernel ../../arch/x86/boot/bzImage -initrd ../rootfs.img -append nokaslr -S -s</p>
<p>docker run -i -t -p 2222:22 —name new_ubuntu new_ubuntu /bin/bash</p>
<p>docker exec -it —privileged new_ubuntu /bin/bash</p>
<p>apt-get install systemd<br>sudo systemctl enable ssh</p>
<p>docker run -id -p 2223:22 —name ubuntu_x86 new_ubuntu /bin/bash</p>
<p>dig @1.1.1.1 hub.docker.com</p>
<p>docker跑ubuntu支持图形化界面</p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/docker-ce" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/docker-ce</a></p>
<p>网上方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull --platform=linux/x86_64 kasmweb/ubuntu-bionic-desktop:<span class="number">1.10</span>.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo docker run --rm --it --name kasmweb_ubuntu -p <span class="number">6901</span>:<span class="number">6901</span> -e VNC_PW=<span class="number">123456</span> kasmweb/ubuntu-bionic-desktop:<span class="number">1.10</span>.0</span><br><span class="line">  </span><br><span class="line">https:<span class="comment">//localhost:6901</span></span><br><span class="line">kasm_user</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>自己制作Dockerfile<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line"> </span><br><span class="line"># 安装桌面环境、VNC 服务器和基本工具</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    ubuntu-desktop \</span><br><span class="line">    gnome-panel \</span><br><span class="line">    gnome-settings-daemon \</span><br><span class="line">    metacity \</span><br><span class="line">    nautilus \</span><br><span class="line">    gnome-terminal \</span><br><span class="line">    vnc4server \</span><br><span class="line">    xvfb \</span><br><span class="line">    unzip \</span><br><span class="line">    wget \</span><br><span class="line">    curl \</span><br><span class="line">    &amp;&amp; rm -rf /<span class="keyword">var</span>/lib/apt/lists<span class="comment">/*</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"># 设置 VNC 服务器密码</span></span><br><span class="line"><span class="comment">ENV VNC_PASSWORD=yourpassword</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"># 创建一个新的用户并允许该用户访问 VNC</span></span><br><span class="line"><span class="comment">RUN useradd -m -s /bin/bash u_user</span></span><br><span class="line"><span class="comment">RUN echo "u_user:u_user" | chpasswd</span></span><br><span class="line"><span class="comment">RUN usermod -a -G vncgroup u_user</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"># 切换到新用户</span></span><br><span class="line"><span class="comment">USER u_user</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"># 启动 VNC 服务器并在前台运行一个 X server</span></span><br><span class="line"><span class="comment">CMD ["/usr/bin/x11vnc", "-forever", "-use_username", "-shared", "-rfbauth", "/home/u_user/.vnc/passwd", "-rfbport", "5900", "&amp;", "/usr/bin/startxfce4"]</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ubuntu-desktop .</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">5900</span>:<span class="number">5900</span> --name=ubuntu-desktop ubuntu-desktop</span><br></pre></td></tr></table></figure>
<p>TightVNC</p>
<hr>
<p>Dockerfile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM --platform=linux/x86_64 new_ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    xorg \</span><br><span class="line">    openbox \</span><br><span class="line">    xterm</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ubuntu_gui .</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix --name ubuntu_view ubuntu_gui</span><br></pre></td></tr></table></figure>
<h1 id="cloudflare-workers反代"><a href="#cloudflare-workers反代" class="headerlink" title="cloudflare workers反代"></a>cloudflare workers反代</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Welcome to Cloudflare Workers! This is your first worker.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Run "npm run dev" in your terminal to start a development server</span></span><br><span class="line"><span class="comment"> * - Open a browser tab at http://localhost:8787/ to see your worker in action</span></span><br><span class="line"><span class="comment"> * - Run "npm run deploy" to publish your worker</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Learn more at https://developers.cloudflare.com/workers/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function">async <span class="title">fetch</span><span class="params">(request, env, ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'Hello World!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进程描述符 task_struct. 双向循环链表</p>
<p>预先分配。重复使用</p>
<p>Thread_info</p>
<p>linux-2.6.32.5/arch/alpha/include/asm/unistd.h.  系统调用号</p>
<p>系统调用号和参数传递<br>eax</p>
<p>ebx ecx edx esi edi 存参数</p>
<p>一个单独寄存器存指向这些参数的指针</p>
<p>返回值也通过寄存器传递 eax</p>
<p>current指针</p>
<p>系统调用上下文</p>
<p>系统调用表</p>
<p>内核映象</p>
<p>linux-2.6.32.5/arch/mn10300/kernel/entry.S</p>
<p>ABI. 应用程序二进制接口</p>
<p>哄直接对系统调用进行访问</p>
<p>内核数据结构</p>
<p>链表list</p>
<p>队列kfifo</p>
<p>映射</p>
<p>红黑树 rbtree<br>基树</p>
<p>位图</p>
<p>中断。 硬件-&gt;中断控制器-&gt;cpu-&gt;内核</p>
<p>中断上下文(原子上下文) 不可阻塞</p>
<p>中断号。中断处理程序</p>
<p> 内核提供2个原子操作</p>
<p>整数。位</p>
<p>Semaphore    计数。二值</p>
<p>Mutex</p>
<p>持有锁不能被抢占</p>
<p>顺序和屏障</p>
<p>定时器和时间管理</p>
<p>时钟中断处理程序</p>
<p>内存管理</p>
<p>页。 mm_type.h   page</p>
<p>以字节为分配单位 </p>
<p>内核空间  kmalloc.  kfree. <linux slab.h></linux></p>
<p>用户空间  malloc/vmalloc</p>
<p>硬件设备不被内存管理单元管理 使用连续物理内存</p>
<p>内核子系统。虚拟文件系统(VFS)</p>
<p>zxuefeng92@gmail.com</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 解决中文环境问题</span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y language-pack-zh-hans  &amp;&amp; \</span><br><span class="line">    locale-gen zh_CN.UTF-<span class="number">8</span> &amp;&amp; update-locale LANG=zh_CN.UTF-<span class="number">8</span> LC_ALL=zh_CN.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line">ENV LANG=<span class="string">'zh_CN.UTF-8'</span></span><br><span class="line">ENV LANGUAGE=<span class="string">'zh_CN:zh:en_US:en'</span></span><br><span class="line">ENV LC_ALL=<span class="string">'zh_CN.UTF-8'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">#### Build Stage ####</span><br><span class="line">ARG BASE_IMAGE=<span class="string">"ubuntu:14.04"</span></span><br><span class="line">FROM $BASE_IMAGE AS base_layer</span><br><span class="line">  </span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y language-pack-zh-hans  &amp;&amp; \</span><br><span class="line">    locale-gen zh_CN.UTF-<span class="number">8</span> &amp;&amp; update-locale LANG=zh_CN.UTF-<span class="number">8</span> LC_ALL=zh_CN.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line">### Environment config</span><br><span class="line">ARG BG_IMG=bg_kasm.png</span><br><span class="line">ARG EXTRA_SH=noop.sh</span><br><span class="line">ARG DISTRO=ubuntu</span><br><span class="line">ARG LANG=<span class="string">'zh_CN.UTF-8'</span></span><br><span class="line">ARG LANGUAGE=<span class="string">'zh_CN:zh:en_US:en'</span></span><br><span class="line">ARG LC_ALL=<span class="string">'zh_CN.UTF-8'</span></span><br><span class="line">ARG TZ=<span class="string">'Etc/UTC'</span></span><br><span class="line">ENV DEBIAN_FRONTEND=noninteractive \</span><br><span class="line">    DISTRO=$DISTRO \</span><br><span class="line">    HOME=/home/kasm-<span class="keyword">default</span>-profile \</span><br><span class="line">    INST_SCRIPTS=/dockerstartup/install \</span><br><span class="line">    KASM_VNC_PATH=/usr/share/kasmvnc \</span><br><span class="line">    LANG=$LANG \</span><br><span class="line">    LANGUAGE=$LANGUAGE \</span><br><span class="line">    LC_ALL=$LC_ALL \</span><br><span class="line">    TZ=$TZ \</span><br><span class="line">    STARTUPDIR=/dockerstartup</span><br><span class="line"></span><br><span class="line">### Home setup</span><br><span class="line">WORKDIR $HOME</span><br><span class="line">RUN mkdir -p $HOME/Desktop</span><br><span class="line"></span><br><span class="line">### Support NVIDIA gpus for graphics acceleration</span><br><span class="line">RUN echo <span class="string">"/usr/local/nvidia/lib"</span> &gt;&gt; /etc/ld.so.conf.d/nvidia.conf &amp;&amp; \</span><br><span class="line">    echo <span class="string">"/usr/local/nvidia/lib64"</span> &gt;&gt; /etc/ld.so.conf.d/nvidia.conf</span><br><span class="line">COPY src/ubuntu/install/nvidia/<span class="number">10</span>_nvidia.json /usr/share/glvnd/egl_vendor.d/<span class="number">10</span>_nvidia.json</span><br><span class="line"></span><br><span class="line">### Setup package rules</span><br><span class="line">COPY ./src/ubuntu/install/package_rules $INST_SCRIPTS/package_rules/</span><br><span class="line">RUN bash $INST_SCRIPTS/package_rules/package_rules.sh &amp;&amp; rm -rf $INST_SCRIPTS/package_rules/</span><br><span class="line"></span><br><span class="line">### Install common tools</span><br><span class="line">COPY ./src/ubuntu/install/tools $INST_SCRIPTS/tools/</span><br><span class="line">RUN bash $INST_SCRIPTS/tools/install_tools.sh &amp;&amp; rm -rf $INST_SCRIPTS/tools/</span><br><span class="line"></span><br><span class="line">### Copy over the maximization script to our startup dir for use by app images.</span><br><span class="line">COPY ./src/ubuntu/install/maximize_script $STARTUPDIR/</span><br><span class="line"></span><br><span class="line">### Install custom fonts</span><br><span class="line">COPY ./src/ubuntu/install/fonts $INST_SCRIPTS/fonts/</span><br><span class="line">RUN bash $INST_SCRIPTS/fonts/install_custom_fonts.sh &amp;&amp; rm -rf $INST_SCRIPTS/fonts/</span><br><span class="line"></span><br><span class="line">### Install xfce UI</span><br><span class="line">COPY ./src/ubuntu/install/xfce $INST_SCRIPTS/xfce/</span><br><span class="line">RUN bash $INST_SCRIPTS/xfce/install_xfce_ui.sh &amp;&amp; rm -rf $INST_SCRIPTS/xfce/</span><br><span class="line">ADD ./src/$DISTRO/xfce/.config/ $HOME/.config/</span><br><span class="line">RUN mkdir -p /usr/share/extra/backgrounds/</span><br><span class="line">RUN mkdir -p /usr/share/extra/icons/</span><br><span class="line">ADD /src/common/resources/images/bg_kasm.png  /usr/share/backgrounds/bg_kasm.png</span><br><span class="line">ADD /src/common/resources/images/$BG_IMG  /usr/share/backgrounds/bg_default.png</span><br><span class="line">ADD /src/common/resources/images/icon_ubuntu.png /usr/share/extra/icons/icon_ubuntu.png</span><br><span class="line">ADD /src/common/resources/images/icon_ubuntu.png /usr/share/extra/icons/icon_default.png</span><br><span class="line">ADD /src/common/resources/images/icon_kasm.png /usr/share/extra/icons/icon_kasm.png</span><br><span class="line">ADD /src/common/resources/images/egress_info.svg /usr/share/extra/icons/egress_info.svg</span><br><span class="line">ADD /src/common/resources/images/egress_error.svg /usr/share/extra/icons/egress_error.svg</span><br><span class="line">ADD /src/common/resources/images/egress_offline.svg /usr/share/extra/icons/egress_offline.svg</span><br><span class="line"></span><br><span class="line">### Install kasm_vnc dependencies and binaries</span><br><span class="line">COPY ./src/ubuntu/install/kasm_vnc $INST_SCRIPTS/kasm_vnc/</span><br><span class="line">RUN bash $INST_SCRIPTS/kasm_vnc/install_kasm_vnc.sh &amp;&amp; rm -rf $INST_SCRIPTS/kasm_vnc/</span><br><span class="line">COPY ./src/common/install/kasm_vnc/kasmvnc.yaml /etc/kasmvnc/</span><br><span class="line"></span><br><span class="line">### Install Kasm Profile Sync</span><br><span class="line">COPY ./src/ubuntu/install/profile_sync $INST_SCRIPTS/profile_sync/</span><br><span class="line">RUN bash $INST_SCRIPTS/profile_sync/install_profile_sync.sh</span><br><span class="line"></span><br><span class="line">### Install Kasm Upload Server</span><br><span class="line">COPY ./src/ubuntu/install/kasm_upload_server $INST_SCRIPTS/kasm_upload_server/</span><br><span class="line">RUN bash $INST_SCRIPTS/kasm_upload_server/install_kasm_upload_server.sh  &amp;&amp; rm -rf $INST_SCRIPTS/kasm_upload_server/</span><br><span class="line"></span><br><span class="line">### Install Audio</span><br><span class="line">COPY ./src/ubuntu/install/audio $INST_SCRIPTS/audio/</span><br><span class="line">RUN bash $INST_SCRIPTS/audio/install_audio.sh  &amp;&amp; rm -rf $INST_SCRIPTS/audio/</span><br><span class="line"></span><br><span class="line">### Install Audio Input</span><br><span class="line">COPY ./src/ubuntu/install/audio_input $INST_SCRIPTS/audio_input/</span><br><span class="line">RUN bash $INST_SCRIPTS/audio_input/install_audio_input.sh &amp;&amp; rm -rf $INST_SCRIPTS/audio_input/</span><br><span class="line"></span><br><span class="line">### Install Gamepad Service</span><br><span class="line">COPY ./src/ubuntu/install/gamepad $INST_SCRIPTS/gamepad/</span><br><span class="line">RUN bash $INST_SCRIPTS/gamepad/install_gamepad.sh &amp;&amp; rm -rf $INST_SCRIPTS/gamepad/</span><br><span class="line"></span><br><span class="line">### Install Webcam Service</span><br><span class="line">COPY ./src/ubuntu/install/webcam $INST_SCRIPTS/webcam/</span><br><span class="line">RUN bash $INST_SCRIPTS/webcam/install_webcam.sh &amp;&amp; rm -rf $INST_SCRIPTS/webcam/</span><br><span class="line"></span><br><span class="line">### Install Printer Service</span><br><span class="line">COPY ./src/ubuntu/install/printer $INST_SCRIPTS/printer/</span><br><span class="line">COPY ./src/ubuntu/install/printer/start_cups.sh /etc/cups/start_cups.sh</span><br><span class="line">RUN bash $INST_SCRIPTS/printer/install_printer.sh &amp;&amp; rm -rf $INST_SCRIPTS/printer</span><br><span class="line">COPY ./src/ubuntu/install/printer/resources<span class="comment">/*.ppd /etc/cups/ppd/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Install Recorder Service</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/recorder $INST_SCRIPTS/recorder/</span></span><br><span class="line"><span class="comment">RUN bash $INST_SCRIPTS/recorder/install_recorder.sh &amp;&amp; rm -rf $INST_SCRIPTS/recorder</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Install custom cursors</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/cursors $INST_SCRIPTS/cursors/</span></span><br><span class="line"><span class="comment">RUN bash $INST_SCRIPTS/cursors/install_cursors.sh &amp;&amp; rm -rf $INST_SCRIPTS/cursors/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Install Squid</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/squid/install/ $INST_SCRIPTS/squid_install/</span></span><br><span class="line"><span class="comment">RUN bash $INST_SCRIPTS/squid_install/install_squid.sh &amp;&amp; rm -rf $INST_SCRIPTS/squid_install/</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/squid/resources/*.conf /etc/squid/</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/squid/resources/start_squid.sh /etc/squid/start_squid.sh</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/squid/resources/SN.png /usr/local/squid/share/icons/SN.png</span></span><br><span class="line"><span class="comment">RUN chown proxy:proxy /usr/local/squid/share/icons/SN.png</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/squid/resources/error_message/access_denied.html /usr/local/squid/share/errors/en/ERR_ACCESS_DENIED</span></span><br><span class="line"><span class="comment">RUN chown proxy:proxy /usr/local/squid/share/errors/en/ERR_ACCESS_DENIED</span></span><br><span class="line"><span class="comment">RUN rm -rf $INST_SCRIPTS/resources/</span></span><br><span class="line"><span class="comment">RUN chmod +x /etc/squid/kasm_squid_adapter</span></span><br><span class="line"><span class="comment">RUN chmod +x /etc/squid/start_squid.sh &amp;&amp; chmod 4755 /etc/squid/start_squid.sh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### configure startup</span></span><br><span class="line"><span class="comment">COPY ./src/common/scripts/kasm_hook_scripts $STARTUPDIR</span></span><br><span class="line"><span class="comment">ADD ./src/common/startup_scripts $STARTUPDIR</span></span><br><span class="line"><span class="comment">RUN bash $STARTUPDIR/set_user_permission.sh $STARTUPDIR $HOME &amp;&amp; \</span></span><br><span class="line"><span class="comment">    echo 'source $STARTUPDIR/generate_container_user' &gt;&gt; $HOME/.bashrc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### extra configurations needed per distro variant</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/extra $INST_SCRIPTS/extra/</span></span><br><span class="line"><span class="comment">RUN bash $INST_SCRIPTS/extra/$EXTRA_SH  &amp;&amp; rm -rf $INST_SCRIPTS/extra/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### VirtualGL</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/virtualgl $INST_SCRIPTS/virtualgl/</span></span><br><span class="line"><span class="comment">RUN bash $INST_SCRIPTS/virtualgl/install_virtualgl.sh &amp;&amp; rm -rf $INST_SCRIPTS/virtualgl/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Sysbox support</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/sysbox $INST_SCRIPTS/sysbox/</span></span><br><span class="line"><span class="comment">RUN bash $INST_SCRIPTS/sysbox/install_systemd.sh &amp;&amp; rm -rf $INST_SCRIPTS/sysbox/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Custom Folder Emblems</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/emblems $INST_SCRIPTS/emblems/</span></span><br><span class="line"><span class="comment">RUN bash $INST_SCRIPTS/emblems/install_emblems.sh &amp;&amp; rm -rf $INST_SCRIPTS/emblems/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Create user and home directory for base images that don't already define it</span></span><br><span class="line"><span class="comment">RUN (groupadd -g 1000 kasm-user \</span></span><br><span class="line"><span class="comment">    &amp;&amp; useradd -M -u 1000 -g 1000 kasm-user \</span></span><br><span class="line"><span class="comment">    &amp;&amp; usermod -a -G kasm-user kasm-user) ; exit 0</span></span><br><span class="line"><span class="comment">ENV HOME=/home/kasm-user</span></span><br><span class="line"><span class="comment">WORKDIR $HOME</span></span><br><span class="line"><span class="comment">RUN mkdir -p $HOME &amp;&amp; chown -R 1000:0 $HOME</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Create user exclusively for session recording purposes</span></span><br><span class="line"><span class="comment">RUN (groupadd -g 1001 kasm-recorder \</span></span><br><span class="line"><span class="comment">    &amp;&amp; useradd -M -u 1001 -g 1001 kasm-recorder \</span></span><br><span class="line"><span class="comment">    &amp;&amp; usermod -a -G kasm-recorder) ; exit 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### FIX PERMISSIONS ## Objective is to change the owner of non-home paths to root, remove write permissions, and set execute where required</span></span><br><span class="line"><span class="comment"># these files are created on container first exec, by the default user, so we have to create them since default will not have write perm</span></span><br><span class="line"><span class="comment">RUN touch $STARTUPDIR/wm.log \</span></span><br><span class="line"><span class="comment">    &amp;&amp; touch $STARTUPDIR/window_manager_startup.log \</span></span><br><span class="line"><span class="comment">    &amp;&amp; touch $STARTUPDIR/vnc_startup.log \</span></span><br><span class="line"><span class="comment">    &amp;&amp; touch $STARTUPDIR/no_vnc_startup.log \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chown -R root:root $STARTUPDIR \</span></span><br><span class="line"><span class="comment">    &amp;&amp; find $STARTUPDIR -type d -exec chmod 755 &#123;&#125; \; \</span></span><br><span class="line"><span class="comment">    &amp;&amp; find $STARTUPDIR -type f -exec chmod 644 &#123;&#125; \; \</span></span><br><span class="line"><span class="comment">    &amp;&amp; find $STARTUPDIR -type f -iname "*.sh" -exec chmod 755 &#123;&#125; \; \</span></span><br><span class="line"><span class="comment">    &amp;&amp; find $STARTUPDIR -type f -iname "*.py" -exec chmod 755 &#123;&#125; \; \</span></span><br><span class="line"><span class="comment">    &amp;&amp; find $STARTUPDIR -type f -iname "*.rb" -exec chmod 755 &#123;&#125; \; \</span></span><br><span class="line"><span class="comment">    &amp;&amp; find $STARTUPDIR -type f -iname "*.pl" -exec chmod 755 &#123;&#125; \; \</span></span><br><span class="line"><span class="comment">    &amp;&amp; find $STARTUPDIR -type f -iname "*.log" -exec chmod 666 &#123;&#125; \; \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chmod 755 $STARTUPDIR/upload_server/kasm_upload_server \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chmod 755 $STARTUPDIR/audio_input/kasm_audio_input_server \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chmod 755 $STARTUPDIR/gamepad/kasm_gamepad_server \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chmod 755 $STARTUPDIR/webcam/kasm_webcam_server \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chmod 755 $STARTUPDIR/printer/kasm_printer_service \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chmod 755 $STARTUPDIR/recorder/kasm_recorder_service \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chmod 755 $STARTUPDIR/generate_container_user \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chmod +x $STARTUPDIR/jsmpeg/kasm_audio_out-linux \</span></span><br><span class="line"><span class="comment">    &amp;&amp; rm -rf $STARTUPDIR/install \</span></span><br><span class="line"><span class="comment">    &amp;&amp; mkdir -p $STARTUPDIR/kasmrx/Downloads \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chown 1000:1000 $STARTUPDIR/kasmrx/Downloads \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chown -R root:root /usr/local/bin \</span></span><br><span class="line"><span class="comment">    &amp;&amp; chown 1000:root /var/run/pulse \</span></span><br><span class="line"><span class="comment">    &amp;&amp; rm -Rf /home/kasm-default-profile/.launchpadlib</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Cleanup job</span></span><br><span class="line"><span class="comment">COPY ./src/ubuntu/install/cleanup $INST_SCRIPTS/cleanup/</span></span><br><span class="line"><span class="comment">RUN bash $INST_SCRIPTS/cleanup/cleanup.sh &amp;&amp; rm -rf $INST_SCRIPTS/cleanup/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### Runtime Stage ####</span></span><br><span class="line"><span class="comment">FROM scratch</span></span><br><span class="line"><span class="comment">COPY --from=base_layer / /</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Labels</span></span><br><span class="line"><span class="comment">LABEL "org.opencontainers.image.authors"='Kasm Tech "info@kasmweb.com"'</span></span><br><span class="line"><span class="comment">LABEL "com.kasmweb.image"="true"</span></span><br><span class="line"><span class="comment">LABEL "com.kasmweb.gpu_acceleration_egl"="nvidia"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Environment config</span></span><br><span class="line"><span class="comment">ARG DISTRO=ubuntu</span></span><br><span class="line"><span class="comment">ARG EXTRA_SH=noop.sh</span></span><br><span class="line"><span class="comment">ARG LANG='en_US.UTF-8'</span></span><br><span class="line"><span class="comment">ARG LANGUAGE='en_US:en'</span></span><br><span class="line"><span class="comment">ARG LC_ALL='en_US.UTF-8'</span></span><br><span class="line"><span class="comment">ARG START_PULSEAUDIO=1</span></span><br><span class="line"><span class="comment">ARG START_XFCE4=1</span></span><br><span class="line"><span class="comment">ARG TZ='Etc/UTC'</span></span><br><span class="line"><span class="comment">ENV AUDIO_PORT=4901 \</span></span><br><span class="line"><span class="comment">    DEBIAN_FRONTEND=noninteractive \</span></span><br><span class="line"><span class="comment">    DISPLAY=:1 \</span></span><br><span class="line"><span class="comment">    DISTRO=$DISTRO \</span></span><br><span class="line"><span class="comment">    GOMP_SPINCOUNT=0 \</span></span><br><span class="line"><span class="comment">    HOME=/home/kasm-user \</span></span><br><span class="line"><span class="comment">    INST_SCRIPTS=/dockerstartup/install \</span></span><br><span class="line"><span class="comment">    KASMVNC_AUTO_RECOVER=true \</span></span><br><span class="line"><span class="comment">    KASM_VNC_PATH=/usr/share/kasmvnc \</span></span><br><span class="line"><span class="comment">    LANG=$LANG \</span></span><br><span class="line"><span class="comment">    LANGUAGE=$LANGUAGE \</span></span><br><span class="line"><span class="comment">    LC_ALL=$LC_ALL \</span></span><br><span class="line"><span class="comment">    LD_LIBRARY_PATH=/opt/libjpeg-turbo/lib64/:/usr/local/lib/ \</span></span><br><span class="line"><span class="comment">    LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:/usr/lib/i386-linux-gnu$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;:/usr/local/nvidia/lib:/usr/local/nvidia/lib64 \</span></span><br><span class="line"><span class="comment">    MAX_FRAME_RATE=24 \</span></span><br><span class="line"><span class="comment">    NO_VNC_PORT=6901 \</span></span><br><span class="line"><span class="comment">    NVIDIA_DRIVER_CAPABILITIES=$&#123;NVIDIA_DRIVER_CAPABILITIES:+$NVIDIA_DRIVER_CAPABILITIES,&#125;graphics,compat32,utility \</span></span><br><span class="line"><span class="comment">    OMP_WAIT_POLICY=PASSIVE \</span></span><br><span class="line"><span class="comment">    PULSE_RUNTIME_PATH=/var/run/pulse \</span></span><br><span class="line"><span class="comment">    SDL_GAMECONTROLLERCONFIG="030000005e040000be02000014010000,XInput Controller,platform:Linux,a:b0,b:b1,x:b2,y:b3,back:b8,guide:b16,start:b9,leftstick:b10,rightstick:b11,leftshoulder:b4,rightshoulder:b5,dpup:b12,dpdown:b13,dpleft:b14,dpright:b15,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7" \</span></span><br><span class="line"><span class="comment">    SHELL=/bin/bash \</span></span><br><span class="line"><span class="comment">    START_PULSEAUDIO=$START_PULSEAUDIO \</span></span><br><span class="line"><span class="comment">    STARTUPDIR=/dockerstartup \</span></span><br><span class="line"><span class="comment">    START_XFCE4=$START_XFCE4 \</span></span><br><span class="line"><span class="comment">    TERM=xterm \</span></span><br><span class="line"><span class="comment">    VNC_COL_DEPTH=24 \</span></span><br><span class="line"><span class="comment">    VNCOPTIONS="-PreferBandwidth -DynamicQualityMin=4 -DynamicQualityMax=7 -DLP_ClipDelay=0" \</span></span><br><span class="line"><span class="comment">    VNC_PORT=5901 \</span></span><br><span class="line"><span class="comment">    VNC_PORT=5901 \</span></span><br><span class="line"><span class="comment">    VNC_PW=aa283617 \</span></span><br><span class="line"><span class="comment">    VNC_RESOLUTION=1280x1024 \</span></span><br><span class="line"><span class="comment">    VNC_RESOLUTION=1280x720 \</span></span><br><span class="line"><span class="comment">    VNC_VIEW_ONLY_PW=vncviewonlypassword \</span></span><br><span class="line"><span class="comment">    TZ=$TZ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Ports and user</span></span><br><span class="line"><span class="comment">EXPOSE $VNC_PORT \</span></span><br><span class="line"><span class="comment">       $NO_VNC_PORT \</span></span><br><span class="line"><span class="comment">       $UPLOAD_PORT \</span></span><br><span class="line"><span class="comment">       $AUDIO_PORT</span></span><br><span class="line"><span class="comment">WORKDIR $HOME</span></span><br><span class="line"><span class="comment">USER 1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ENTRYPOINT ["/dockerstartup/kasm_default_profile.sh", "/dockerstartup/vnc_startup.sh", "/dockerstartup/kasm_startup.sh"]</span></span><br><span class="line"><span class="comment">CMD ["--wait"]</span></span><br></pre></td></tr></table></figure>
<h1 id="常见架构名称等价关系"><a href="#常见架构名称等价关系" class="headerlink" title="常见架构名称等价关系"></a>常见架构名称等价关系</h1><p>ARMv8 = ARM64 = AArch64<br>ARMv7 = armv7l = ARM<br>x86_64 = x64 = amd64<br>x86 = x86_32</p>
<p>docker run -id —name debug_jvm8 debug_openjdk8</p>
<p> CONF=linux-aarch64-normal-server-slowdebug</p>
<p>检查内核版本 </p>
<p>uname -a</p>
<p>加6%</p>
<p>debug_openjdk8u</p>
<p>docker run -id —name debug_jvm8u debug_openjdk8u</p>
<p>/Users/zhangxuefeng/Documents/test_openjdk8</p>
<p>build/linux-aarch64-normal-server-slowdebug/jdk/bin/java -version</p>
<p>超过10年处理可能有问题 javac因为这个有问题</p>
<p>系统安装Javac编译</p>
<p>自己编译的java运行编译的文件</p>
<p>java运行没什么问题</p>
<p>javac Test.java</p>
<p>cd /opt/software</p>
<p>/opt/software/jdk8u/build/linux-aarch64-normal-server-slowdebug/jdk/bin/java Test </p>
<p>/Users/zhangxuefeng/Library/Java/JavaVirtualMachines/corretto-1.8.0_392/Contents/Home</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./configure --with-debug-level=slowdebug --with-boot-jdk=/Users/zhangxuefeng/Library/Java/JavaVirtualMachines/corretto-<span class="number">1.8</span>.0_392/Contents/Home --enable-debug-symbols</span><br></pre></td></tr></table></figure>
<p>export CC=/opt/homebrew/Cellar/gcc/14.2.0/bin/gcc-14</p>
<p>/opt/homebrew/bin/gcc-14</p>
<p>homebrew安装目录。/opt/homebrew/Cellar</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sh ./configure MAKE=/usr/bin/make \</span><br><span class="line">--with-tools-dir=/opt/homebrew/bin/gcc-<span class="number">14</span> \</span><br><span class="line">--with-debug-level=slowdebug \</span><br><span class="line">--disable-zip-debug-info \</span><br><span class="line">--with-boot-jdk=/Users/zhangxuefeng/Library/Java/JavaVirtualMachines/corretto-<span class="number">1.8</span>.0_392/Contents/Home \</span><br><span class="line">--with-freetype-include=/opt/homebrew/Cellar/freetype/<span class="number">2.13</span>.3/include/freetype2 \</span><br><span class="line">--with-freetype-lib=/opt/homebrew/Cellar/freetype/<span class="number">2.13</span>.3/lib/</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408282237859.png" alt="image-20240828223757771"></p>
<p>vim ~/.bash_profile</p>
<p>alias gcc=’gcc-14’<br>alias g++=’g++-14’<br>alias c++=’c++-14’</p>
<p>source ~/.bash_profile</p>
<p>gcc —version</p>
<p>gcc hhh.cpp -o hhh -lstdc++</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash configure --disable-warnings-as-errors --with-debug-level=slowdebug --with-jvm-variants=server</span><br><span class="line"># disable-warnings-as-errors选项是禁止把warning 当成error</span><br><span class="line"># --with-debug-level=slowdebug。用来设置编译的级别，可选值为release、fastdebug、slowde-bug，越往后进行的优化措施就越少，带的调试信息就越多。</span><br><span class="line">#默认值为release。slowdebug 含有最丰富的调试信息，没有这些信息，很多执行可能被优化掉，我们单步执行时，可能看不到一些变量的值。所以最好指定slowdebug 为编译级别。</span><br><span class="line"># with-jvm-variants 编译特定模式的HotSpot虚拟机，可选值：server、client、minimal、core、zero、custom</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408282357777.png" alt="image-20240828235736688"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo make clean</span><br><span class="line">sudo chmod -R 777 ./*</span><br><span class="line">sudo make images</span><br></pre></td></tr></table></figure>
<p>make CONF=macosx-aarch64-server-slowdebug</p>
<p>build/macosx-aarch64-server-slowdebug/jdk/bin/javac ~/Downloads/jdk-17.0.8.1+1-src/Test.java</p>
<p>build/macosx-aarch64-server-slowdebug/jdk/bin/java Test </p>
<p>pro hand -p true -s false SIGILL SIGSEGV SIGBUS</p>
<p>softwareupdate —install-rosetta</p>
<p>arm-none-eabi-gdb</p>
<h1 id="调试linux源码"><a href="#调试linux源码" class="headerlink" title="调试linux源码"></a>调试linux源码</h1><p>vmware和parallels Desktop创建不了x86的虚拟机,所以用docker创建ubuntu x86版本的容器</p>
<p>在Docker ubuntu编译linux源码,并在Docker ubuntu启动qemu,在本机mac m1启动vscode.</p>
<p>vscode以ssh方式登录ubuntu,连接qemu启动的gdb server来调试编译的linux内核源码</p>
<h2 id="gdb基本使用"><a href="#gdb基本使用" class="headerlink" title="gdb基本使用"></a>gdb基本使用</h2><p><code>target remote :1234</code>连接到 QEMU 的 GDB 服务器</p>
<p>b设置断点</p>
<p>在 GDB 中使用 bt 命令可以打印出当前线程的调用栈（backtrace），这对于调试程序时查看函数调用的历史非常有用</p>
<p>n来单步调试</p>
<p> c代表continue</p>
<h2 id="vscode调试linux内核源码"><a href="#vscode调试linux内核源码" class="headerlink" title="vscode调试linux内核源码"></a>vscode调试linux内核源码</h2><p>写shell脚本开启ssh,启动qemu</p>
<p>start_qemu.sh.sh</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start</span><br><span class="line">cd /root/linux-<span class="number">5.0</span>.1/kernel_test/test_epoll_thundering_herd</span><br><span class="line">qemu-system-x86_64 -curses -kernel ../../arch/x86/boot/bzImage -initrd ../rootfs.img -append nokaslr -S -s</span><br></pre></td></tr></table></figure>
<p>这里的 -s 和 -S 选项用于启用 GDB 调试</p>
<p><strong>在vscode设置断点</strong></p>
<p>main.c的start_kernel处打断点</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408292000617.png" alt="image-20240829200035515"></p>
<p><strong>vscode配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"kernel-debug"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"miDebuggerServerAddress"</span>: <span class="string">"127.0.0.1:1234"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/vmlinux"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="keyword">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="keyword">false</span>,</span><br><span class="line">            <span class="string">"logging"</span>: &#123;</span><br><span class="line">                <span class="string">"engineLogging"</span>: <span class="keyword">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>./start_qemu.sh.sh</code>启动qemu</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291957672.png" alt="image-20240829195721573"></p>
<p>vscode开启调试后</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291948450.png" alt="image-20240829194850385"></p>
<p>vscode停在断点start_kernel处</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408291950547.png" alt="image-20240829195024472"></p>
<p>参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/445453676" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/445453676</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MarkDown语法]]></title>
      <url>/p/8vzha/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><p><strong>语法:</strong></p>
<p><code>&lt;font size=5&gt;字体大小size=5&lt;/font&gt;</code></p>
<p><strong>效果:</strong></p>
<font size="5">字体大小size=5</font>

<h2 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h2><p><strong>语法:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=red&gt;红色&lt;/font&gt;</span><br><span class="line">&lt;font color=green&gt;绿色&lt;/font&gt;</span><br><span class="line">&lt;font color=blue&gt;蓝色&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p><strong>效果:</strong></p>
<font color="red">红色</font>

<font color="green">绿色</font>

<font color="blue">蓝色</font>

<h2 id="字体类型"><a href="#字体类型" class="headerlink" title="字体类型"></a>字体类型</h2><p><strong>语法:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face="黑体"&gt;黑体&lt;/font&gt;</span><br><span class="line">&lt;font face="宋体"&gt;宋体&lt;/font&gt;</span><br><span class="line">&lt;font face="仿宋"&gt;仿宋&lt;/font&gt;</span><br><span class="line">&lt;font face="幼圆"&gt;幼圆&lt;/font&gt;</span><br><span class="line">&lt;font face="楷书"&gt;楷书&lt;/font&gt;</span><br><span class="line">&lt;font face="华文行楷"&gt;华文行楷&lt;/font&gt;</span><br><span class="line">&lt;font face="华文隶书"&gt;华文隶书&lt;/font&gt;</span><br><span class="line">&lt;font face="华文新魏"&gt;华文新魏&lt;/font&gt;</span><br><span class="line">&lt;font face="华文彩云"&gt;华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font face="华文琥珀"&gt;华文琥珀&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p><strong>效果:</strong></p>
<font face="黑体">黑体</font>
<font face="宋体">宋体</font>
<font face="仿宋">仿宋</font>
<font face="幼圆">幼圆</font>
<font face="楷书">楷书</font>
<font face="华文行楷">华文行楷</font>
<font face="华文隶书">华文隶书</font>
<font face="华文新魏">华文新魏</font>
<font face="华文彩云">华文彩云</font>
<font face="华文琥珀">华文琥珀</font>

<h2 id="字体颜色-1"><a href="#字体颜色-1" class="headerlink" title="字体颜色"></a>字体颜色</h2><p><strong>语法:</strong></p>
<p><code>&lt;font color=&quot;Blue&quot;&gt;蓝色&lt;/font&gt;</code></p>
<font color="Red">红色</font>

<p><strong>效果:</strong></p>
<h2 id="字体背景色"><a href="#字体背景色" class="headerlink" title="字体背景色"></a>字体背景色</h2><p><strong>语法:</strong></p>
<p><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p>
<p><strong>效果:</strong></p>
<table><tr><td bgcolor="orange">背景色orange</td></tr></table>

<h2 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h2><p><strong>语法:</strong></p>
<p><code>**字体加粗**</code></p>
<p><strong>效果:</strong></p>
<p><strong>字体加粗</strong></p>
<h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p><strong>语法:</strong></p>
<p><code>*斜体*</code></p>
<p><strong>效果:</strong></p>
<p><em>斜体</em></p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p><strong>语法:</strong></p>
<p><code>&lt;u&gt;文本&lt;/u&gt;</code></p>
<p><strong>效果:</strong></p>
<p><u>文本</u></p>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><strong>语法:</strong></p>
<p><code>~~文本~~</code></p>
<p><strong>效果:</strong></p>
<p><del>文本</del></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="文本高亮"><a href="#文本高亮" class="headerlink" title="文本高亮"></a>文本高亮</h2><p><strong>语法:</strong></p>
<p><code>&lt;mark&gt;文本高亮&lt;/mark&gt;</code></p>
<p><strong>效果:</strong></p>
<p><mark>文本高亮</mark></p>
<hr>
<p><strong>语法:</strong></p>
<p><code>&lt;font style=background:red&gt;test&lt;/font&gt;</code></p>
<p><strong>效果:</strong></p>
<font style="background:red">test</font>

<h2 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h2><p><strong>语法:</strong></p>
<p><code>&lt;center&gt;文本居中&lt;/center&gt;</code></p>
<p><strong>效果:</strong></p>
<center>文本居中</center>







]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty框架学习]]></title>
      <url>/p/8vwl7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IO流</p>
<p>java NIO</p>
<p>read系统调用不会在内核数据准备阶段阻塞认为是非阻塞的 但是cpu空转浪费cpu</p>
<p>配合selector。selector可避免cpu空转</p>
<p>IO多路复用</p>
<p>select poll epoll</p>
<p>Select 1024的限制 </p>
<p>poll </p>
<p>epoll</p>
<p>边缘和水平</p>
<p>java NIO 是水平。只要有数据没处理会一直有事件</p>
<p>SelectionKey =ssc.register(selector)</p>
<p>selector 包含感兴趣的事件。 就绪事件</p>
<p>就绪事件不处理selector.select方法不会阻塞 </p>
<p>处理完后要手动去除就绪事件  nio本身并不会从集合中除去</p>
<p>下次再有事件就绪,对就绪事件遍历处理时。会有空指针异常</p>
<p>Selector  channel. Buffer</p>
<p>直接内存和堆内存</p>
<p>Netty基本概念</p>
<p>Netty实现rpc</p>
<p>Netty启动流程源码分析</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java日志框架]]></title>
      <url>/p/8vwaz/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="日志框架简介"><a href="#日志框架简介" class="headerlink" title="日志框架简介"></a>日志框架简介</h1><p><strong>问题：</strong></p>
<ol>
<li>控制日志输出的内容和格式</li>
<li>控制日志输出的位置</li>
<li>日志优化：异步日志，日志文件的归档和压缩</li>
<li>日志系统的维护</li>
<li>面向接口开发 — 日志的门面</li>
</ol>
<h2 id="现有的日志框架"><a href="#现有的日志框架" class="headerlink" title="现有的日志框架"></a>现有的日志框架</h2><p>JUL（java util logging）、logback、log4j、log4j2<br>JCL（Jakarta Commons Logging）、slf4j（ Simple Logging Facade for Java）</p>
<h3 id="日志门面"><a href="#日志门面" class="headerlink" title="日志门面"></a>日志门面</h3><p>JCL、slf4j</p>
<h3 id="日志实现"><a href="#日志实现" class="headerlink" title="日志实现"></a>日志实现</h3><p>JUL、logback、log4j、log4j2</p>
<p>JUL 学习<br>JUL全称Java util Logging是java原生的日志框架，使用时不需要另外引用第三方类库，相对其他日志框<br>架使用方便，学习简单，能够在小型应用中灵活使用。</p>
<ul>
<li>Loggers：被称为记录器，应用程序通过获取Logger对象，调用其API来来发布日志信息。Logger<br>通常时应用程序访问日志系统的入口程序。<br>Appenders：也被称为Handlers，每个Logger都会关联一组Handlers，Logger会将日志交给关联</li>
<li>Handlers处理，由Handlers负责将日志做记录。Handlers在此是一个抽象，其具体的实现决定了<br>日志记录的位置可以是控制台、文件、网络上的其他日志服务或操作系统日志等。</li>
<li>Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了<br>数据在一条日志记录中的最终形式。</li>
<li>Level：每条日志消息都有一个关联的日志级别。该级别粗略指导了日志消息的重要性和紧迫，我<br>可以将Level和Loggers，Appenders做关联以便于我们过滤消息。</li>
<li>Filters：过滤器，根据需要定制哪些信息会被记录，哪些信息会被放过。</li>
</ul>
<p>用户使用Logger来进行日志记录，Logger持有若干个Handler，日志的输出操作是由Handler完成的。<br>在Handler在输出日志前，会经过Filter的过滤，判断哪些日志级别过滤放行哪些拦截，Handler会将日<br>志内容输出到指定位置（日志文件、控制台等）。Handler在输出日志时会使用Layout，将输出内容进<br>行排版。</p>
<p>Logger之间的父子关系<br>JUL中Logger之间存在父子关系，这种父子关系通过树状结构存储，JUL在初始化时会创建一个顶层<br>RootLogger作为所有Logger父Logger，存储上作为树状结构的根节点。并父子关系通过路径来关联。</p>
<p>LOG4J 学习<br>Log4j是Apache下的一款开源的日志框架，通过在项目中使用 Log4J，我们可以控制日志信息输出到控<br>制台、文件、甚至是数据库中。我们可以控制每一条日志的输出格式，通过定义日志的输出级别，可以<br>更灵活的控制日志的输出过程。方便项目的调试</p>
<blockquote>
<p>注：一般只使用4个级别，优先级从高到低为 ERROR &gt; WARN &gt; INFO &gt; DEBUG</p>
</blockquote>
<p>Log4j组件<br>Log4J 主要由 Loggers (日志记录器)、Appenders（输出端）和 Layout（日志格式化器）组成。其中<br>Loggers 控制日志的输出级别与日志是否输出；Appenders 指定日志的输出方式（输出到控制台、文件<br>等）；Layout 控制日志信息的输出格式。</p>
<p>Loggers<br>日志记录器，负责收集处理日志记录，实例的命名就是类“XX”的full quailied name（类的全限定名），<br>Logger的名字大小写敏感，其命名有继承机制：例如：name为org.apache.commons的logger会继承<br>name为org.apache的logger。<br>Log4J中有一个特殊的logger叫做“root”，他是所有logger的根，也就意味着其他所有的logger都会直接<br>或者间接地继承自root。root logger可以用Logger.getRootLogger()方法获取。</p>
<p>我们为什么要使用日志门面：</p>
<ol>
<li>面向接口开发，不再依赖具体的实现类。减少代码的耦合</li>
<li>项目通过导入不同的日志实现类，可以灵活的切换日志框架</li>
<li>统一API，方便开发者学习和使用</li>
<li>统一配置便于项目日志的管理</li>
</ol>
<ol>
<li>日志门面和日志体系</li>
<li>SLF4J</li>
<li>logback的使用</li>
<li>log4j2的使用</li>
<li>SpringBoot中的日志使用</li>
</ol>
<p>日志框架出现的历史顺序：<br>log4j —&gt;JUL—&gt;JCL—&gt; slf4j —&gt; logback —&gt; log4j2</p>
<p>对于一般的Java项目而言，日志框架<br>会选择slf4j-api作为门面，配上具体的实现框架（log4j、logback等），中间使用桥接器完成桥接</p>
<p>SLF4J日志门面主要提供两大功能：</p>
<ol>
<li>日志框架的绑定</li>
<li>日志框架的桥接</li>
</ol>
<p>使用slf4j的日志绑定流程:</p>
<ol>
<li>添加slf4j-api的依赖</li>
<li>使用slf4j的API在项目中进行统一的日志记录</li>
<li>绑定具体的日志实现框架</li>
<li>绑定已经实现了slf4j的日志框架,直接添加对应依赖</li>
<li>绑定没有实现slf4j的日志框架,先添加日志的适配器,再添加实现类的依赖</li>
<li>slf4j有且仅有一个日志实现框架的绑定（如果出现多个默认使用第一个依赖日志实现）</li>
</ol>
<p>SLF4J原理解析</p>
<ol>
<li>SLF4J通过LoggerFactory加载日志具体的实现对象。</li>
<li>LoggerFactory在初始化的过程中，会通过performInitialization()方法绑定具体的日志实现。</li>
<li>在绑定具体实现的时候，通过类加载器，加载org/slf4j/impl/StaticLoggerBinder.class</li>
<li>所以，只要是一个日志实现框架，在org.slf4j.impl包中提供一个自己的StaticLoggerBinder类，在<br>其中提供具体日志实现的LoggerFactory就可以被SLF4J所加载</li>
</ol>
<p>logback组件之间的关系</p>
<ol>
<li>Logger:日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也<br>可以定义日志类型、级别。</li>
<li>Appender:用于指定日志输出的目的地，目的地可以是控制台、文件、数据库等等。</li>
<li>Layout:负责把事件转换成字符串，格式化的日志信息的输出。在logback中Layout对象被封<br>装在encoder中</li>
</ol>
<p>springboot<br>默认就是使用SLF4J作为日志门面，logback作为日志实现来记录日志</p>
<p>解析xml dom4j.   </p>
<p>dtd  schema 约束</p>
<p>log4j2默认error</p>
<p>logback默认debug</p>
<p>jul默认info</p>
<p>logback日志输出格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">-5level</span></span><br><span class="line"><span class="meta">%</span><span class="bash">d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;日期</span></span><br><span class="line"><span class="meta">%</span><span class="bash">c类的完整名称</span></span><br><span class="line"><span class="meta">%</span><span class="bash">M为method</span></span><br><span class="line"><span class="meta">%</span><span class="bash">L为行号</span></span><br><span class="line"><span class="meta">%</span><span class="bash">thread线程名称</span></span><br><span class="line"><span class="meta">%</span><span class="bash">m或者%msg为信息</span></span><br><span class="line"><span class="meta">%</span><span class="bash">n换行</span></span><br></pre></td></tr></table></figure>
<p>桥接器</p>
<p>Log4j-to-slf4j</p>
<p>Jul-to-slf4j</p>
<p>slf4j默认使用第1个日志实现框架。有多个会警告不会报错</p>
<p>log4j和jul要使用slf4j适配器</p>
<p>jul。rootLogger也是从配置文件解析的,jre下的logging.properties.  logManager</p>
<p>自己设置用自己的,没设置用父亲的配置.  有点像多态</p>
<p>以.分隔 只创建一个 没有创建上层,父亲是rootlogger 创建后会变化</p>
<p>processParentHandlers</p>
<p>alt+鼠标左键拖动</p>
<p>在Logback中，Logger 实例之间存在父子关系，这些关系基于它们的名称，也就是它们的完全限定类名或者由用户指定的名称。当你创建一个 Logger 时，如果没有显式指定父 Logger，Logback 会自动为它设置一个父 Logger。</p>
<p>例如，如果你创建了一个名为 <code>com.example.MyClass</code> 的 Logger，而没有显式地指定父 Logger，那么它的父 Logger 将是 <code>com.example</code>。如果 <code>com.example</code> 不存在，则会向上查找直到根 Logger (<code>root</code>)</p>
<p>Logback.  loggerFactory</p>
<p>Logback  会按.分隔逐个创建</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[maven插件体系]]></title>
      <url>/p/8vvcg/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h2><p>依赖具有传递性</p>
<ul>
<li>直接依赖。在当前项目中通过依赖配置建立的依赖关系</li>
<li>间接依赖。被依赖的资源如果依赖其他资源,当前项目间接依赖其他资源</li>
</ul>
<h3 id="依赖传递冲突问题"><a href="#依赖传递冲突问题" class="headerlink" title="依赖传递冲突问题"></a>依赖传递冲突问题</h3><p>同样资源但版本不同</p>
<p>路径优先 越靠近本项目优先级越高</p>
<p>声明优先 除了1度,同级别谁在前谁有效</p>
<p>特殊优先 当前项目直接配置的依赖(1度),同级别谁在后谁有效,覆盖</p>
<h2 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h2><p>可选依赖对外隐藏当前所依赖的资源。不透明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖的jar默认情况可以在任何地方使用,可通过scope标签设定其作用范围</p>
<p>作用范围</p>
<p>主程序范围有效(main文件夹范围内)</p>
<p>测试程序范围有效(test文件夹范围内)</p>
<p>是否参与打包(package指令范围内)</p>
<p>compile（编译依赖范围）：使用此依赖范围的Maven 依赖，对于编译、测试、运行三种classpath 都有效。典型的例子是spring-core,在编译、测试和运行的时候都需要使用该依赖。<br>test（测试依赖范围）：只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是junit,它只有在编译测试代码及运行测试的时候才需要。<br>provided：对于编译和测试classpath有效，但在运行时无效。典型的例子是 servlet-api,，编译和测试项目的时候需要该依赖，假如需要打包成war然后放到tomcat当中运行，由于tomcat已经提供，就不需要Maven重复地引入一遍。所以将 scope 设置为 provided 的依赖不会参与项目的war打包。假如打包为jar，设置与不设置provided并不会影响maven将依赖打包到jar当中</p>
<p>runtime（运行时依赖范围）： 运行时依赖范围：对于测试和运行class-path有效，但在编译主代码时无效（对编译的classpath无效）。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。<br>system（系统依赖范围）：与<code>provided</code>相同，但是需要手动指定依赖文件路径,需要引用第三方本地jar包的时候使用. <a href="https://blog.csdn.net/weixin_43888891/article/details/130611728" target="_blank" rel="noopener">参考</a></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408241921920.png" alt="image-20240824192125794"></p>
<h3 id="依赖范围传递性"><a href="#依赖范围传递性" class="headerlink" title="依赖范围传递性"></a>依赖范围传递性</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408241937614.png" alt="image-20240824193714454"></p>
<ul>
<li><code>provided</code> 与 <code>test</code> 范围不会向上传递。</li>
<li><code>compile</code> 范围在向上传递的时候，间接依赖于直接依赖的范围一致。</li>
<li><code>runtime</code> 范围与 <code>compile</code> 类似，区别在于直接依赖为<code>compile</code>时，间接依赖的范围依然是<code>runtime</code></li>
</ul>
<h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><ol>
<li><p>mvn 指令 –D skipTests</p>
</li>
<li><p>idea设置</p>
</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408242012554.png" alt="image-20240824201233381"></p>
<ol>
<li>maven-surefire-plugin插件配置</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt; </span><br><span class="line">  &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; </span><br><span class="line">  &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">  &lt;configuration&gt;</span><br><span class="line">  &lt;skipTests&gt;true&lt;/skipTests&gt;&lt;!-- 设置跳过测试--&gt;</span><br><span class="line">  &lt;includes&gt;  &lt;!-- 包含指定测试用例        --&gt;</span><br><span class="line">  			&lt;include&gt;**/User*Test.java&lt;/include&gt;</span><br><span class="line">  &lt;/includes&gt;  </span><br><span class="line">  &lt;excludes&gt;&lt;!--  排除指定测试用例  --&gt; </span><br><span class="line">  			&lt;exclude&gt;**/User*TestCase.java&lt;/exclude&gt;</span><br><span class="line">  &lt;/excludes&gt; </span><br><span class="line">  &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408241847081.png" alt="image-20240824184722960"></p>
<p>常用插件<br>maven-source-plugin<br>maven-assembly-plugin<br>maven-shade-plugin<br>maven-antrun-plugin</p>
<p>maven-surefire-plugin  运行单元测试</p>
<p>proguard-maven-plugin</p>
<p>制作fat-jar</p>
<p>maven-assembly-plugin,maven-shade-plugin 依赖jar会解压平铺</p>
<p>spring-boot-maven-plugin 依赖jar还是jar包形式存在于打包的jar中,Main-Class是JarLauncher,会调用Start-Class(也就是应用程序真正的启动类)</p>
<p>单元测试覆盖率 jacoco.  emma。增量怎么配置</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408112159053.png" alt="image-20240811215932491"></p>
<p>Mockito  不能测private方法。powermock可以测private方法</p>
<p>mockito配合junit4或junit5完成单元测试,包含mockito的参数匹配、常用注解如@Mock/@Spy/@InjectMocks等、以及一些常用插桩方法、verify、断言的使用</p>
<p>junit4 Assert</p>
<p>Junit5 Assertions</p>
<p>虚拟外部依赖 如redis,db,第三方接口调用</p>
<p>Input to output</p>
<p>mock对象(返回mock对象默认值)和spy对象(调用真实方法)</p>
<p>参数匹配</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// anyXXX() 不包括<span class="literal">null</span> <span class="keyword">any</span>()包括<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>指定返回值</p>
<p>插桩</p>
<p>mock不插桩返回默认值</p>
<p>spy不插桩调用真实方法</p>
<p>doXXX.    Mock/spy.    或无返回值</p>
<p>When(). thenXXX.  Mock.   (spy用这种写法会调用真实方法 然后再返回指定值)</p>
<p>抛出异常</p>
<p>doThrow()</p>
<p>thenAnswer,doAnswer指定插桩逻辑</p>
<p>@InjectMocks注解。必须是实现类</p>
<p>spring使用 @MockBean @SpyBean</p>
<p>TestMe插件生成单元测试代码</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[泛型基础]]></title>
      <url>/p/8vvcf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>JAVA推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，需要程序员明确知道存储每个元素的数据类型，否则很容易引发ClassCastException异常。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>类型参数化 </li>
<li>编译期间检查类型</li>
<li>减少了数据类型转换</li>
</ul>
<h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p><strong>概述</strong></p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识，泛型标识，…&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 变量名; </span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名&lt;具体的数据类型&gt; 对象名 = <span class="keyword">new</span> 类名&lt;具体的数据类型&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>Java1.7以后，后面的&lt;&gt;中的具体的数据类型可以省略不写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名&lt;具体的数据类型&gt; 对象名 = <span class="keyword">new</span> 类名&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>泛型类注意事项</strong></p>
<ul>
<li>泛型类，如果没有指定具体的数据类型，此时，操作类型是Object</li>
<li>泛型的类型参数只能是类类型，不能是基本数据类型</li>
<li>泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型</li>
</ul>
<p><strong>从泛型类派生子类</strong></p>
<p>子类也是泛型类，子类和父类的泛型类型要一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildGeneric</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子类不是泛型类，父类要明确泛型的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildGeneric</span> <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">String</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称 &lt;泛型标识，泛型标识，…&gt; </span>&#123;</span><br><span class="line">  泛型标识 方法名(); </span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>泛型接口的使用</strong></p>
<ul>
<li>实现类不是泛型类，接口要明确数据类型</li>
<li>实现类也是泛型类，实现类和接口的泛型类型要一致</li>
</ul>
<h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T，E, ...&gt; 返回值类型 方法名(形参列表) &#123;</span><br><span class="line">    方法体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>public与返回值中间<t>非常重要，可以理解为声明此方法为泛型方法。</t></li>
<li>只有声明了<t>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</t></li>
<li><t>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</t></li>
<li>与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</li>
</ul>
<p><strong>泛型方法与可变参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(E... e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E e1 : e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>泛型方法总结</strong></p>
<ul>
<li>泛型方法能使方法独立于类而产生变化</li>
<li>如果static方法要使用泛型能力，就必须使其成为泛型方法</li>
</ul>
<blockquote>
<p>static方法是可以在类加载后就可以调用的,而泛型类的泛型标识是需要具体对象实例化时传入实际类型的,</p>
<p>所以泛型类的泛型标识不能用在static方法上,而泛型方法的标识是方法调用时传入实际类型的,</p>
<p>所以泛型方法可以用在static方法上</p>
</blockquote>
<p><strong>泛型类和泛型方法区分</strong></p>
<ul>
<li>泛型类，是在实例化类的时候指明泛型的具体类型</li>
<li>泛型方法，是在调用方法的时候指明泛型的具体类型</li>
</ul>
<blockquote>
<p> 举例说明</p>
</blockquote>
<ol>
<li>虽然泛型类和泛型方法都用标识T,但此时getProduct方法参数可以传任意类型的ArrayList,不用和ProductGetter对象创建时类型保持一致</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductGetter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型标识，具体类型，由调用方法的时候来指定。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K,T&gt; <span class="function">T <span class="title">getProduct</span><span class="params">(ArrayList&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这不是泛型方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductGetter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型标识，具体类型，由调用方法的时候来指定。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getProduct</span><span class="params">(ArrayList&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法定义如果用了和泛型类一样的标识,此时标识是泛型方法的标识,不需要和对象创建时类型保持一致</p>
<p>否则是泛型类的标识,要和对象创建时类型保持一致,调用方法时传递实际参数</p>
<h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h1><p><strong>什么是类型通配符？</strong></p>
<p>类型通配符一般是使用”?”代替具体的类型实参。类型通配符是类型实参，而不是类型形参。上界extends.   下界super.</p>
<p>一般在定义方法参数时使用,调用方法时指定具体类型</p>
<p><strong>类型通配符的上限</strong></p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类/接口&lt;? <span class="keyword">super</span> 实参类型&gt;</span><br></pre></td></tr></table></figure>
<p>要求该泛型的类型，只能是实参类型，或实参类型的子类类型</p>
<p><strong>类型通配符的下限</strong></p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类/接口&lt;? <span class="keyword">super</span> 实参类型&gt;</span><br></pre></td></tr></table></figure>
<p>要求该泛型的类型，只能是实参类型，或实参类型的父类类型</p>
<p><strong>实例</strong></p>
<p>ArrayList#addAll(Collection&lt;? extends E&gt; c).   E是泛型类标识</p>
<p>TreeSet两个构造方法,E是泛型类标识</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Comparator传E的父类 (创建对象时先创建父对象,父对象的字段可以获得,可以用来排序)</p>
<p>Collection传E的子类</p>
<p>泛型类和泛型方法可以使用extends不可以使用super</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassExtends</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">List</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;T extends List&gt; <span class="function">T <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><p><strong>概念</strong></p>
<p>泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是，泛型代码能够很好地和之前版本的代码兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为—类型擦除。</p>
<p><strong>无限制类型擦除</strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221026291.png" alt="image-20240822102659184"></p>
<p><strong>有限制类型擦除</strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221206270.png" alt="image-20240822120644180"></p>
<p><strong>擦除方法中类型定义的参数</strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221027000.png" alt="image-20240822102738903"></p>
<p><strong>桥接方法</strong> </p>
<p>类型擦除和多态发生冲突的解决办法</p>
<p>保持接口和类的实现关系</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221029730.png" alt="image-20240822102906634"></p>
<p>实例</p>
<ol>
<li>接口实现类不是泛型类，父类是泛型接口</li>
</ol>
<ul>
<li>泛型接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">info</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口实现类不是泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span> <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">info</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看字节码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature Ljava/lang/Object;Lcom/itheima/demo9/Info&lt;Ljava/lang/Integer;&gt;;</span></span><br><span class="line"><span class="comment">// declaration: com/itheima/demo9/InfoImpl implements com.itheima.demo9.Info&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>/<span class="title">itheima</span>/<span class="title">demo9</span>/<span class="title">InfoImpl</span> <span class="keyword">implements</span> <span class="title">com</span>/<span class="title">itheima</span>/<span class="title">demo9</span>/<span class="title">Info</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: InfoImpl.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">3</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/itheima/demo9/InfoImpl; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">info</span><span class="params">(Ljava/lang/Integer;)</span>Ljava/lang/Integer</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">6</span> L0</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/itheima/demo9/InfoImpl; L0 L1 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE value Ljava/lang/Integer; L0 L1 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1041</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> synthetic bridge <span class="title">info</span><span class="params">(Ljava/lang/Object;)</span>Ljava/lang/Object</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">3</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    CHECKCAST java/lang/Integer</span><br><span class="line">    INVOKEVIRTUAL com/itheima/demo9/InfoImpl.info (Ljava/lang/Integer;)Ljava/lang/Integer;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/itheima/demo9/InfoImpl; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synthetic bridge标识的就是桥接方法,实现多态,内部调用具体类型的方法,在这里是Integer类型</p>
<ul>
<li>反射验证</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;InfoImpl&gt; infoClass = InfoImpl.class;</span><br><span class="line">        <span class="comment">//获取所有的方法</span></span><br><span class="line">        Method[] infoImplMethods = infoClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : infoImplMethods) &#123;</span><br><span class="line">            <span class="comment">//打印方法名和方法的返回值类型。</span></span><br><span class="line">            System.out.println(method.getName() + <span class="string">":"</span> + method.getReturnType().getSimpleName());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<center><u>输出结果</u></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info:Integer</span><br><span class="line">info:Object</span><br></pre></td></tr></table></figure>
<ol>
<li>子类不是泛型类，父类是泛型类</li>
</ol>
<p>不是泛型的类继承泛型类也会有桥接方法</p>
<ul>
<li>泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类不是泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类派生子类，如果子类不是泛型类，那么父类要明确数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildSecond</span> <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看字节码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature Lcom/itheima/demo4/Parent&lt;Ljava/lang/Integer;&gt;;</span></span><br><span class="line"><span class="comment">// declaration: com/itheima/demo4/ChildSecond extends com.itheima.demo4.Parent&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>/<span class="title">itheima</span>/<span class="title">demo4</span>/<span class="title">ChildSecond</span> <span class="keyword">extends</span> <span class="title">com</span>/<span class="title">itheima</span>/<span class="title">demo4</span>/<span class="title">Parent</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: ChildSecond.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">6</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL com/itheima/demo4/Parent.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/itheima/demo4/ChildSecond; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getValue</span><span class="params">()</span>Ljava/lang/Integer</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">9</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL com/itheima/demo4/Parent.getValue ()Ljava/lang/Object;</span><br><span class="line">    CHECKCAST java/lang/Integer</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/itheima/demo4/ChildSecond; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setValue</span><span class="params">(Ljava/lang/Integer;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 14 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    INVOKESPECIAL com/itheima/demo4/Parent.<span class="title">setValue</span> <span class="params">(Ljava/lang/Object;)</span>V</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 15 L1</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L2</span></span><br><span class="line"><span class="function">    LOCALVARIABLE <span class="keyword">this</span> Lcom/itheima/demo4/ChildSecond</span>; L0 L2 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE value Ljava/lang/Integer; L0 L2 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1041</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> synthetic bridge <span class="title">setValue</span><span class="params">(Ljava/lang/Object;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 6 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    CHECKCAST java/lang/Integer</span></span><br><span class="line"><span class="function">    INVOKEVIRTUAL com/itheima/demo4/ChildSecond.<span class="title">setValue</span> <span class="params">(Ljava/lang/Integer;)</span>V</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LOCALVARIABLE <span class="keyword">this</span> Lcom/itheima/demo4/ChildSecond</span>; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1041</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> synthetic bridge <span class="title">getValue</span><span class="params">()</span>Ljava/lang/Object</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">6</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKEVIRTUAL com/itheima/demo4/ChildSecond.getValue ()Ljava/lang/Integer;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/itheima/demo4/ChildSecond; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synthetic bridge标识的就是桥接方法,实现多态,内部调用具体类型的方法,在这里是Integer类型</p>
<h1 id="泛型与数组"><a href="#泛型与数组" class="headerlink" title="泛型与数组"></a>泛型与数组</h1><p>通过Array.newInstance()创建泛型数组</p>
<p><strong>泛型数组的创建</strong></p>
<ul>
<li>可以声明带泛型的数组引用，但是不能直接创建带泛型的数组对象</li>
<li>可以通过java.lang.reflect.Array的newInstance(Class<t>,int)创建T[]数组</t></li>
</ul>
<p><strong>示例</strong></p>
<ul>
<li>一个带泛型数组字段的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(Class&lt;T&gt; clz, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过Array.newInstance创建泛型数组</span></span><br><span class="line">        array = (T[])Array.newInstance(clz, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 填充数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Fruit&lt;String&gt; fruit = <span class="keyword">new</span> Fruit&lt;&gt;(String.class,<span class="number">3</span>);</span><br><span class="line">    fruit.put(<span class="number">0</span>,<span class="string">"苹果"</span>);</span><br><span class="line">    fruit.put(<span class="number">1</span>,<span class="string">"西瓜"</span>);</span><br><span class="line">    fruit.put(<span class="number">2</span>,<span class="string">"香蕉"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(fruit.getArray()));</span><br><span class="line">    String s1 = fruit.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(s1);</span><br></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[苹果, 西瓜, 香蕉]</span><br><span class="line">香蕉</span><br></pre></td></tr></table></figure>
<h1 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h1><p>反射常用泛型类</p>
<p>Class<t>  </t></p>
<p>Constructor<t></t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        Class&lt;Person&gt; personClass = Person.class;</span></span><br><span class="line"><span class="comment">//        Constructor&lt;Person&gt; constructor = personClass.getConstructor();</span></span><br><span class="line"><span class="comment">//        Person person = constructor.newInstance();</span></span><br><span class="line"><span class="comment">//        System.out.println (person.getName ());</span></span><br><span class="line"></span><br><span class="line">        Class personClass = Person.class;</span><br><span class="line">        Constructor constructor = personClass.getConstructor();</span><br><span class="line">        Person o = (Person)constructor.newInstance();</span><br><span class="line">        System.out.println (o.getName ());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>不用反射泛型类就需要进行强制类型转换</p>
]]></content>
      
        
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RocketMQ源码梳理]]></title>
      <url>/p/8vuhb/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rocketmq集群搭建"><a href="#rocketmq集群搭建" class="headerlink" title="rocketmq集群搭建"></a>rocketmq集群搭建</h1><h2 id="主机节点规划"><a href="#主机节点规划" class="headerlink" title="主机节点规划"></a>主机节点规划</h2><p><strong>Hosts文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">172.16</span>.117.103 node3</span><br><span class="line"><span class="number">172.16</span>.117.104 node4</span><br><span class="line"><span class="number">172.16</span>.117.105 node5</span><br><span class="line"><span class="number">172.16</span>.117.106 node6</span><br><span class="line"># nameserver</span><br><span class="line"><span class="number">172.16</span>.117.103 rocketmq-nameserver1</span><br><span class="line"><span class="number">172.16</span>.117.104 rocketmq-nameserver2</span><br><span class="line"># broker</span><br><span class="line"><span class="number">172.16</span>.117.103 rocketmq-master1</span><br><span class="line"><span class="number">172.16</span>.117.104 rocketmq-master2</span><br><span class="line"><span class="number">172.16</span>.117.105 rocketmq-slave1</span><br><span class="line"><span class="number">172.16</span>.117.106 rocketmq-slave2</span><br></pre></td></tr></table></figure>
<p><strong>nameserver</strong></p>
<ul>
<li>node3,node4</li>
</ul>
<p><strong>broker</strong></p>
<ul>
<li><strong>master:</strong>  node3 ,node4</li>
<li><strong>slave:</strong>    node5,node6</li>
</ul>
<p>消息存储路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/store</span><br><span class="line">mkdir /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/store/commitlog</span><br><span class="line">mkdir /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/store/consumequeue</span><br><span class="line">mkdir /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/store/index</span><br></pre></td></tr></table></figure>
<h2 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h2><ol>
<li>nameserver启动</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># node3</span><br><span class="line">cd /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/bin</span><br><span class="line">nohup sh mqnamesrv &amp;</span><br><span class="line">  </span><br><span class="line"># node4</span><br><span class="line">cd /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/bin</span><br><span class="line">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>
<ol>
<li>broker启动</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># node3</span><br><span class="line">cd /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/bin</span><br><span class="line">nohup sh mqbroker -c /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/conf/<span class="number">2</span>m-<span class="number">2</span>s-sync/broker-a.properties &amp;</span><br><span class="line"></span><br><span class="line"># node4</span><br><span class="line">cd /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/bin</span><br><span class="line">nohup sh mqbroker -c /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/conf/<span class="number">2</span>m-<span class="number">2</span>s-sync/broker-b.properties &amp;</span><br><span class="line"></span><br><span class="line"># node5</span><br><span class="line">cd /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/bin</span><br><span class="line">nohup sh mqbroker -c /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/conf/<span class="number">2</span>m-<span class="number">2</span>s-sync/broker-a-s.properties &amp;</span><br><span class="line"></span><br><span class="line"># node6</span><br><span class="line">cd /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/bin</span><br><span class="line">nohup sh mqbroker -c /opt/software/rocketmq-all-<span class="number">4.4</span>.0-bin-release/conf/<span class="number">2</span>m-<span class="number">2</span>s-sync/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>
<p>启动后可以用jps查看</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p><strong>命令行:</strong>  mqadmin</p>
<p><strong>网页可视化:</strong> rocketmq-console</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># node3</span><br><span class="line">cd /opt/software</span><br><span class="line">nohup java -jar rocketmq-console-ng-<span class="number">1.0</span>.0.jar &amp;</span><br></pre></td></tr></table></figure>
<p>打开浏览器输入<code>node3:9999</code></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409021911101.png" alt="image-20240902191144865"></p>
<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><ul>
<li>导入MQ客户端依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>消息发送者步骤分析r</li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建消息生产者producer，并制定生产者组名</span><br><span class="line">2.指定Nameserver地址</span><br><span class="line">3.启动producer</span><br><span class="line">4.创建消息对象，指定主题Topic、Tag和消息体</span><br><span class="line">5.发送消息</span><br><span class="line">6.关闭生产者producer</span><br></pre></td></tr></table></figure>
<ul>
<li>消息消费者步骤分析</li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建消费者Consumer，制定消费者组名</span><br><span class="line">2.指定Nameserver地址</span><br><span class="line">3.订阅主题Topic和Tag</span><br><span class="line">4.设置回调函数，处理消息</span><br><span class="line">5.启动消费者consumer</span><br></pre></td></tr></table></figure>
<h2 id="基本样例"><a href="#基本样例" class="headerlink" title="基本样例"></a>基本样例</h2><h3 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h3><h4 id="1）发送同步消息"><a href="#1）发送同步消息" class="headerlink" title="1）发送同步消息"></a>1）发送同步消息</h4><p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    	producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    	    <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">    	    Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">        	<span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">        	(<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        	);</span><br><span class="line">        	<span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）发送异步消息"><a href="#2）发送异步消息" class="headerlink" title="2）发送异步消息"></a>2）发送异步消息</h4><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      	              System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">      	              e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            	&#125;);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3）单向发送消息"><a href="#3）单向发送消息" class="headerlink" title="3）单向发送消息"></a>3）单向发送消息</h4><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        	Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        	);</span><br><span class="line">        	<span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        	producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><h4 id="1）负载均衡模式"><a href="#1）负载均衡模式" class="headerlink" title="1）负载均衡模式"></a>1）负载均衡模式</h4><p>消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同(默认)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</span><br><span class="line">    <span class="comment">// 指定Namesrv地址信息.</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 订阅Topic</span></span><br><span class="line">    consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</span><br><span class="line">    <span class="comment">//负载均衡模式消费</span></span><br><span class="line">    consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">    <span class="comment">// 注册回调函数，处理消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, </span><br><span class="line">                              Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消息者</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）广播模式"><a href="#2）广播模式" class="headerlink" title="2）广播模式"></a>2）广播模式</h4><p>消费者采用广播的方式消费消息，每个消费者消费的消息都是相同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</span><br><span class="line">    <span class="comment">// 指定Namesrv地址信息.</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 订阅Topic</span></span><br><span class="line">    consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</span><br><span class="line">    <span class="comment">//广播模式消费</span></span><br><span class="line">    consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">    <span class="comment">// 注册回调函数，处理消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, </span><br><span class="line">                              Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消息者</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>
<p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p>
<p>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。</p>
<h3 id="顺序消息生产"><a href="#顺序消息生产" class="headerlink" title="顺序消息生产"></a>顺序消息生产</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Producer，发送顺序消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line"></span><br><span class="line">       producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">       producer.start();</span><br><span class="line"></span><br><span class="line">       String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 订单列表</span></span><br><span class="line">       List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> Producer().buildOrders();</span><br><span class="line"></span><br><span class="line">       Date date = <span class="keyword">new</span> Date();</span><br><span class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       String dateStr = sdf.format(date);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 加个时间前缀</span></span><br><span class="line">           String body = dateStr + <span class="string">" Hello RocketMQ "</span> + orderList.get(i);</span><br><span class="line">           Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i, body.getBytes());</span><br><span class="line"></span><br><span class="line">           SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                   Long id = (Long) arg;  <span class="comment">//根据订单id选择发送queue</span></span><br><span class="line">                   <span class="keyword">long</span> index = id % mqs.size();</span><br><span class="line">                   <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">           System.out.println(String.format(<span class="string">"SendResult status:%s, queueId:%d, body:%s"</span>,</span><br><span class="line">               sendResult.getSendStatus(),</span><br><span class="line">               sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">               body));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       producer.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 订单的步骤</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStep</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> orderId;</span><br><span class="line">       <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> orderId;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">long</span> orderId)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> desc;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.desc = desc;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"OrderStep&#123;"</span> +</span><br><span class="line">               <span class="string">"orderId="</span> + orderId +</span><br><span class="line">               <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成模拟订单数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;OrderStep&gt; <span class="title">buildOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> ArrayList&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line">       OrderStep orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"推送"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> orderList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序消费消息"><a href="#顺序消费消息" class="headerlink" title="顺序消费消息"></a>顺序消费消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerInOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DefaultMQPushConsumer consumer = <span class="keyword">new</span> </span><br><span class="line">           DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_3"</span>);</span><br><span class="line">       consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class="line"><span class="comment">        * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">       consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line"></span><br><span class="line">       consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">           Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">               context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                   <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                   System.out.println(<span class="string">"consumeThread="</span> + Thread.currentThread().getName() + <span class="string">"queueId="</span> + msg.getQueueId() + <span class="string">", content:"</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       consumer.start();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"Consumer Started."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>比如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p>
<h3 id="启动消息消费者"><a href="#启动消息消费者" class="headerlink" title="启动消息消费者"></a>启动消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageConsumer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化消费者</span></span><br><span class="line">      DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"ExampleConsumer"</span>);</span><br><span class="line">      <span class="comment">// 订阅Topics</span></span><br><span class="line">      consumer.subscribe(<span class="string">"TestTopic"</span>, <span class="string">"*"</span>);</span><br><span class="line">      <span class="comment">// 注册消息监听者</span></span><br><span class="line">      consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line">                  <span class="comment">// Print approximate delay time period</span></span><br><span class="line">                  System.out.println(<span class="string">"Receive message[msgId="</span> + message.getMsgId() + <span class="string">"] "</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">"ms later"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 启动消费者</span></span><br><span class="line">      consumer.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送延时消息"><a href="#发送延时消息" class="headerlink" title="发送延时消息"></a>发送延时消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line">      DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">      <span class="comment">// 启动生产者</span></span><br><span class="line">      producer.start();</span><br><span class="line">      <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">          Message message = <span class="keyword">new</span> Message(<span class="string">"TestTopic"</span>, (<span class="string">"Hello scheduled message "</span> + i).getBytes());</span><br><span class="line">          <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">          message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">          <span class="comment">// 发送消息</span></span><br><span class="line">          producer.send(message);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 关闭生产者</span></span><br><span class="line">      producer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>您将会看到消息的消费比存储时间晚10秒</p>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span>;</span><br></pre></td></tr></table></figure>
<p>现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18</p>
<h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。</p>
<h3 id="发送批量消息"><a href="#发送批量消息" class="headerlink" title="发送批量消息"></a>发送批量消息</h3><p>如果您每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String topic = <span class="string">"BatchTest"</span>;</span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID001"</span>, <span class="string">"Hello world 0"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID002"</span>, <span class="string">"Hello world 1"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID003"</span>, <span class="string">"Hello world 2"</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   producer.send(messages);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   <span class="comment">//处理error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果消息的总长度可能大于4MB时，这时候最好把消息进行分割</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_LIMIT = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> currIndex;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.messages = messages;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">   &#125;</span><br><span class="line">   	<span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Message&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> nextIndex = currIndex;</span><br><span class="line">       <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">           Message message = messages.get(nextIndex);</span><br><span class="line">           <span class="keyword">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class="line">           Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">               tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">           &#125;</span><br><span class="line">           tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">// 增加日志的开销20字节</span></span><br><span class="line">           <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="comment">//单个消息超过了最大的限制</span></span><br><span class="line">               <span class="comment">//忽略,否则会阻塞分裂的进程</span></span><br><span class="line">               <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//假如下一个子列表没有元素,则添加这个子列表然后退出循环,否则只是退出循环</span></span><br><span class="line">                  nextIndex++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               totalSize += tmpSize;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">       currIndex = nextIndex;</span><br><span class="line">       <span class="keyword">return</span> subList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把大的消息分裂成若干个小的消息</span></span><br><span class="line">ListSplitter splitter = <span class="keyword">new</span> ListSplitter(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;Message&gt;  listItem = splitter.next();</span><br><span class="line">      producer.send(listItem);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="comment">//处理error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><p>在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"CID_EXAMPLE"</span>);</span><br><span class="line">consumer.subscribe(<span class="string">"TOPIC"</span>, <span class="string">"TAGA || TAGB || TAGC"</span>);</span><br></pre></td></tr></table></figure>
<p>消费者将接收包含TAGA或TAGB或TAGC的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用SQL表达式筛选消息。SQL特性可以通过发送消息时的属性来进行计算。在RocketMQ定义的语法下，可以实现一些简单的逻辑。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|  a &gt; 5 AND b = &apos;abc&apos;</span><br><span class="line">| a = 10   |  --------------------&gt; Gotten</span><br><span class="line">| b = &apos;abc&apos;|</span><br><span class="line">| c = true |</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|   a &gt; 5 AND b = &apos;abc&apos;</span><br><span class="line">| a = 1    |  --------------------&gt; Missed</span><br><span class="line">| b = &apos;abc&apos;|</span><br><span class="line">| c = true |</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>
<h3 id="SQL基本语法"><a href="#SQL基本语法" class="headerlink" title="SQL基本语法"></a>SQL基本语法</h3><p>RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p>
<ul>
<li>数值比较，比如：<strong>&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；</strong></li>
<li>字符比较，比如：<strong>=，&lt;&gt;，IN；</strong></li>
<li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li>
<li>逻辑符号 <strong>AND，OR，NOT；</strong></li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如：<strong>123，3.1415；</strong></li>
<li>字符，比如：<strong>‘abc’，必须用单引号包裹起来；</strong></li>
<li><strong>NULL</strong>，特殊的常量</li>
<li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li>
</ul>
<p>只有使用push模式的消费者才能用使用SQL92标准的sql语句，接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>发送消息时，你能通过<code>putUserProperty</code>来设置消息的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">producer.start();</span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">   tag,</span><br><span class="line">   (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 设置一些属性</span></span><br><span class="line">msg.putUserProperty(<span class="string">"a"</span>, String.valueOf(i));</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>用MessageSelector.bySql来使用sql筛选消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"><span class="comment">// 只有订阅的消息有这个属性a, a &gt;=0 and a &lt;= 3</span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, MessageSelector.bySql(<span class="string">"a between 0 and 3"</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409021913704.png" alt></p>
<p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<h4 id="1）事务消息发送及提交"><a href="#1）事务消息发送及提交" class="headerlink" title="1）事务消息发送及提交"></a>1）事务消息发送及提交</h4><p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<h4 id="2）事务补偿"><a href="#2）事务补偿" class="headerlink" title="2）事务补偿"></a>2）事务补偿</h4><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="3）事务消息状态"><a href="#3）事务消息状态" class="headerlink" title="3）事务消息状态"></a>3）事务消息状态</h4><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
<h3 id="发送事务消息"><a href="#发送事务消息" class="headerlink" title="发送事务消息"></a>发送事务消息</h3><h4 id="1-创建事务性生产者"><a href="#1-创建事务性生产者" class="headerlink" title="1) 创建事务性生产者"></a>1) 创建事务性生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建事务监听器</span></span><br><span class="line">        TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">        <span class="comment">//创建消息生产者</span></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"group6"</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"192.168.25.135:9876;192.168.25.138:9876"</span>);</span><br><span class="line">        <span class="comment">//生产者这是监听器</span></span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        <span class="comment">//启动消息生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TransactionTopic"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）实现事务的监听接口"><a href="#2）实现事务的监听接口" class="headerlink" title="2）实现事务的监听接口"></a>2）实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTranscation</code> 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行本地事务"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagA"</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagB"</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MQ检查消息Tag【"</span>+msg.getTags()+<span class="string">"】的本地事务执行结果"</span>);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用限制-1"><a href="#使用限制-1" class="headerlink" title="使用限制"></a>使用限制</h3><ol>
<li>事务消息不支持延时消息和批量消息。</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</li>
<li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</li>
<li>事务性消息可能不止一次被检查或消费。</li>
<li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li>
</ol>
<h1 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h1><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p>分布式队列因为有高可靠性的要求，所以数据要进行持久化存储。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029436.png" alt></p>
<ol>
<li>消息生成者发送消息</li>
<li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>返回ACK给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li>
<li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li>
<li>MQ删除消息</li>
</ol>
<h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><ul>
<li>关系型数据库DB</li>
</ul>
<p>Apache下开源的另外一款MQ—ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029434.png" alt></p>
<ul>
<li><p>文件系统</p>
<p>目前业界较为常用的几款产品（RocketMQ/Kafka/RabbitMQ）均采用的是消息刷盘至所部署虚拟机/物理机的文件系统来做持久化（刷盘一般可以分为异步刷盘和同步刷盘两种模式）。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p>
<p><img src="/Users/zhangxuefeng/Desktop/黑马rocketmq/RocketMQ-1/文档/img/磁盘.png" alt></p>
</li>
</ul>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>文件系统&gt;关系型数据库DB</p>
<h3 id="消息的存储和发送"><a href="#消息的存储和发送" class="headerlink" title="消息的存储和发送"></a>消息的存储和发送</h3><h4 id="1）消息存储"><a href="#1）消息存储" class="headerlink" title="1）消息存储"></a>1）消息存储</h4><p>磁盘如果使用得当，磁盘的速度完全可以匹配上网络 的数据传输速度。目前的高性能磁盘，顺序写速度可以达到600MB/s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB/s，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。RocketMQ的消息用顺序写,保证了消息存储的速度。</p>
<h4 id="2）消息发送"><a href="#2）消息发送" class="headerlink" title="2）消息发送"></a>2）消息发送</h4><p>Linux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。</p>
<p>一台服务器 把本机磁盘文件的内容发送到客户端，一般分为两个步骤：</p>
<p>1）read；读取本地文件内容； </p>
<p>2）write；将读取的内容通过网络发送出去。</p>
<p>这两个看似简单的操作，实际进行了4 次数据复制，分别是：</p>
<ol>
<li>从磁盘复制数据到内核态内存；</li>
<li>从内核态内存复 制到用户态内存；</li>
<li>然后从用户态 内存复制到网络驱动的内核态内存；</li>
<li>最后是从网络驱动的内核态内存复制到网卡中进行传输。</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029435.png" alt>通过使用mmap的方式，可以省去向用户态的内存复制，提高速度。这种机制在Java中是通过MappedByteBuffer实现的</p>
<p>RocketMQ充分利用了上述特性，也就是所谓的“零拷贝”技术，提高消息存盘和网络发送的速度。</p>
<blockquote>
<p>这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了</p>
</blockquote>
<h3 id="消息存储结构"><a href="#消息存储结构" class="headerlink" title="消息存储结构"></a>消息存储结构</h3><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成 的，消息真正的物理存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。每 个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029437.png" alt></p>
<ul>
<li>CommitLog：存储消息的元数据</li>
<li>ConsumerQueue：存储消息在CommitLog的索引</li>
<li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li>
</ul>
<h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量不超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，分布式同步刷盘和异步刷盘。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029438.png" alt></p>
<h4 id="1）同步刷盘"><a href="#1）同步刷盘" class="headerlink" title="1）同步刷盘"></a>1）同步刷盘</h4><p>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p>
<h4 id="2）异步刷盘"><a href="#2）异步刷盘" class="headerlink" title="2）异步刷盘"></a>2）异步刷盘</h4><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p>
<h4 id="3）配置"><a href="#3）配置" class="headerlink" title="3）配置"></a>3）配置</h4><p><strong>同步刷盘还是异步刷盘，都是通过Broker配置文件里的flushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</strong></p>
<h2 id="高可用性机制"><a href="#高可用性机制" class="headerlink" title="高可用性机制"></a>高可用性机制</h2><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029468.jpg" alt></p>
<p>RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的。</p>
<p>Master和Slave的区别：在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</p>
<p>Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</p>
<h3 id="消息消费高可用"><a href="#消息消费高可用" class="headerlink" title="消息消费高可用"></a>消息消费高可用</h3><p>在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave 读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。</p>
<h3 id="消息发送高可用"><a href="#消息发送高可用" class="headerlink" title="消息发送高可用"></a>消息发送高可用</h3><p>在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可 用后，其他组的Master仍然可用，Producer仍然可以发送消息。 RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足， 需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文 件，用新的配置文件启动Broker。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029529.jpg" alt></p>
<h3 id="消息主从复制"><a href="#消息主从复制" class="headerlink" title="消息主从复制"></a>消息主从复制</h3><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p>
<h4 id="1）同步复制"><a href="#1）同步复制" class="headerlink" title="1）同步复制"></a>1）同步复制</h4><p>同步复制方式是等Master和Slave均写 成功后才反馈给客户端写成功状态；</p>
<p>在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入 延迟，降低系统吞吐量。</p>
<h4 id="2）异步复制"><a href="#2）异步复制" class="headerlink" title="2）异步复制"></a>2）异步复制</h4><p>异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。</p>
<p>在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失；</p>
<h4 id="3）配置-1"><a href="#3）配置-1" class="headerlink" title="3）配置"></a>3）配置</h4><p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p>
<h4 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h4><p><img src="/Users/zhangxuefeng/Desktop/黑马rocketmq/RocketMQ-1/文档/img/复制刷盘.png" alt></p>
<p>实际应用中要结合业务场景，合理设置刷盘方式和主从复制方式， 尤其是SYNC_FLUSH方式，由于频繁地触发磁盘写动作，会明显降低 性能。通常情况下，应该把Master和Save配置成ASYNC_FLUSH的刷盘 方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台 机器出故障，仍然能保证数据不丢，是个不错的选择。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="Producer负载均衡"><a href="#Producer负载均衡" class="headerlink" title="Producer负载均衡"></a>Producer负载均衡</h3><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029757.png" alt></p>
<p>图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推。</p>
<h3 id="Consumer负载均衡"><a href="#Consumer负载均衡" class="headerlink" title="Consumer负载均衡"></a>Consumer负载均衡</h3><h4 id="1）集群模式"><a href="#1）集群模式" class="headerlink" title="1）集群模式"></a>1）集群模式</h4><p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p>
<p>而每当实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。</p>
<p>默认的分配算法是AllocateMessageQueueAveragely，如下图：</p>
<p><img src="/Users/zhangxuefeng/Desktop/黑马rocketmq/RocketMQ-1/文档/img/consumer负载均衡.png" alt></p>
<p>还有另外一种平均的算法是AllocateMessageQueueAveragelyByCircle，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029850.png" alt></p>
<p>需要注意的是，集群模式下，queue都是只允许分配只一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue。</p>
<p>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</p>
<p>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p>
<h4 id="2）广播模式-1"><a href="#2）广播模式-1" class="headerlink" title="2）广播模式"></a>2）广播模式</h4><p>由于广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p>
<p>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029561.png" alt></p>
<h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><h3 id="顺序消息的重试"><a href="#顺序消息的重试" class="headerlink" title="顺序消息的重试"></a>顺序消息的重试</h3><p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p>
<h3 id="无序消息的重试"><a href="#无序消息的重试" class="headerlink" title="无序消息的重试"></a>无序消息的重试</h3><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p>
<p>无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p>
<h4 id="1）重试次数"><a href="#1）重试次数" class="headerlink" title="1）重试次数"></a>1）重试次数</h4><p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">第几次重试</th>
<th style="text-align:center">与上次重试的间隔时间</th>
<th style="text-align:center">第几次重试</th>
<th style="text-align:center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10 秒</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7 分钟</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">30 秒</td>
<td style="text-align:center">10</td>
<td style="text-align:center">8 分钟</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1 分钟</td>
<td style="text-align:center">11</td>
<td style="text-align:center">9 分钟</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2 分钟</td>
<td style="text-align:center">12</td>
<td style="text-align:center">10 分钟</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">3 分钟</td>
<td style="text-align:center">13</td>
<td style="text-align:center">20 分钟</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">4 分钟</td>
<td style="text-align:center">14</td>
<td style="text-align:center">30 分钟</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">5 分钟</td>
<td style="text-align:center">15</td>
<td style="text-align:center">1 小时</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">6 分钟</td>
<td style="text-align:center">16</td>
<td style="text-align:center">2 小时</td>
</tr>
</tbody>
</table>
</div>
<p>如果消息重试 16 次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。</p>
<p><strong>注意：</strong> 一条消息无论重试多少次，这些重试消息的 Message ID 不会改变。</p>
<h4 id="2）配置方式"><a href="#2）配置方式" class="headerlink" title="2）配置方式"></a>2）配置方式</h4><p><strong>消费失败后，重试配置方式</strong></p>
<p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p>
<ul>
<li>返回 Action.ReconsumeLater （推荐）</li>
<li>返回 Null</li>
<li>抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理消息</span></span><br><span class="line">        doConsumeMessage(message);</span><br><span class="line">        <span class="comment">//方式1：返回 Action.ReconsumeLater，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> Action.ReconsumeLater;</span><br><span class="line">        <span class="comment">//方式2：返回 null，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//方式3：直接抛出异常， 消息将重试</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Consumer Message exceotion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费失败后，不重试配置方式</strong></p>
<p>集群消费方式下，消息失败后期望消息不重试，需要捕获消费逻辑中可能抛出的异常，最终返回 Action.CommitMessage，此后这条消息将不会再重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConsumeMessage(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></span><br><span class="line">            <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理正常，直接返回 Action.CommitMessage;</span></span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义消息最大重试次数</strong></p>
<p>消息队列 RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p>
<ul>
<li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述。</li>
<li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//配置对应 Group ID 的最大消息重试次数为 20 次</span></span><br><span class="line">properties.put(PropertyKeyConst.MaxReconsumeTimes,<span class="string">"20"</span>);</span><br><span class="line">Consumer consumer =ONSFactory.createConsumer(properties);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。</li>
<li>如果只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效。</li>
<li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li>
</ul>
<p><strong>获取消息重试次数</strong></p>
<p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取消息的重试次数</span></span><br><span class="line">        System.out.println(message.getReconsumeTimes());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</p>
<h3 id="死信特性"><a href="#死信特性" class="headerlink" title="死信特性"></a>死信特性</h3><p>死信消息具有以下特性</p>
<ul>
<li>不会再被消费者正常消费。</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li>
</ul>
<p>死信队列具有以下特性：</p>
<ul>
<li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li>
</ul>
<h3 id="查看死信信息"><a href="#查看死信信息" class="headerlink" title="查看死信信息"></a>查看死信信息</h3><ol>
<li>在控制台查询出现死信队列的主题信息</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029792.png" alt></p>
<ol>
<li>在消息界面根据主题查询死信消息</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029834.png" alt></p>
<ol>
<li>选择重新发送消息</li>
</ol>
<p>一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要您对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次。</p>
<h2 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h2><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</p>
<h3 id="消费幂等的必要性"><a href="#消费幂等的必要性" class="headerlink" title="消费幂等的必要性"></a>消费幂等的必要性</h3><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p>
<ul>
<li><p>发送时消息重复</p>
<p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p>投递时消息重复</p>
<p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p>负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p>
<p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p>
</li>
</ul>
<h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">message.setKey(<span class="string">"ORDERID_100"</span>);</span><br><span class="line">SendResult sendResult = producer.send(message);</span><br></pre></td></tr></table></figure>
<p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">"ons_test"</span>, <span class="string">"*"</span>, <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        String key = message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>调试源码版本4.9.4,源码路径/Users/zhangxuefeng/Downloads/rocketmq-rocketmq-all-4.9.4</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>依赖工具</p>
<ul>
<li>JDK ：1.8+</li>
<li>Maven</li>
<li>IntelliJ IDEA</li>
</ul>
<h3 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h3><p>从官方仓库 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">https://github.com/apache/rocketmq</a> <code>clone</code>或者<code>download</code>源码。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029226.png" alt></p>
<p><strong>源码目录结构：</strong></p>
<ul>
<li><p>broker: broker 模块（broke 启动进程） </p>
</li>
<li><p>client ：消息客户端，包含消息生产者、消息消费者相关类 </p>
</li>
<li>common ：公共包 </li>
<li>dev ：开发者信息（非源代码） </li>
<li>distribution ：部署实例文件夹（非源代码） </li>
<li>example: RocketMQ 例代码 </li>
<li><p>filter ：消息过滤相关基础类</p>
</li>
<li><p>filtersrv：消息过滤服务器实现相关类（Filter启动进程）</p>
</li>
<li>logappender：日志实现相关类</li>
<li>namesrv：NameServer实现相关类（NameServer启动进程）</li>
<li>openmessageing：消息开放标准</li>
<li>remoting：远程通信模块，给予Netty</li>
<li>srcutil：服务工具类</li>
<li>store：消息存储实现相关类</li>
<li>style：checkstyle相关实现</li>
<li>test：测试相关类</li>
<li>tools：工具类，监控命令相关实现类</li>
</ul>
<h3 id="导入IDEA"><a href="#导入IDEA" class="headerlink" title="导入IDEA"></a>导入IDEA</h3><p><img src="/Users/zhangxuefeng/Desktop/黑马rocketmq/RocketMQ-1/文档/img/源码2.png" alt></p>
<p><strong>执行安装</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>创建<code>conf</code>配置文件夹,从<code>distribution</code>拷贝<code>broker.conf</code>和<code>logback_broker.xml</code>和<code>logback_namesrv.xml</code></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029305.png" alt></p>
<h4 id="1）启动NameServer"><a href="#1）启动NameServer" class="headerlink" title="1）启动NameServer"></a>1）启动NameServer</h4><ul>
<li>展开namesrv模块，右键NamesrvStartup.java</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029549.png" alt></p>
<ul>
<li>配置<strong>ROCKETMQ_HOME</strong></li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029659.png" alt></p>
<p><img src="/Users/zhangxuefeng/Desktop/黑马rocketmq/RocketMQ-1/文档/img/源码5.png" alt></p>
<ul>
<li><p>重新启动</p>
<p>控制台打印结果</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure>
<h4 id="2）启动Broker"><a href="#2）启动Broker" class="headerlink" title="2）启动Broker"></a>2）启动Broker</h4><ul>
<li><code>broker.conf</code>配置文件内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = 0</span><br><span class="line"># namesrvAddr地址</span><br><span class="line">namesrvAddr=127.0.0.1:9876</span><br><span class="line">deleteWhen = 04</span><br><span class="line">fileReservedTime = 48</span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"></span><br><span class="line"># 存储路径</span><br><span class="line">storePathRootDir=E:\\RocketMQ\\data\\rocketmq\\dataDir</span><br><span class="line"># commitLog路径</span><br><span class="line">storePathCommitLog=E:\\RocketMQ\\data\\rocketmq\\dataDir\\commitlog</span><br><span class="line"># 消息队列存储路径</span><br><span class="line">storePathConsumeQueue=E:\\RocketMQ\\data\\rocketmq\\dataDir\\consumequeue</span><br><span class="line"># 消息索引存储路径</span><br><span class="line">storePathIndex=E:\\RocketMQ\\data\\rocketmq\\dataDir\\index</span><br><span class="line"># checkpoint文件路径</span><br><span class="line">storeCheckpoint=E:\\RocketMQ\\data\\rocketmq\\dataDir\\checkpoint</span><br><span class="line"># abort文件存储路径</span><br><span class="line">abortFile=E:\\RocketMQ\\data\\rocketmq\\dataDir\\abort</span><br></pre></td></tr></table></figure>
<ul>
<li>创建数据文件夹<code>dataDir</code></li>
<li>启动<code>BrokerStartup</code>,配置<code>broker.conf</code>和<code>ROCKETMQ_HOME</code></li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029472.png" alt></p>
<p><img src="/Users/zhangxuefeng/Desktop/黑马rocketmq/RocketMQ-1/文档/img/源码8.png" alt></p>
<h4 id="3）发送消息"><a href="#3）发送消息" class="headerlink" title="3）发送消息"></a>3）发送消息</h4><ul>
<li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li>
<li>指定Namesrv地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>运行<code>main</code>方法，发送消息</li>
</ul>
<h4 id="4）消费消息"><a href="#4）消费消息" class="headerlink" title="4）消费消息"></a>4）消费消息</h4><ul>
<li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li>
<li>指定Namesrv地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>运行<code>main</code>方法，消费消息</li>
</ul>
<h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>消息中间件的设计思路一般是基于主题订阅发布的机制，消息生产者（Producer）发送某一个主题到消息服务器，消息服务器负责将消息持久化存储，消息消费者（Consumer）订阅该兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费者（Push模式）或者消费者主动向消息服务器拉去（Pull模式），从而实现消息生产者与消息消费者解耦。为了避免消息服务器的单点故障导致的整个系统瘫痪，通常会部署多台消息服务器共同承担消息的存储。那消息生产者如何知道消息要发送到哪台消息服务器呢？如果某一台消息服务器宕机了，那么消息生产者如何在不重启服务情况下感知呢？</p>
<p>NameServer就是为了解决以上问题设计的。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029468.jpg" alt></p>
<p>Broker消息服务器在启动的时向所有NameServer注册，消息生产者（Producer）在发送消息时之前先从NameServer获取Broker服务器地址列表，然后根据负载均衡算法从列表中选择一台服务器进行发送。NameServer与每台Broker保持长连接，并间隔30S检测Broker是否存活，如果检测到Broker宕机，则从路由注册表中删除。但是路由变化不会马上通知消息生产者。这样设计的目的是为了降低NameServer实现的复杂度，在消息发送端提供容错机制保证消息发送的可用性。</p>
<p>NameServer本身的高可用是通过部署多台NameServer来实现，但彼此之间不通讯，也就是NameServer服务器之间在某一个时刻的数据并不完全相同，但这对消息发送并不会造成任何影响，这也是NameServer设计的一个亮点，总之，RocketMQ设计追求简单高效。</p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029971.png" alt></p>
<p>启动类：<code>org.apache.rocketmq.namesrv.NamesrvStartup</code></p>
<h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p>解析配置文件，填充NameServerConfig、NettyServerConfig属性值，并创建NamesrvController</p>
<p><strong><em>代码：NamesrvController#createNamesrvController</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建NamesrvConfig</span></span><br><span class="line"><span class="keyword">final</span> NamesrvConfig namesrvConfig = <span class="keyword">new</span> NamesrvConfig();</span><br><span class="line"><span class="comment">//创建NettyServerConfig</span></span><br><span class="line"><span class="keyword">final</span> NettyServerConfig nettyServerConfig = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line"><span class="comment">//设置启动端口号</span></span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line"><span class="comment">//解析启动-c参数</span></span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">'c'</span>)) &#123;</span><br><span class="line">    String file = commandLine.getOptionValue(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(in);</span><br><span class="line">        MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">        MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">        namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"load config properties file OK, %s%n"</span>, file);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析启动-p参数</span></span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">'p'</span>)) &#123;</span><br><span class="line">    InternalLogger console = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</span><br><span class="line">    MixAll.printObjectProperties(console, namesrvConfig);</span><br><span class="line">    MixAll.printObjectProperties(console, nettyServerConfig);</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将启动参数填充到namesrvConfig,nettyServerConfig</span></span><br><span class="line">MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建NameServerController</span></span><br><span class="line"><span class="keyword">final</span> NamesrvController controller = <span class="keyword">new</span> NamesrvController(namesrvConfig, nettyServerConfig);</span><br></pre></td></tr></table></figure>
<p><u><strong>NamesrvConfig属性</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));</span><br><span class="line"><span class="keyword">private</span> String kvConfigPath = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"namesrv"</span> + File.separator + <span class="string">"kvConfig.json"</span>;</span><br><span class="line"><span class="keyword">private</span> String configStorePath = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"namesrv"</span> + File.separator + <span class="string">"namesrv.properties"</span>;</span><br><span class="line"><span class="keyword">private</span> String productEnvName = <span class="string">"center"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clusterTest = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> orderMessageEnable = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p><strong>rocketmqHome：</strong>rocketmq主目录</p>
<p><strong>kvConfig：</strong>NameServer存储KV配置属性的持久化路径</p>
<p><strong>configStorePath：</strong>nameServer默认配置文件路径</p>
<p><strong>orderMessageEnable：</strong>是否支持顺序消息</p>
<p><u><strong>NettyServerConfig属性</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> listenPort = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWorkerThreads = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverCallbackExecutorThreads = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSelectorThreads = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverOnewaySemaphoreValue = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverAsyncSemaphoreValue = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverChannelMaxIdleTimeSeconds = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketSndBufSize = NettySystemConfig.socketSndbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> serverPooledByteBufAllocatorEnable = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useEpollNativeSelector = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p><strong>listenPort：</strong>NameServer监听端口，该值默认会被初始化为9876<br><strong>serverWorkerThreads：</strong>Netty业务线程池线程个数<br><strong>serverCallbackExecutorThreads：</strong>Netty public任务线程池线程个数，Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等。如果该业务类型未注册线程池，则由public线程池执行。<br><strong>serverSelectorThreads：</strong>IO线程池个数，主要是NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网路请求的，解析请求包，然后转发到各个业务线程池完成具体的操作，然后将结果返回给调用方;<br><strong>serverOnewaySemaphoreValue：</strong>send oneway消息请求并发读（Broker端参数）;<br><strong>serverAsyncSemaphoreValue：</strong>异步消息发送最大并发度;<br><strong>serverChannelMaxIdleTimeSeconds ：</strong>网络连接最大的空闲时间，默认120s。<br><strong>serverSocketSndBufSize：</strong>网络socket发送缓冲区大小。<br><strong>serverSocketRcvBufSize：</strong> 网络接收端缓存区大小。<br><strong>serverPooledByteBufAllocatorEnable：</strong>ByteBuffer是否开启缓存;<br><strong>useEpollNativeSelector：</strong>是否启用Epoll IO模型。</p>
<h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>根据启动属性创建NamesrvController实例，并初始化该实例。NameServerController实例为NameServer核心控制器</p>
<p><strong><em>代码：NamesrvController#initialize</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//加载KV配置</span></span><br><span class="line">    <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line">	<span class="comment">//创建NettyServer网络处理对象</span></span><br><span class="line">    <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line">	<span class="comment">//开启定时任务:每隔10s扫描一次Broker,移除不活跃的Broker</span></span><br><span class="line">    <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"RemotingExecutorThread_"</span>));</span><br><span class="line">    <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">	<span class="comment">//开启定时任务:每隔10min打印一次KV配置</span></span><br><span class="line">	<span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>在JVM进程关闭之前，先将线程池关闭，及时释放资源</p>
<p><strong><em>代码：NamesrvStartup#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册JVM钩子函数代码</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShutdownHookThread(log, <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        controller.shutdown();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><p>NameServer的主要作用是为消息的生产者和消息消费者提供关于主题Topic的路由信息，那么NameServer需要存储路由的基础信息，还要管理Broker节点，包括路由注册、路由删除等。</p>
<h4 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h4><p><strong><em>代码：RouteInfoManager</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029980.png" alt></p>
<p><strong>topicQueueTable：</strong>Topic消息队列路由信息，消息发送时根据路由表进行负载均衡</p>
<p><strong>brokerAddrTable：</strong>Broker基础信息，包括brokerName、所属集群名称、主备Broker地址</p>
<p><strong>clusterAddrTable：</strong>Broker集群信息，存储集群中所有Broker名称</p>
<p><strong>brokerLiveTable：</strong>Broker状态信息，NameServer每次收到心跳包是会替换该信息</p>
<p><strong>filterServerTable：</strong>Broker上的FilterServer列表，用于类模式消息过滤。</p>
<blockquote>
<p>RocketMQ基于定于发布机制，一个Topic拥有多个消息队列，一个Broker为每一个主题创建4个读队列和4个写队列。多个Broker组成一个集群，集群由相同的多台Broker组成Master-Slave架构，brokerId为0代表Master，大于0为Slave。BrokerLiveInfo中的lastUpdateTimestamp存储上次收到Broker心跳包的时间。</p>
</blockquote>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029773.png" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029783.png" alt></p>
<h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><h5 id="1）发送心跳包"><a href="#1）发送心跳包" class="headerlink" title="1）发送心跳包"></a>1）发送心跳包</h5><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029935.png" alt></p>
<p>RocketMQ路由注册是通过Broker与NameServer的心跳功能实现的。Broker启动时向集群中所有的NameServer发送心跳信息，每隔30s向集群中所有NameServer发送心跳包，NameServer收到心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdataTimeStamp信息，然后NameServer每隔10s扫描brokerLiveTable，如果连续120S没有收到心跳包，NameServer将移除Broker的路由信息同时关闭Socket连接。</p>
<p><strong><em>代码：BrokerController#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册Broker信息</span></span><br><span class="line"><span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//每隔30s上报Broker信息到NameServer</span></span><br><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), </span><br><span class="line">                                                  TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：BrokerOuterAPI#registerBrokerAll</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得nameServer地址信息</span></span><br><span class="line">List&lt;String&gt; nameServerAddressList = <span class="keyword">this</span>.remotingClient.getNameServerAddressList();</span><br><span class="line"><span class="comment">//遍历所有nameserver列表</span></span><br><span class="line"><span class="keyword">if</span> (nameServerAddressList != <span class="keyword">null</span> &amp;&amp; nameServerAddressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装请求头</span></span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader = <span class="keyword">new</span> RegisterBrokerRequestHeader();</span><br><span class="line">    requestHeader.setBrokerAddr(brokerAddr);</span><br><span class="line">    requestHeader.setBrokerId(brokerId);</span><br><span class="line">    requestHeader.setBrokerName(brokerName);</span><br><span class="line">    requestHeader.setClusterName(clusterName);</span><br><span class="line">    requestHeader.setHaServerAddr(haServerAddr);</span><br><span class="line">    requestHeader.setCompressed(compressed);</span><br><span class="line">	<span class="comment">//封装请求体</span></span><br><span class="line">    RegisterBrokerBody requestBody = <span class="keyword">new</span> RegisterBrokerBody();</span><br><span class="line">    requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);</span><br><span class="line">    requestBody.setFilterServerList(filterServerList);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = requestBody.encode(compressed);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bodyCrc32 = UtilAll.crc32(body);</span><br><span class="line">    requestHeader.setBodyCrc32(bodyCrc32);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(nameServerAddressList.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String namesrvAddr : nameServerAddressList) &#123;</span><br><span class="line">        brokerOuterExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//分别向NameServer注册</span></span><br><span class="line">                    RegisterBrokerResult result = registerBroker(namesrvAddr,oneway, timeoutMills,requestHeader,body);</span><br><span class="line">                    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        registerBrokerResultList.add(result);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">"register broker[&#123;&#125;]to name server &#123;&#125; OK"</span>, brokerId, namesrvAddr);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.warn(<span class="string">"registerBroker Exception, &#123;&#125;"</span>, namesrvAddr, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：BrokerOutAPI#registerBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oneway) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingTooMuchRequestException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);</span><br></pre></td></tr></table></figure>
<h5 id="2）处理心跳包"><a href="#2）处理心跳包" class="headerlink" title="2）处理心跳包"></a>2）处理心跳包</h5><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029019.png" alt></p>
<p><code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor</code>网路处理类解析请求类型，如果请求类型是为<strong><em>REGISTER_BROKER</em></strong>，则将请求转发到<code>RouteInfoManager#regiesterBroker</code></p>
<p><strong><em>代码：DefaultRequestProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是注册Broker信息</span></span><br><span class="line"><span class="keyword">case</span> RequestCode.REGISTER_BROKER:</span><br><span class="line">	Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class="line">	<span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//注册Broker信息</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.registerBroker(ctx, request);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultRequestProcessor#registerBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RegisterBrokerResult result = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().registerBroker(</span><br><span class="line">    requestHeader.getClusterName(),</span><br><span class="line">    requestHeader.getBrokerAddr(),</span><br><span class="line">    requestHeader.getBrokerName(),</span><br><span class="line">    requestHeader.getBrokerId(),</span><br><span class="line">    requestHeader.getHaServerAddr(),</span><br><span class="line">    topicConfigWrapper,</span><br><span class="line">    <span class="keyword">null</span>,</span><br><span class="line">    ctx.channel()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：RouteInfoManager#registerBroker</em></strong></p>
<p>维护路由信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"><span class="comment">//维护clusterAddrTable</span></span><br><span class="line">Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">    brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">&#125;</span><br><span class="line">brokerNames.add(brokerName);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerAddrTable</span></span><br><span class="line">BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line"><span class="comment">//第一次注册,则创建brokerData</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">    registerFirst = <span class="keyword">true</span>;</span><br><span class="line">    brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line">    <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非第一次注册,更新Broker</span></span><br><span class="line">Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护topicQueueTable</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || </span><br><span class="line">        registerFirst) &#123;</span><br><span class="line">        ConcurrentMap&lt;String, TopicConfig&gt; tcTable = topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">        <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：RouteInfoManager#createAndUpdateQueueData</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndUpdateQueueData</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> TopicConfig topicConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建QueueData</span></span><br><span class="line">	QueueData queueData = <span class="keyword">new</span> QueueData();</span><br><span class="line">	queueData.setBrokerName(brokerName);</span><br><span class="line">	queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());</span><br><span class="line">	queueData.setReadQueueNums(topicConfig.getReadQueueNums());</span><br><span class="line">	queueData.setPerm(topicConfig.getPerm());</span><br><span class="line">	queueData.setTopicSynFlag(topicConfig.getTopicSysFlag());</span><br><span class="line">	<span class="comment">//获得topicQueueTable中队列集合</span></span><br><span class="line">	List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topicConfig.getTopicName());</span><br><span class="line">    <span class="comment">//topicQueueTable为空,则直接添加queueData到队列集合</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == queueDataList) &#123;</span><br><span class="line">	    queueDataList = <span class="keyword">new</span> LinkedList&lt;QueueData&gt;();</span><br><span class="line">	    queueDataList.add(queueData);</span><br><span class="line">	    <span class="keyword">this</span>.topicQueueTable.put(topicConfig.getTopicName(), queueDataList);</span><br><span class="line">	    log.info(<span class="string">"new topic registered, &#123;&#125; &#123;&#125;"</span>, topicConfig.getTopicName(), queueData);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是新的队列</span></span><br><span class="line">	    <span class="keyword">boolean</span> addNewOne = <span class="keyword">true</span>;</span><br><span class="line">	    Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">	    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	        QueueData qd = it.next();</span><br><span class="line">            <span class="comment">//如果brokerName相同,代表不是新的队列</span></span><br><span class="line">	        <span class="keyword">if</span> (qd.getBrokerName().equals(brokerName)) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (qd.equals(queueData)) &#123;</span><br><span class="line">	                addNewOne = <span class="keyword">false</span>;</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	                    log.info(<span class="string">"topic changed, &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;"</span>, topicConfig.getTopicName(), qd,</span><br><span class="line">	                        queueData);</span><br><span class="line">	                    it.remove();</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">		<span class="comment">//如果是新的队列,则添加队列到queueDataList</span></span><br><span class="line">        <span class="keyword">if</span> (addNewOne) &#123;</span><br><span class="line">            queueDataList.add(queueData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerLiveTable</span></span><br><span class="line">BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,<span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">    System.currentTimeMillis(),</span><br><span class="line">    topicConfigWrapper.getDataVersion(),</span><br><span class="line">    channel,</span><br><span class="line">    haServerAddr));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护filterServerList</span></span><br><span class="line"><span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">    String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">    <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">        <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">            result.setMasterAddr(masterAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="路由删除"><a href="#路由删除" class="headerlink" title="路由删除"></a>路由删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**RocketMQ有两个触发点来删除路由信息**：</span><br><span class="line"></span><br><span class="line">* NameServer定期扫描brokerLiveTable检测上次心跳包与当前系统的时间差，如果时间超过120s，则需要移除broker。</span><br><span class="line">* Broker在正常关闭的情况下，会执行unregisterBroker指令</span><br><span class="line"></span><br><span class="line">这两种方式路由删除的方法都是一样的，就是从相关路由表中删除与该broker相关的信息。</span><br><span class="line"></span><br><span class="line">![](https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029449.png)</span><br><span class="line"></span><br><span class="line">***代码：NamesrvController#initialize***</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//每隔10s扫描一次为活跃Broker</span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        NamesrvController.this.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 5, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：RouteInfoManager#scanNotActiveBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNotActiveBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得brokerLiveTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历brokerLiveTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">        <span class="keyword">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class="line">        <span class="comment">//如果收到心跳包的时间距当时时间是否超过120s</span></span><br><span class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">            <span class="comment">//移除broker</span></span><br><span class="line">            it.remove();</span><br><span class="line">            <span class="comment">//维护路由表</span></span><br><span class="line">            <span class="keyword">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：RouteInfoManager#onChannelDestroy</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请写锁,根据brokerAddress从brokerLiveTable和filterServerTable移除</span></span><br><span class="line"><span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"><span class="keyword">this</span>.brokerLiveTable.remove(brokerAddrFound);</span><br><span class="line"><span class="keyword">this</span>.filterServerTable.remove(brokerAddrFound);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerAddrTable</span></span><br><span class="line">String brokerNameFound = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> removeBrokerName = <span class="keyword">false</span>;</span><br><span class="line">Iterator&lt;Entry&lt;String, BrokerData&gt;&gt; itBrokerAddrTable =<span class="keyword">this</span>.brokerAddrTable.entrySet().iterator();</span><br><span class="line"><span class="comment">//遍历brokerAddrTable</span></span><br><span class="line"><span class="keyword">while</span> (itBrokerAddrTable.hasNext() &amp;&amp; (<span class="keyword">null</span> == brokerNameFound)) &#123;</span><br><span class="line">    BrokerData brokerData = itBrokerAddrTable.next().getValue();</span><br><span class="line">    <span class="comment">//遍历broker地址</span></span><br><span class="line">    Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerData.getBrokerAddrs().entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Long, String&gt; entry = it.next();</span><br><span class="line">        Long brokerId = entry.getKey();</span><br><span class="line">        String brokerAddr = entry.getValue();</span><br><span class="line">        <span class="comment">//根据broker地址移除brokerAddr</span></span><br><span class="line">        <span class="keyword">if</span> (brokerAddr.equals(brokerAddrFound)) &#123;</span><br><span class="line">            brokerNameFound = brokerData.getBrokerName();</span><br><span class="line">            it.remove();</span><br><span class="line">            log.info(<span class="string">"remove brokerAddr[&#123;&#125;, &#123;&#125;] from brokerAddrTable, because channel destroyed"</span>,</span><br><span class="line">                brokerId, brokerAddr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果当前主题只包含待移除的broker,则移除该topic</span></span><br><span class="line">    <span class="keyword">if</span> (brokerData.getBrokerAddrs().isEmpty()) &#123;</span><br><span class="line">        removeBrokerName = <span class="keyword">true</span>;</span><br><span class="line">        itBrokerAddrTable.remove();</span><br><span class="line">        log.info(<span class="string">"remove brokerName[&#123;&#125;] from brokerAddrTable, because channel destroyed"</span>,</span><br><span class="line">            brokerData.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护clusterAddrTable</span></span><br><span class="line"><span class="keyword">if</span> (brokerNameFound != <span class="keyword">null</span> &amp;&amp; removeBrokerName) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = <span class="keyword">this</span>.clusterAddrTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历clusterAddrTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();</span><br><span class="line">        <span class="comment">//获得集群名称</span></span><br><span class="line">        String clusterName = entry.getKey();</span><br><span class="line">        <span class="comment">//获得集群中brokerName集合</span></span><br><span class="line">        Set&lt;String&gt; brokerNames = entry.getValue();</span><br><span class="line">        <span class="comment">//从brokerNames中移除brokerNameFound</span></span><br><span class="line">        <span class="keyword">boolean</span> removed = brokerNames.remove(brokerNameFound);</span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">            log.info(<span class="string">"remove brokerName[&#123;&#125;], clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed"</span>,</span><br><span class="line">                brokerNameFound, clusterName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerNames.isEmpty()) &#123;</span><br><span class="line">                log.info(<span class="string">"remove the clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed and no broker in this cluster"</span>,</span><br><span class="line">                    clusterName);</span><br><span class="line">                <span class="comment">//如果集群中不包含任何broker,则移除该集群</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护topicQueueTable队列</span></span><br><span class="line"><span class="keyword">if</span> (removeBrokerName) &#123;</span><br><span class="line">    <span class="comment">//遍历topicQueueTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, List&lt;QueueData&gt;&gt;&gt; itTopicQueueTable =</span><br><span class="line">        <span class="keyword">this</span>.topicQueueTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (itTopicQueueTable.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, List&lt;QueueData&gt;&gt; entry = itTopicQueueTable.next();</span><br><span class="line">        <span class="comment">//主题名称</span></span><br><span class="line">        String topic = entry.getKey();</span><br><span class="line">        <span class="comment">//队列集合</span></span><br><span class="line">        List&lt;QueueData&gt; queueDataList = entry.getValue();</span><br><span class="line">		<span class="comment">//遍历该主题队列</span></span><br><span class="line">        Iterator&lt;QueueData&gt; itQueueData = queueDataList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itQueueData.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//从队列中移除为活跃broker信息</span></span><br><span class="line">            QueueData queueData = itQueueData.next();</span><br><span class="line">            <span class="keyword">if</span> (queueData.getBrokerName().equals(brokerNameFound)) &#123;</span><br><span class="line">                itQueueData.remove();</span><br><span class="line">                log.info(<span class="string">"remove topic[&#123;&#125; &#123;&#125;], from topicQueueTable, because channel destroyed"</span>,</span><br><span class="line">                    topic, queueData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果该topic的队列为空,则移除该topic</span></span><br><span class="line">        <span class="keyword">if</span> (queueDataList.isEmpty()) &#123;</span><br><span class="line">            itTopicQueueTable.remove();</span><br><span class="line">            log.info(<span class="string">"remove topic[&#123;&#125;] all queue, from topicQueueTable, because channel destroyed"</span>,</span><br><span class="line">                topic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放写锁</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h4><p>RocketMQ路由发现是非实时的，当Topic路由出现变化后，NameServer不会主动推送给客户端，而是由客户端定时拉取主题最新的路由。</p>
<p><strong><em>代码：DefaultRequestProcessor#getRouteInfoByTopic</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> GetRouteInfoRequestHeader requestHeader =</span><br><span class="line">        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</span><br><span class="line">	<span class="comment">//调用RouteInfoManager的方法,从路由表topicQueueTable、brokerAddrTable、filterServerTable中分别填充TopicRouteData的List&lt;QueueData&gt;、List&lt;BrokerData&gt;、filterServer</span></span><br><span class="line">    TopicRouteData topicRouteData = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line">	<span class="comment">//如果找到主题对应你的路由信息并且该主题为顺序消息，则从NameServer KVConfig中获取关于顺序消息相关的配置填充路由信息</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">            String orderTopicConf =</span><br><span class="line">                <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                    requestHeader.getTopic());</span><br><span class="line">            topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">        response.setBody(content);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">    response.setRemark(<span class="string">"No topic route info in name server for the topic: "</span> + requestHeader.getTopic()</span><br><span class="line">        + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029498.png" alt></p>
<h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>消息生产者的代码都在client模块中，相对于RocketMQ来讲，消息生产者就是客户端，也是消息的提供者。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029868.png" alt></p>
<h3 id="方法和属性"><a href="#方法和属性" class="headerlink" title="方法和属性"></a>方法和属性</h3><h4 id="1）主要方法介绍"><a href="#1）主要方法介绍" class="headerlink" title="1）主要方法介绍"></a>1）主要方法介绍</h4><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029256.png" alt></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建主题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTopic</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String newTopic, <span class="keyword">final</span> <span class="keyword">int</span> queueNum)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据时间戳从队列中查找消息偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">searchOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找消息队列中最大的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">maxOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找消息队列中最小的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">minOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据偏移量查找消息</span></span><br><span class="line"><span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(<span class="keyword">final</span> String offsetMsgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException,</span></span><br><span class="line"><span class="function">        InterruptedException, MQClientException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据条件查找消息</span></span><br><span class="line"><span class="function">QueryResult <span class="title">queryMessage</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum, <span class="keyword">final</span> <span class="keyword">long</span> begin,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> end)</span> <span class="keyword">throws</span> MQClientException, InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据消息ID和主题查找消息</span></span><br><span class="line"><span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(String topic,String msgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029279.png" alt></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找该主题下所有消息</span></span><br><span class="line"><span class="function">List&lt;MessageQueue&gt; <span class="title">fetchPublishMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步发送消息</span></span><br><span class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException,</span></span><br><span class="line"><span class="function">        InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步超时发送消息</span></span><br><span class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">        RemotingException, MQBrokerException, InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">        RemotingException, InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步超时发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送单向消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(<span class="keyword">final</span> Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException,</span></span><br><span class="line"><span class="function">    InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择指定队列同步发送消息</span></span><br><span class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">    RemotingException, MQBrokerException, InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择指定队列异步发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> SendCallback sendCallback)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择指定队列单项发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">    RemotingException, InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量发送消息</span></span><br><span class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException,InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2）属性介绍"><a href="#2）属性介绍" class="headerlink" title="2）属性介绍"></a>2）属性介绍</h4><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029319.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">producerGroup：生产者所属组</span><br><span class="line">createTopicKey：默认Topic</span><br><span class="line">defaultTopicQueueNums：默认主题在每一个Broker队列数量</span><br><span class="line">sendMsgTimeout：发送消息默认超时时间，默认<span class="number">3</span>s</span><br><span class="line">compressMsgBodyOverHowmuch：消息体超过该值则启用压缩，默认<span class="number">4</span>k</span><br><span class="line">retryTimesWhenSendFailed：同步方式发送消息重试次数，默认为<span class="number">2</span>，总共执行<span class="number">3</span>次</span><br><span class="line">retryTimesWhenSendAsyncFailed：异步方法发送消息重试次数，默认为<span class="number">2</span></span><br><span class="line">retryAnotherBrokerWhenNotStoreOK：消息重试时选择另外一个Broker时，是否不等待存储结果就返回，默认为<span class="keyword">false</span></span><br><span class="line">maxMessageSize：允许发送的最大消息长度，默认为<span class="number">4</span>M</span><br></pre></td></tr></table></figure>
<h3 id="启动流程-1"><a href="#启动流程-1" class="headerlink" title="启动流程"></a>启动流程</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022354510.png" alt="image-20240902235409199"></p>
<p><strong><em>代码：DefaultMQProducerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查生产者组是否满足要求</span></span><br><span class="line"><span class="keyword">this</span>.checkConfig();</span><br><span class="line"><span class="comment">//更改当前instanceName为进程ID</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得MQ客户端实例</span></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>整个JVM中只存在一个MQClientManager实例，维护一个MQClientInstance缓存表</p>
<p>ConcurrentMap<string * clientid , mqclientinstance> factoryTable = new ConcurrentHashMap<string,mqclientinstance>();</string,mqclientinstance></string></p>
<p>同一个clientId只会创建一个MQClientInstance。</p>
<p>MQClientInstance封装了RocketMQ网络处理API，是消息生产者和消息消费者与NameServer、Broker打交道的网络通道</p>
</blockquote>
<p><strong><em>代码：MQClientManager#getAndCreateMQClientInstance</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MQClientInstance <span class="title">getAndCreateMQClientInstance</span><span class="params">(<span class="keyword">final</span> ClientConfig clientConfig, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                     RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建客户端ID</span></span><br><span class="line">    String clientId = clientConfig.buildMQClientId();</span><br><span class="line">    <span class="comment">//根据客户端ID或者客户端实例</span></span><br><span class="line">    MQClientInstance instance = <span class="keyword">this</span>.factoryTable.get(clientId);</span><br><span class="line">    <span class="comment">//实例如果为空就创建新的实例,并添加到实例表中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">        instance =</span><br><span class="line">            <span class="keyword">new</span> MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class="line">                <span class="keyword">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">        MQClientInstance prev = <span class="keyword">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = prev;</span><br><span class="line">            log.warn(<span class="string">"Returned Previous MQClientInstance for clientId:[&#123;&#125;]"</span>, clientId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Created new MQClientInstance for clientId:[&#123;&#125;]"</span>, clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册当前生产者到到MQClientInstance管理中,方便后续调用网路请求</span></span><br><span class="line"><span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">    <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">        + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">        <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动生产者</span></span><br><span class="line"><span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">    mQClientFactory.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息发送-2"><a href="#消息发送-2" class="headerlink" title="消息发送"></a>消息发送</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029926.png" alt></p>
<p><strong><em>代码：DefaultMQProducerImpl#send(Message msg)</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> send(msg, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#send(Message msg,long timeout)</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息,默认超时时间为3s</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg,<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="keyword">null</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#sendDefaultImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验消息</span></span><br><span class="line">Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br></pre></td></tr></table></figure>
<h4 id="1）验证消息"><a href="#1）验证消息" class="headerlink" title="1）验证消息"></a>1）验证消息</h4><p><strong><em>代码：Validators#checkMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(Message msg, DefaultMQProducer defaultMQProducer)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验主题</span></span><br><span class="line">    Validators.checkTopic(msg.getTopic());</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 校验消息体</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg.getBody()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message body is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == msg.getBody().length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message body length is zero"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL,</span><br><span class="line">            <span class="string">"the message body size over max value, MAX: "</span> + defaultMQProducer.getMaxMessageSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）查找路由"><a href="#2）查找路由" class="headerlink" title="2）查找路由"></a>2）查找路由</h4><p><strong><em>代码：DefaultMQProducerImpl#tryToFindTopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中获得主题的路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">//路由信息为空,则从NameServer获取路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果未找到当前主题的路由信息,则用默认主题继续查找</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029198.png" alt></p>
<p><strong><em>代码：TopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPublishInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orderTopic = <span class="keyword">false</span>;	<span class="comment">//是否是顺序消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> haveTopicRouterInfo = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();	<span class="comment">//该主题消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();<span class="comment">//每选择一次消息队列,该值+1</span></span><br><span class="line">    <span class="keyword">private</span> TopicRouteData topicRouteData;<span class="comment">//关联Topic路由元信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TopicRouteData topicRouteData;</span><br><span class="line"><span class="comment">//使用默认主题从NameServer获取路由信息</span></span><br><span class="line"><span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">        <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">            <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">            data.setReadQueueNums(queueNums);</span><br><span class="line">            data.setWriteQueueNums(queueNums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//使用指定主题从NameServer获取路由信息</span></span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断路由是否需要更改</span></span><br><span class="line">TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</span><br><span class="line"><span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line"><span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">    changed = <span class="keyword">this</span>.isNeedUpdateTopicRouteInfo(topic);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="string">"the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]"</span>, topic, old, topicRouteData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed) &#123;</span><br><span class="line">    <span class="comment">//将topicRouteData转换为发布队列</span></span><br><span class="line">    TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">    publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//遍历生产</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">        MQProducerInner impl = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//生产者不为空时,更新publishInfo信息</span></span><br><span class="line">            impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#topicRouteData2TopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//创建TopicPublishInfo对象</span></span><br><span class="line">        TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</span><br><span class="line">    	<span class="comment">//关联topicRoute</span></span><br><span class="line">        info.setTopicRouteData(route);</span><br><span class="line">    	<span class="comment">//顺序消息,更新TopicPublishInfo</span></span><br><span class="line">        <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] brokers = route.getOrderTopicConf().split(<span class="string">";"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">                String[] item = broker.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非顺序消息更新TopicPublishInfo</span></span><br><span class="line">            List&lt;QueueData&gt; qds = route.getQueueDatas();</span><br><span class="line">            Collections.sort(qds);</span><br><span class="line">            <span class="comment">//遍历topic队列信息</span></span><br><span class="line">            <span class="keyword">for</span> (QueueData qd : qds) &#123;</span><br><span class="line">                <span class="comment">//是否是写队列</span></span><br><span class="line">                <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</span><br><span class="line">                    BrokerData brokerData = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//遍历写队列Broker</span></span><br><span class="line">                    <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</span><br><span class="line">                        <span class="comment">//根据名称获得读队列对应的Broker</span></span><br><span class="line">                        <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</span><br><span class="line">                        brokerData = bd;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//封装TopicPublishInfo写队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.setOrderTopic(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//返回TopicPublishInfo对象</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3）选择队列"><a href="#3）选择队列" class="headerlink" title="3）选择队列"></a>3）选择队列</h4><ul>
<li>默认不启用Broker故障延迟机制</li>
</ul>
<p><strong><em>代码：TopicPublishInfo#selectOneMessageQueue(lastBrokerName)</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次选择队列</span></span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//sendWhichQueue</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">        <span class="comment">//遍历消息队列集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//sendWhichQueue自增后取模</span></span><br><span class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//规避上次Broker队列</span></span><br><span class="line">            MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果以上情况都不满足,返回sendWhichQueue取模后的队列</span></span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：TopicPublishInfo#selectOneMessageQueue()</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次选择队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sendWhichQueue自增</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">    <span class="comment">//对队列大小取模</span></span><br><span class="line">    <span class="keyword">int</span> pos = Math.abs(index) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//返回对应的队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>启用Broker故障延迟机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Broker故障延迟机制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对sendWhichQueue自增</span></span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="comment">//对消息队列轮询获取一个队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">//验证该队列是否可用</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="comment">//可用</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//从规避的Broker中选择一个可用的Broker</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="comment">//获得Broker的写队列集合</span></span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获得一个队列,指定broker和队列ID并返回</span></span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/Users/zhangxuefeng/Desktop/黑马rocketmq/RocketMQ-1/文档/img/Broker故障延迟机制核心类.png" alt></p>
<ul>
<li>延迟机制接口规范</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LatencyFaultTolerance</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//更新失败条目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> T name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span></span>;</span><br><span class="line">	<span class="comment">//判断Broker是否可用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">(<span class="keyword">final</span> T name)</span></span>;</span><br><span class="line">	<span class="comment">//移除Fault条目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> T name)</span></span>;</span><br><span class="line">	<span class="comment">//尝试从规避的Broker中选择一个可用的Broker</span></span><br><span class="line">    <span class="function">T <span class="title">pickOneAtLeast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>FaultItem：失败条目</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FaultItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">FaultItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//条目唯一键,这里为brokerName</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//本次消息发送延迟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> currentLatency;</span><br><span class="line">    <span class="comment">//故障规避开始时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTimestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消息失败策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQFaultStrategy</span> </span>&#123;</span><br><span class="line">   <span class="comment">//根据currentLatency本地消息发送延迟,从latencyMax尾部向前找到第一个比currentLatency小的索引,如果没有找到,返回0</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line">    <span class="comment">//根据这个索引从notAvailableDuration取出对应的时间,在该时长内,Broker设置为不可用</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u><strong><em>原理分析</em></strong></u></p>
<p><strong><em>代码：DefaultMQProducerImpl#sendDefaultImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, </span><br><span class="line">                                 mq, </span><br><span class="line">                                 communicationMode, </span><br><span class="line">                                 sendCallback, </span><br><span class="line">                                 topicPublishInfo, </span><br><span class="line">                                 timeout - costTime);</span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>如果上述发送过程出现异常，则调用<code>DefaultMQProducerImpl#updateFaultItem</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数一：broker名称</span></span><br><span class="line">    <span class="comment">//参数二:本次消息发送延迟时间</span></span><br><span class="line">    <span class="comment">//参数三:是否隔离</span></span><br><span class="line">    <span class="keyword">this</span>.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MQFaultStrategy#updateFaultItem</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="comment">//计算broker规避的时长</span></span><br><span class="line">        <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">        <span class="comment">//更新该FaultItem规避时长</span></span><br><span class="line">        <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MQFaultStrategy#computeNotAvailableDuration</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentLatency)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历latencyMax</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//找到第一个比currentLatency的latencyMax值</span></span><br><span class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.notAvailableDuration[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到则返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：LatencyFaultToleranceImpl#updateFaultItem</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得原FaultItem</span></span><br><span class="line">    FaultItem old = <span class="keyword">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="comment">//为空新建faultItem对象,设置规避时长和开始时间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</span><br><span class="line">        <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">new</span> FaultItem(name);</span><br><span class="line">        faultItem.setCurrentLatency(currentLatency);</span><br><span class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">        old = <span class="keyword">this</span>.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.setCurrentLatency(currentLatency);</span><br><span class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//更新规避时长和开始时间</span></span><br><span class="line">        old.setCurrentLatency(currentLatency);</span><br><span class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4）发送消息"><a href="#4）发送消息" class="headerlink" title="4）发送消息"></a>4）发送消息</h4><p>消息发送API核心入口<strong><em>DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Message msg,	//待发送消息</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue mq,	//消息发送队列</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,		//消息发送内模式</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback,	pp	//异步消息回调函数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,	//主题路由信息</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeout	//超时时间</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得broker网络地址信息</span></span><br><span class="line">String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">    <span class="comment">//没有找到从NameServer更新broker网络地址信息</span></span><br><span class="line">    tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">    brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为消息分类唯一ID</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">    MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> topicWithNamespace = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace()) &#123;</span><br><span class="line">    msg.setInstanceId(<span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">    topicWithNamespace = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消息大小超过4K,启用消息压缩</span></span><br><span class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">    msgBodyCompressed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是事务消息,设置消息标记MessageSysFlag.TRANSACTION_PREPARED_TYPE</span></span><br><span class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注册了消息发送钩子函数,在执行消息发送前的增强逻辑</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line">    context.setProducer(<span class="keyword">this</span>);</span><br><span class="line">    context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    context.setCommunicationMode(communicationMode);</span><br><span class="line">    context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">    context.setBrokerAddr(brokerAddr);</span><br><span class="line">    context.setMessage(msg);</span><br><span class="line">    context.setMq(mq);</span><br><span class="line">    context.setNamespace(<span class="keyword">this</span>.defaultMQProducer.getNamespace());</span><br><span class="line">    String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">        context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：SendMessageHook</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SendMessageHook</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hookName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息发送请求包</span></span><br><span class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line"><span class="comment">//生产者组</span></span><br><span class="line">requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line"><span class="comment">//主题</span></span><br><span class="line">requestHeader.setTopic(msg.getTopic());</span><br><span class="line"><span class="comment">//默认创建主题Key</span></span><br><span class="line">requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line"><span class="comment">//该主题在单个Broker默认队列树</span></span><br><span class="line">requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line"><span class="comment">//队列ID</span></span><br><span class="line">requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line"><span class="comment">//消息系统标记</span></span><br><span class="line">requestHeader.setSysFlag(sysFlag);</span><br><span class="line"><span class="comment">//消息发送时间</span></span><br><span class="line">requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line"><span class="comment">//消息标记</span></span><br><span class="line">requestHeader.setFlag(msg.getFlag());</span><br><span class="line"><span class="comment">//消息扩展信息</span></span><br><span class="line">requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"><span class="comment">//消息重试次数</span></span><br><span class="line">requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line"><span class="comment">//是否是批量消息等</span></span><br><span class="line">requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line"><span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">    String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">    <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">    <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ASYNC:		<span class="comment">//异步发送</span></span><br><span class="line">    Message tmpMessage = msg;</span><br><span class="line">    <span class="keyword">boolean</span> messageCloned = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">        messageCloned = <span class="keyword">true</span>;</span><br><span class="line">        msg.setBody(prevBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicWithNamespace) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!messageCloned) &#123;</span><br><span class="line">            tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">            messageCloned = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), </span><br><span class="line">                                                    <span class="keyword">this</span>.defaultMQProducer.getNamespace()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">		<span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">		    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">        			brokerAddr,</span><br><span class="line">        			mq.getBrokerName(),</span><br><span class="line">        			tmpMessage,</span><br><span class="line">        			requestHeader,</span><br><span class="line">        			timeout - costTimeAsync,</span><br><span class="line">        			communicationMode,</span><br><span class="line">        			sendCallback,</span><br><span class="line">        			topicPublishInfo,</span><br><span class="line">        			<span class="keyword">this</span>.mQClientFactory,</span><br><span class="line">        			<span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">        			context,</span><br><span class="line">        			<span class="keyword">this</span>);</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ONEWAY:</span><br><span class="line"><span class="keyword">case</span> SYNC:		<span class="comment">//同步发送</span></span><br><span class="line">    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">            brokerAddr,</span><br><span class="line">            mq.getBrokerName(),</span><br><span class="line">            msg,</span><br><span class="line">            requestHeader,</span><br><span class="line">            timeout - costTimeSync,</span><br><span class="line">            communicationMode,</span><br><span class="line">            context,</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注册了钩子函数,则发送完毕后执行钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context.setSendResult(sendResult);</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量消息发送"><a href="#批量消息发送" class="headerlink" title="批量消息发送"></a>批量消息发送</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029614.png" alt></p>
<p>批量消息发送是将同一个主题的多条消息一起打包发送到消息服务端，减少网络调用次数，提高网络传输效率。当然，并不是在同一批次中发送的消息数量越多越好，其判断依据是单条消息的长度，如果单条消息内容比较长，则打包多条消息发送会影响其他线程发送消息的响应时间，并且单批次消息总长度不能超过DefaultMQProducer#maxMessageSize。</p>
<p>批量消息发送要解决的问题是如何将这些消息编码以便服务端能够正确解码出每条消息的消息内容。</p>
<p><strong><em>代码：DefaultMQProducer#send</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Collection&lt;Message&gt; msgs)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//压缩消息集合成一条消息,然后发送出去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(batch(msgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducer#batch</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MessageBatch <span class="title">batch</span><span class="params">(Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    MessageBatch msgBatch;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将集合消息封装到MessageBatch</span></span><br><span class="line">        msgBatch = MessageBatch.generateFromList(msgs);</span><br><span class="line">        <span class="comment">//遍历消息集合,检查消息合法性,设置消息ID,设置Topic</span></span><br><span class="line">        <span class="keyword">for</span> (Message message : msgBatch) &#123;</span><br><span class="line">            Validators.checkMessage(message, <span class="keyword">this</span>);</span><br><span class="line">            MessageClientIDSetter.setUniqID(message);</span><br><span class="line">            message.setTopic(withNamespace(message.getTopic()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//压缩消息,设置消息body</span></span><br><span class="line">        msgBatch.setBody(msgBatch.encode());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"Failed to initiate the MessageBatch"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置msgBatch的topic</span></span><br><span class="line">    msgBatch.setTopic(withNamespace(msgBatch.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> msgBatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息存储-1"><a href="#消息存储-1" class="headerlink" title="消息存储"></a>消息存储</h2><h3 id="消息存储核心类"><a href="#消息存储核心类" class="headerlink" title="消息存储核心类"></a>消息存储核心类</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022355239.png" alt="image-20240902235558032"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageStoreConfig messageStoreConfig;	<span class="comment">//消息配置属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CommitLog commitLog;		<span class="comment">//CommitLog文件存储的实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, ConcurrentMap&lt;Integer<span class="comment">/* queueId */</span>, ConsumeQueue&gt;&gt; consumeQueueTable;	<span class="comment">//消息队列存储缓存表,按照消息主题分组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlushConsumeQueueService flushConsumeQueueService;	<span class="comment">//消息队列文件刷盘线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanCommitLogService cleanCommitLogService;	<span class="comment">//清除CommitLog文件服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanConsumeQueueService cleanConsumeQueueService;	<span class="comment">//清除ConsumerQueue队列文件服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IndexService indexService;	<span class="comment">//索引实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;	<span class="comment">//MappedFile分配服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReputMessageService reputMessageService;<span class="comment">//CommitLog消息分发,根据CommitLog文件构建ConsumerQueue、IndexFile文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HAService haService;	<span class="comment">//存储HA机制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduleMessageService scheduleMessageService;	<span class="comment">//消息服务调度线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StoreStatsService storeStatsService;	<span class="comment">//消息存储服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransientStorePool transientStorePool;	<span class="comment">//消息堆外内存缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerStatsManager brokerStatsManager;	<span class="comment">//Broker状态管理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageArrivingListener messageArrivingListener;	<span class="comment">//消息拉取长轮询模式消息达到监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerConfig brokerConfig;	<span class="comment">//Broker配置类</span></span><br><span class="line"><span class="keyword">private</span> StoreCheckpoint storeCheckpoint;	<span class="comment">//文件刷盘监测点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;CommitLogDispatcher&gt; dispatcherList;	<span class="comment">//CommitLog文件转发请求</span></span><br></pre></td></tr></table></figure>
<h3 id="消息存储流程"><a href="#消息存储流程" class="headerlink" title="消息存储流程"></a>消息存储流程</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029133.png" alt></p>
<p><strong><em>消息存储入口：DefaultMessageStore#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断Broker角色如果是从节点,则无需写入</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"message store is slave mode, so putMessage is forbidden "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前写入状态如果是正在写入,则不能继续</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isWriteable()) &#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.printTimes.set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断消息主题长度是否超过最大限制</span></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">"putMessage message topic length too long "</span> + msg.getTopic().length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断消息属性长度是否超过限制</span></span><br><span class="line"><span class="keyword">if</span> (msg.getPropertiesString() != <span class="keyword">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">"putMessage message properties length too long "</span> + msg.getPropertiesString().length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断系统PageCache缓存去是否占用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息写入CommitLog文件</span></span><br><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录消息存储时间</span></span><br><span class="line">msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断如果mappedFile如果为空或者已满,创建新的mappedFile文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">    mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果创建失败,直接返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">    log.error(<span class="string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入消息到mappedFile中</span></span><br><span class="line">result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MappedFile#appendMessagesInner</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得文件的写入指针</span></span><br><span class="line"><span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指针大于文件大小则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">    <span class="comment">//通过writeBuffer.slice()创建一个与MappedFile共享的内存区,并设置position为当前指针</span></span><br><span class="line">    ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">    byteBuffer.position(currentPos);</span><br><span class="line">    AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">       	<span class="comment">//通过回调方法写入</span></span><br><span class="line">        result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">        result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">    <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#doAppend</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件写入位置</span></span><br><span class="line"><span class="keyword">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</span><br><span class="line"><span class="comment">//设置消息ID</span></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line">String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得该消息在消息队列中的偏移量</span></span><br><span class="line">keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">keyBuilder.append(msgInner.getTopic());</span><br><span class="line">keyBuilder.append(<span class="string">'-'</span>);</span><br><span class="line">keyBuilder.append(msgInner.getQueueId());</span><br><span class="line">String key = keyBuilder.toString();</span><br><span class="line">Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == queueOffset) &#123;</span><br><span class="line">    queueOffset = <span class="number">0L</span>;</span><br><span class="line">    CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, queueOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息属性长度</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] propertiesData =msgInner.getPropertiesString() == <span class="keyword">null</span> ? <span class="keyword">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> propertiesLength = propertiesData == <span class="keyword">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息主题大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息体大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line"><span class="comment">//计算消息总长度</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#calMsgLength</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calMsgLength</span><span class="params">(<span class="keyword">int</span> bodyLength, <span class="keyword">int</span> topicLength, <span class="keyword">int</span> propertiesLength)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = <span class="number">4</span> <span class="comment">//TOTALSIZE</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//MAGICCODE  </span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//BODYCRC</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//QUEUEID</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//FLAG</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//QUEUEOFFSET</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//PHYSICALOFFSET</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//SYSFLAG</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//BORNTIMESTAMP</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//BORNHOST</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//STORETIMESTAMP</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//STOREHOSTADDRESS</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//RECONSUMETIMES</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//Prepared Transaction Offset</span></span><br><span class="line">        + <span class="number">4</span> + (bodyLength &gt; <span class="number">0</span> ? bodyLength : <span class="number">0</span>) <span class="comment">//BODY</span></span><br><span class="line">        + <span class="number">1</span> + topicLength <span class="comment">//TOPIC</span></span><br><span class="line">        + <span class="number">2</span> + (propertiesLength &gt; <span class="number">0</span> ? propertiesLength : <span class="number">0</span>) <span class="comment">//propertiesLength</span></span><br><span class="line">        + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> msgLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#doAppend</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息长度不能超过4M</span></span><br><span class="line"><span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</span><br><span class="line">    CommitLog.log.warn(<span class="string">"message size exceeded, msg total size: "</span> + msgLen + <span class="string">", msg body size: "</span> + bodyLength</span><br><span class="line">        + <span class="string">", maxMessageSize: "</span> + <span class="keyword">this</span>.maxMessageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息是如果没有足够的存储空间则新创建CommitLog文件</span></span><br><span class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">    <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">    <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">    <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">    <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line">    byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">        queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息存储到ByteBuffer中,返回AppendMessageResult</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line"><span class="comment">// Write messages to the queue buffer</span></span><br><span class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line">AppendMessageResult result = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, </span><br><span class="line">                                                     msgLen, msgId,msgInner.getStoreTimestamp(), </span><br><span class="line">                                                     queueOffset, </span><br><span class="line">                                                     CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() </span><br><span class="line">                                                     -beginTimeMills);</span><br><span class="line"><span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">        <span class="comment">//更新消息队列偏移量</span></span><br><span class="line">        CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, ++queueOffset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">putMessageLock.unlock();</span><br><span class="line"><span class="comment">//刷盘</span></span><br><span class="line">handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"><span class="comment">//执行HA主从同步</span></span><br><span class="line">handleHA(result, putMessageResult, msg);</span><br></pre></td></tr></table></figure>
<h3 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029142.png" alt></p>
<ul>
<li>commitLog：消息存储目录</li>
<li>config：运行期间一些配置信息</li>
<li>consumerqueue：消息消费队列存储目录</li>
<li>index：消息索引文件存储目录</li>
<li>abort：如果存在改文件寿命Broker非正常关闭</li>
<li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳。</li>
</ul>
<h3 id="存储文件内存映射"><a href="#存储文件内存映射" class="headerlink" title="存储文件内存映射"></a>存储文件内存映射</h3><p>RocketMQ通过使用内存映射文件提高IO访问性能，无论是CommitLog、ConsumerQueue还是IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。</p>
<h4 id="1）MappedFileQueue"><a href="#1）MappedFileQueue" class="headerlink" title="1）MappedFileQueue"></a>1）MappedFileQueue</h4><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022356039.png" alt="image-20240902235642878"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String storePath;	<span class="comment">//存储目录</span></span><br><span class="line"><span class="keyword">int</span> mappedFileSize;	<span class="comment">// 单个文件大小</span></span><br><span class="line">CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles;	<span class="comment">//MappedFile文件集合</span></span><br><span class="line">AllocateMappedFileService allocateMappedFileService;	<span class="comment">//创建MapFile服务类</span></span><br><span class="line"><span class="keyword">long</span> flushedWhere = <span class="number">0</span>;		<span class="comment">//当前刷盘指针</span></span><br><span class="line"><span class="keyword">long</span> committedWhere = <span class="number">0</span>;	<span class="comment">//当前数据提交指针,内存中ByteBuffer当前的写指针,该值大于等于flushWhere</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据存储时间查询MappedFile</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getMappedFileByTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    Object[] mfs = <span class="keyword">this</span>.copyMappedFiles(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mfs)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//遍历MappedFile文件数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mfs.length; i++) &#123;</span><br><span class="line">        MappedFile mappedFile = (MappedFile) mfs[i];</span><br><span class="line">        <span class="comment">//MappedFile文件的最后修改时间大于指定时间戳则返回该文件</span></span><br><span class="line">        <span class="keyword">if</span> (mappedFile.getLastModifiedTimestamp() &gt;= timestamp) &#123;</span><br><span class="line">            <span class="keyword">return</span> mappedFile;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (MappedFile) mfs[mfs.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据消息偏移量offset查找MappedFile</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得第一个MappedFile文件</span></span><br><span class="line">        MappedFile firstMappedFile = <span class="keyword">this</span>.getFirstMappedFile();</span><br><span class="line">        <span class="comment">//获得最后一个MappedFile文件</span></span><br><span class="line">        MappedFile lastMappedFile = <span class="keyword">this</span>.getLastMappedFile();</span><br><span class="line">        <span class="comment">//第一个文件和最后一个文件均不为空,则进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (firstMappedFile != <span class="keyword">null</span> &amp;&amp; lastMappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; firstMappedFile.getFileFromOffset() || </span><br><span class="line">                offset &gt;= lastMappedFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获得文件索引</span></span><br><span class="line">                <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((offset / <span class="keyword">this</span>.mappedFileSize) </span><br><span class="line">                                   - (firstMappedFile.getFileFromOffset() / <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">                MappedFile targetFile = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//根据索引返回目标文件</span></span><br><span class="line">                    targetFile = <span class="keyword">this</span>.mappedFiles.get(index);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetFile != <span class="keyword">null</span> &amp;&amp; offset &gt;= targetFile.getFileFromOffset()</span><br><span class="line">                    &amp;&amp; offset &lt; targetFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">                    <span class="keyword">return</span> targetFile;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (MappedFile tmpMappedFile : <span class="keyword">this</span>.mappedFiles) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (offset &gt;= tmpMappedFile.getFileFromOffset()</span><br><span class="line">                        &amp;&amp; offset &lt; tmpMappedFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">                        <span class="keyword">return</span> tmpMappedFile;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (returnFirstOnNotFound) &#123;</span><br><span class="line">                <span class="keyword">return</span> firstMappedFile;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"findMappedFileByOffset Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取存储文件最小偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMinOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.mappedFiles.get(<span class="number">0</span>).getFileFromOffset();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">//continue;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"getMinOffset has exception."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取存储文件最大偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFile = getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getReadPosition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回存储文件当前写指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxWrotePosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFile = getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getWrotePosition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）MappedFile"><a href="#2）MappedFile" class="headerlink" title="2）MappedFile"></a>2）MappedFile</h4><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029195.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_PAGE_SIZE = <span class="number">1024</span> * <span class="number">4</span>;		<span class="comment">//操作系统每页大小,默认4K</span></span><br><span class="line">AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);	<span class="comment">//当前JVM实例中MappedFile虚拟内存</span></span><br><span class="line">AtomicInteger TOTAL_MAPPED_FILES = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);	<span class="comment">//当前JVM实例中MappedFile对象个数</span></span><br><span class="line">AtomicInteger wrotePosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);	<span class="comment">//当前文件的写指针</span></span><br><span class="line">AtomicInteger committedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);	<span class="comment">//当前文件的提交指针</span></span><br><span class="line">AtomicInteger flushedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);	<span class="comment">//刷写到磁盘指针</span></span><br><span class="line"><span class="keyword">int</span> fileSize;	<span class="comment">//文件大小</span></span><br><span class="line">FileChannel fileChannel;	<span class="comment">//文件通道	</span></span><br><span class="line">ByteBuffer writeBuffer = <span class="keyword">null</span>;	<span class="comment">//堆外内存ByteBuffer</span></span><br><span class="line">TransientStorePool transientStorePool = <span class="keyword">null</span>;	<span class="comment">//堆外内存池</span></span><br><span class="line">String fileName;	<span class="comment">//文件名称</span></span><br><span class="line"><span class="keyword">long</span> fileFromOffset;	<span class="comment">//该文件的处理偏移量</span></span><br><span class="line">File file;	<span class="comment">//物理文件</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer;	<span class="comment">//物理文件对应的内存映射Buffer</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;	<span class="comment">//文件最后一次内容写入时间</span></span><br><span class="line"><span class="keyword">boolean</span> firstCreateInQueue = <span class="keyword">false</span>;	<span class="comment">//是否是MappedFileQueue队列中第一个文件</span></span><br></pre></td></tr></table></figure>
<p><strong><em>MappedFile初始化</em></strong></p>
<ul>
<li>未开启<code>transientStorePoolEnable</code>。<code>transientStorePoolEnable=true</code>为<code>true</code>表示数据先存储到堆外内存，然后通过<code>Commit</code>线程将数据提交到内存映射Buffer中，再通过<code>Flush</code>线程将内存映射<code>Buffer</code>中数据持久化磁盘。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">this</span>.fileSize = fileSize;</span><br><span class="line">    <span class="keyword">this</span>.file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">this</span>.fileFromOffset = Long.parseLong(<span class="keyword">this</span>.file.getName());</span><br><span class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">    ensureDirOK(<span class="keyword">this</span>.file.getParent());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.file, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer = <span class="keyword">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line">        TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);</span><br><span class="line">        TOTAL_MAPPED_FILES.incrementAndGet();</span><br><span class="line">        ok = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"create file channel "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"map file "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok &amp;&amp; <span class="keyword">this</span>.fileChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.fileChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启<code>transientStorePoolEnable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    init(fileName, fileSize);</span><br><span class="line">    <span class="keyword">this</span>.writeBuffer = transientStorePool.borrowBuffer();	<span class="comment">//初始化writeBuffer</span></span><br><span class="line">    <span class="keyword">this</span>.transientStorePool = transientStorePool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>MappedFile提交</em></strong></p>
<p>提交数据到FileChannel，commitLeastPages为本次提交最小的页数，如果待提交数据不满commitLeastPages，则不执行本次提交操作。如果writeBuffer如果为空，直接返回writePosition指针，无需执行commit操作，表名commit操作主体是writeBuffer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否满足提交条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToCommit(commitLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            commit0(commitLeastPages);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in commit, hold failed, commit offset = "</span> + <span class="keyword">this</span>.committedPosition.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数据提交后,清空缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.transientStorePool != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.fileSize == <span class="keyword">this</span>.committedPosition.get()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.transientStorePool.returnBuffer(writeBuffer);</span><br><span class="line">        <span class="keyword">this</span>.writeBuffer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>MappedFile#isAbleToCommit</em></strong></p>
<p>判断是否执行commit操作，如果文件已满返回true；如果commitLeastpages大于0，则比较writePosition与上一次提交的指针commitPosition的差值，除以OS_PAGE_SIZE得到当前脏页的数量，如果大于commitLeastPages则返回true，如果commitLeastpages小于0表示只要存在脏页就提交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAbleToCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经刷盘指针</span></span><br><span class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">    <span class="comment">//文件写指针</span></span><br><span class="line">    <span class="keyword">int</span> write = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">	<span class="comment">//写满刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//文件内容达到commitLeastPages页数,则刷盘</span></span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>MappedFile#commit0</em></strong></p>
<p>具体提交的实现，首先创建WriteBuffer区共享缓存区，然后将新创建的position回退到上一次提交的位置（commitPosition），设置limit为wrotePosition（当前最大有效数据指针），然后把commitPosition到wrotePosition的数据写入到FileChannel中，然后更新committedPosition指针为wrotePosition。commit的作用就是将MappedFile的writeBuffer中数据提交到文件通道FileChannel中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commit0</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//写指针</span></span><br><span class="line">    <span class="keyword">int</span> writePos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    <span class="comment">//上次提交指针</span></span><br><span class="line">    <span class="keyword">int</span> lastCommittedPosition = <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePos - <span class="keyword">this</span>.committedPosition.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//复制共享内存区域</span></span><br><span class="line">            ByteBuffer byteBuffer = writeBuffer.slice();</span><br><span class="line">            <span class="comment">//设置提交位置是上次提交位置</span></span><br><span class="line">            byteBuffer.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//最大提交数量</span></span><br><span class="line">            byteBuffer.limit(writePos);</span><br><span class="line">            <span class="comment">//设置fileChannel位置为上次提交位置</span></span><br><span class="line">            <span class="keyword">this</span>.fileChannel.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//将lastCommittedPosition到writePos的数据复制到FileChannel中</span></span><br><span class="line">            <span class="keyword">this</span>.fileChannel.write(byteBuffer);</span><br><span class="line">            <span class="comment">//重置提交位置</span></span><br><span class="line">            <span class="keyword">this</span>.committedPosition.set(writePos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when commit data to FileChannel."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>MappedFile#flush</em></strong></p>
<p>刷写磁盘，直接调用MappedByteBuffer或fileChannel的force方法将内存中的数据持久化到磁盘，那么flushedPosition应该等于MappedByteBuffer中的写指针；如果writeBuffer不为空，则flushPosition应该等于上一次的commit指针；因为上一次提交的数据就是进入到MappedByteBuffer中的数据；如果writeBuffer为空，数据时直接进入到MappedByteBuffer，wrotePosition代表的是MappedByteBuffer中的指针，故设置flushPosition为wrotePosition。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029194.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据达到刷盘条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class="line">        <span class="comment">//加锁，同步刷盘</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            <span class="comment">//获得读指针</span></span><br><span class="line">            <span class="keyword">int</span> value = getReadPosition();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//数据从writeBuffer提交数据到fileChannel再刷新到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//从mmap刷新数据到磁盘</span></span><br><span class="line">                    <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"Error occurred when force data to disk."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//更新刷盘位置</span></span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(value);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in flush, hold failed, flush offset = "</span> + <span class="keyword">this</span>.flushedPosition.get());</span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getFlushedPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>MappedFile#getReadPosition</em></strong></p>
<p>获取当前文件最大可读指针。如果writeBuffer为空，则直接返回当前的写指针；如果writeBuffer不为空，则返回上一次提交的指针。在MappedFile设置中,只有提交了的数据（写入到MappedByteBuffer或FileChannel中的数据）才是安全的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getReadPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果writeBuffer为空,刷盘的位置就是应该等于上次commit的位置,如果为空则为mmap的写指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writeBuffer == <span class="keyword">null</span> ? <span class="keyword">this</span>.wrotePosition.get() : <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>MappedFile#selectMappedBuffer</em></strong></p>
<p>查找pos到当前最大可读之间的数据，由于在整个写入期间都未曾改MappedByteBuffer的指针，如果mappedByteBuffer.slice()方法返回的共享缓存区空间为整个MappedFile，然后通过设置ByteBuffer的position为待查找的值，读取字节长度当前可读最大长度，最终返回的ByteBuffer的limit为size。整个共享缓存区的容量为（MappedFile#fileSize-pos）。故在操作SelectMappedBufferResult不能对包含在里面的ByteBuffer调用filp方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">selectMappedBuffer</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得最大可读指针</span></span><br><span class="line">    <span class="keyword">int</span> readPosition = getReadPosition();</span><br><span class="line">    <span class="comment">//pos小于最大可读指针,并且大于0</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; readPosition &amp;&amp; pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            <span class="comment">//复制mappedByteBuffer读共享区</span></span><br><span class="line">            ByteBuffer byteBuffer = <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">            <span class="comment">//设置读指针位置</span></span><br><span class="line">            byteBuffer.position(pos);</span><br><span class="line">            <span class="comment">//获得可读范围</span></span><br><span class="line">            <span class="keyword">int</span> size = readPosition - pos;</span><br><span class="line">            <span class="comment">//设置最大刻度范围</span></span><br><span class="line">            ByteBuffer byteBufferNew = byteBuffer.slice();</span><br><span class="line">            byteBufferNew.limit(size);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectMappedBufferResult(<span class="keyword">this</span>.fileFromOffset + pos, byteBufferNew, size, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>MappedFile#shutdown</em></strong></p>
<p>MappedFile文件销毁的实现方法为public boolean destory(long intervalForcibly)，intervalForcibly表示拒绝被销毁的最大存活时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> intervalForcibly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.available) &#123;</span><br><span class="line">        <span class="comment">//关闭MapedFile</span></span><br><span class="line">        <span class="keyword">this</span>.available = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//设置当前关闭时间戳</span></span><br><span class="line">        <span class="keyword">this</span>.firstShutdownTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">this</span>.release();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getRefCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((System.currentTimeMillis() - <span class="keyword">this</span>.firstShutdownTimestamp) &gt;= intervalForcibly) &#123;</span><br><span class="line">            <span class="keyword">this</span>.refCount.set(-<span class="number">1000</span> - <span class="keyword">this</span>.getRefCount());</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3）TransientStorePool"><a href="#3）TransientStorePool" class="headerlink" title="3）TransientStorePool"></a>3）TransientStorePool</h4><p>短暂的存储池。RocketMQ单独创建一个MappedByteBuffer内存缓存池，用来临时存储数据，数据先写入该内存映射中，然后由commit线程定时将数据从该内存复制到与目标物理文件对应的内存映射中。RocketMQ引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。</p>
<p><img src="/Users/zhangxuefeng/Desktop/黑马rocketmq/RocketMQ-1/文档/img/TransientStorePool.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;		<span class="comment">//availableBuffers个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fileSize;		<span class="comment">//每隔ByteBuffer大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; availableBuffers;	<span class="comment">//ByteBuffer容器。双端队列</span></span><br></pre></td></tr></table></figure>
<p><strong><em>初始化</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建poolSize个堆外内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> address = ((DirectBuffer) byteBuffer).address();</span><br><span class="line">        Pointer pointer = <span class="keyword">new</span> Pointer(address);</span><br><span class="line">        <span class="comment">//使用com.sun.jna.Library类库将该批内存锁定,避免被置换到交换区,提高存储性能</span></span><br><span class="line">        LibC.INSTANCE.mlock(pointer, <span class="keyword">new</span> NativeLong(fileSize));</span><br><span class="line"></span><br><span class="line">        availableBuffers.offer(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实时更新消息消费队列与索引文件"><a href="#实时更新消息消费队列与索引文件" class="headerlink" title="实时更新消息消费队列与索引文件"></a>实时更新消息消费队列与索引文件</h3><p>消息消费队文件、消息属性索引文件都是基于CommitLog文件构建的，当消息生产者提交的消息存储在CommitLog文件中，ConsumerQueue、IndexFile需要及时更新，否则消息无法及时被消费，根据消息属性查找消息也会出现较大延迟。RocketMQ通过开启一个线程ReputMessageService来准实时转发CommitLog文件更新事件，相应的任务处理器根据转发的消息及时更新ConsumerQueue、IndexFile文件。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029437.png" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029251.png" alt></p>
<p><strong><em>代码：DefaultMessageStore：start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置CommitLog内存中最大偏移量</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore：run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">	<span class="comment">//每隔1毫秒就继续尝试推送消息到消息消费队列和索引文件</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore：deReput</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从result中循环遍历消息,一次读一条,创建DispatherRequest对象。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">	DispatchRequest dispatchRequest =                               DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">int</span> size = dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	        DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>DispatchRequest</em></strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022357225.png" alt="image-20240902235751012"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String topic; <span class="comment">//消息主题名称</span></span><br><span class="line"><span class="keyword">int</span> queueId;  <span class="comment">//消息队列ID</span></span><br><span class="line"><span class="keyword">long</span> commitLogOffset;	<span class="comment">//消息物理偏移量</span></span><br><span class="line"><span class="keyword">int</span> msgSize;	<span class="comment">//消息长度</span></span><br><span class="line"><span class="keyword">long</span> tagsCode;	<span class="comment">//消息过滤tag hashCode</span></span><br><span class="line"><span class="keyword">long</span> storeTimestamp;	<span class="comment">//消息存储时间戳</span></span><br><span class="line"><span class="keyword">long</span> consumeQueueOffset;	<span class="comment">//消息队列偏移量</span></span><br><span class="line">String keys;	<span class="comment">//消息索引key</span></span><br><span class="line"><span class="keyword">boolean</span> success;	<span class="comment">//是否成功解析到完整的消息</span></span><br><span class="line">String uniqKey;	<span class="comment">//消息唯一键</span></span><br><span class="line"><span class="keyword">int</span> sysFlag;	<span class="comment">//消息系统标记</span></span><br><span class="line"><span class="keyword">long</span> preparedTransactionOffset;	<span class="comment">//消息预处理事务偏移量</span></span><br><span class="line">Map&lt;String, String&gt; propertiesMap;	<span class="comment">//消息属性</span></span><br><span class="line"><span class="keyword">byte</span>[] bitMap;	<span class="comment">//位图</span></span><br></pre></td></tr></table></figure>
<h4 id="1）转发到ConsumerQueue"><a href="#1）转发到ConsumerQueue" class="headerlink" title="1）转发到ConsumerQueue"></a>1）转发到ConsumerQueue</h4><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022358387.png" alt="image-20240902235816276"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="comment">//消息分发</span></span><br><span class="line">                DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#putMessagePositionInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得消费队列</span></span><br><span class="line">    ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">    <span class="comment">//消费队列分发消息</span></span><br><span class="line">    cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#putMessagePositionInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次将消息偏移量、消息长度、tag写入到ByteBuffer中</span></span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"><span class="comment">//获得内存映射文件</span></span><br><span class="line">MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line"><span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//将消息追加到内存映射文件,异步输盘</span></span><br><span class="line">    <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）转发到Index"><a href="#2）转发到Index" class="headerlink" title="2）转发到Index"></a>2）转发到Index</h4><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029024.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#buildIndex</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得索引文件</span></span><br><span class="line">    IndexFile indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">    <span class="keyword">if</span> (indexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获得文件最大物理偏移量</span></span><br><span class="line">        <span class="keyword">long</span> endPhyOffset = indexFile.getEndPhyOffset();</span><br><span class="line">        DispatchRequest msg = req;</span><br><span class="line">        String topic = msg.getTopic();</span><br><span class="line">        String keys = msg.getKeys();</span><br><span class="line">        <span class="comment">//如果该消息的物理偏移量小于索引文件中的最大物理偏移量,则说明是重复数据,忽略本次索引构建</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果消息ID不为空,则添加到Hash索引中</span></span><br><span class="line">        <span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</span><br><span class="line">            <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//构建索引key,RocketMQ支持为同一个消息建立多个索引,多个索引键空格隔开.</span></span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">                String key = keyset[i];</span><br><span class="line">                <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line">                    <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">"build index error, stop building index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息队列和索引文件恢复"><a href="#消息队列和索引文件恢复" class="headerlink" title="消息队列和索引文件恢复"></a>消息队列和索引文件恢复</h3><p>由于RocketMQ存储首先将消息全量存储在CommitLog文件中，然后异步生成转发任务更新ConsumerQueue和Index文件。如果消息成功存储到CommitLog文件中，转发任务未成功执行，此时消息服务器Broker由于某个愿意宕机，导致CommitLog、ConsumerQueue、IndexFile文件数据不一致。如果不加以人工修复的话，会有一部分消息即便在CommitLog中文件中存在，但由于没有转发到ConsumerQueue，这部分消息将永远复发被消费者消费。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022358951.png" alt="image-20240902235851832"></p>
<h4 id="1）存储文件加载"><a href="#1）存储文件加载" class="headerlink" title="1）存储文件加载"></a>1）存储文件加载</h4><p><strong><em>代码：DefaultMessageStore#load</em></strong></p>
<p>判断上一次是否异常退出。实现机制是Broker在启动时创建abort文件，在退出时通过JVM钩子函数删除abort文件。如果下次启动时存在abort文件。说明Broker时异常退出的，CommitLog与ConsumerQueue数据有可能不一致，需要进行修复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断临时文件是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> lastExitOK = !<span class="keyword">this</span>.isTempFileExist();</span><br><span class="line"><span class="comment">//根据临时文件判断当前Broker是否异常退出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTempFileExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String fileName = StorePathConfigHelper</span><br><span class="line">        .getAbortFile(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir());</span><br><span class="line">    File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">return</span> file.exists();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#load</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载延时队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载CommitLog文件</span></span><br><span class="line">result = result &amp;&amp; <span class="keyword">this</span>.commitLog.load();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载消费队列文件</span></span><br><span class="line">result = result &amp;&amp; <span class="keyword">this</span>.loadConsumeQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">	<span class="comment">//加载存储监测点,监测点主要记录CommitLog文件、ConsumerQueue文件、Index索引文件的刷盘点</span></span><br><span class="line">    <span class="keyword">this</span>.storeCheckpoint =<span class="keyword">new</span> StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line">	<span class="comment">//加载index文件</span></span><br><span class="line">    <span class="keyword">this</span>.indexService.load(lastExitOK);</span><br><span class="line">	<span class="comment">//根据Broker是否异常退出,执行不同的恢复策略</span></span><br><span class="line">    <span class="keyword">this</span>.recover(lastExitOK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MappedFileQueue#load</em></strong></p>
<p>加载CommitLog到映射文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向CommitLog文件目录</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="keyword">this</span>.storePath);</span><br><span class="line"><span class="comment">//获得文件数组</span></span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 文件排序</span></span><br><span class="line">    Arrays.sort(files);</span><br><span class="line">    <span class="comment">//遍历文件</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">		<span class="comment">//如果文件大小和配置文件不一致,退出</span></span><br><span class="line">        <span class="keyword">if</span> (file.length() != <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建映射文件</span></span><br><span class="line">            MappedFile mappedFile = <span class="keyword">new</span> MappedFile(file.getPath(), mappedFileSize);</span><br><span class="line">            mappedFile.setWrotePosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            mappedFile.setFlushedPosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            mappedFile.setCommittedPosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            <span class="comment">//将映射文件添加到队列</span></span><br><span class="line">            <span class="keyword">this</span>.mappedFiles.add(mappedFile);</span><br><span class="line">            log.info(<span class="string">"load "</span> + file.getPath() + <span class="string">" OK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"load file "</span> + file + <span class="string">" error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#loadConsumeQueue</em></strong></p>
<p>加载消息消费队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行消费队列目录</span></span><br><span class="line">File dirLogic = <span class="keyword">new</span> File(StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line"><span class="comment">//遍历消费队列目录</span></span><br><span class="line">File[] fileTopicList = dirLogic.listFiles();</span><br><span class="line"><span class="keyword">if</span> (fileTopicList != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File fileTopic : fileTopicList) &#123;</span><br><span class="line">        <span class="comment">//获得子目录名称,即topic名称</span></span><br><span class="line">        String topic = fileTopic.getName();</span><br><span class="line">		<span class="comment">//遍历子目录下的消费队列文件</span></span><br><span class="line">        File[] fileQueueIdList = fileTopic.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (fileQueueIdList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历文件</span></span><br><span class="line">            <span class="keyword">for</span> (File fileQueueId : fileQueueIdList) &#123;</span><br><span class="line">                <span class="comment">//文件名称即队列ID</span></span><br><span class="line">                <span class="keyword">int</span> queueId;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queueId = Integer.parseInt(fileQueueId.getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建消费队列并加载到内存</span></span><br><span class="line">                ConsumeQueue logic = <span class="keyword">new</span> ConsumeQueue(</span><br><span class="line">                    topic,</span><br><span class="line">                    queueId,</span><br><span class="line">                    StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class="line">            <span class="keyword">this</span>.getMessageStoreConfig().getMapedFileSizeConsumeQueue(),</span><br><span class="line">                    <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">this</span>.putConsumeQueue(topic, queueId, logic);</span><br><span class="line">                <span class="keyword">if</span> (!logic.load()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"load logics queue all over, OK"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：IndexService#load</em></strong></p>
<p>加载索引文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//索引文件目录</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="keyword">this</span>.storePath);</span><br><span class="line">    <span class="comment">//遍历索引文件</span></span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//文件排序</span></span><br><span class="line">        Arrays.sort(files);</span><br><span class="line">        <span class="comment">//遍历文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加载索引文件</span></span><br><span class="line">                IndexFile f = <span class="keyword">new</span> IndexFile(file.getPath(), <span class="keyword">this</span>.hashSlotNum, <span class="keyword">this</span>.indexNum, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                f.load();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!lastExitOK) &#123;</span><br><span class="line">                    <span class="comment">//索引文件上次的刷盘时间小于该索引文件的消息时间戳,该文件将立即删除</span></span><br><span class="line">                    <span class="keyword">if</span> (f.getEndTimestamp() &gt; <span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint()</span><br><span class="line">                        .getIndexMsgTimestamp()) &#123;</span><br><span class="line">                        f.destroy(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//将索引文件添加到队列</span></span><br><span class="line">                log.info(<span class="string">"load index file OK, "</span> + f.getFileName());</span><br><span class="line">                <span class="keyword">this</span>.indexFileList.add(f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">"load file &#123;&#125; error"</span>, file, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                log.error(<span class="string">"load file &#123;&#125; error"</span>, file, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#recover</em></strong></p>
<p>文件恢复，根据Broker是否正常退出执行不同的恢复策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得最大的物理便宜消费队列</span></span><br><span class="line">    <span class="keyword">long</span> maxPhyOffsetOfConsumeQueue = <span class="keyword">this</span>.recoverConsumeQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastExitOK) &#123;</span><br><span class="line">        <span class="comment">//正常恢复</span></span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverNormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//异常恢复</span></span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverAbnormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//在CommitLog中保存每个消息消费队列当前的存储逻辑偏移量</span></span><br><span class="line">    <span class="keyword">this</span>.recoverTopicQueueTable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#recoverTopicQueueTable</em></strong></p>
<p>恢复ConsumerQueue后，将在CommitLog实例中保存每隔消息队列当前的存储逻辑偏移量，这也是消息中不仅存储主题、消息队列ID、还存储了消息队列的关键所在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTopicQueueTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String<span class="comment">/* topic-queueid */</span>, Long<span class="comment">/* offset */</span>&gt; table = <span class="keyword">new</span> HashMap&lt;String, Long&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//CommitLog最小偏移量</span></span><br><span class="line">    <span class="keyword">long</span> minPhyOffset = <span class="keyword">this</span>.commitLog.getMinOffset();</span><br><span class="line">    <span class="comment">//遍历消费队列,将消费队列保存在CommitLog中</span></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : <span class="keyword">this</span>.consumeQueueTable.values()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumeQueue logic : maps.values()) &#123;</span><br><span class="line">            String key = logic.getTopic() + <span class="string">"-"</span> + logic.getQueueId();</span><br><span class="line">            table.put(key, logic.getMaxOffsetInQueue());</span><br><span class="line">            logic.correctMinOffset(minPhyOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.commitLog.setTopicQueueTable(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）正常恢复"><a href="#2）正常恢复" class="headerlink" title="2）正常恢复"></a>2）正常恢复</h4><p><strong><em>代码：CommitLog#recoverNormally</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverNormally</span><span class="params">(<span class="keyword">long</span> maxPhyOffsetOfConsumeQueue)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="keyword">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">//Broker正常停止再重启时,从倒数第三个开始恢复,如果不足3个文件,则从第一个文件开始恢复。</span></span><br><span class="line">        <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        MappedFile mappedFile = mappedFiles.get(index);</span><br><span class="line">        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">        <span class="keyword">long</span> processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">        <span class="comment">//代表当前已校验通过的offset</span></span><br><span class="line">        <span class="keyword">long</span> mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//查找消息</span></span><br><span class="line">            DispatchRequest dispatchRequest = <span class="keyword">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</span><br><span class="line">            <span class="comment">//消息长度</span></span><br><span class="line">            <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line">           	<span class="comment">//查找结果为true,并且消息长度大于0,表示消息正确.mappedFileOffset向前移动本消息长度</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mappedFileOffset += size;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果查找结果为true且消息长度等于0,表示已到该文件末尾,如果还有下一个文件,则重置processOffset和MappedFileOffset重复查找下一个文件,否则跳出循环。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size == <span class="number">0</span>) &#123;</span><br><span class="line">              index++;</span><br><span class="line">              <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123;</span><br><span class="line">                  <span class="comment">// Current branch can not happen</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//取出每个文件</span></span><br><span class="line">                  mappedFile = mappedFiles.get(index);</span><br><span class="line">                  byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">                  processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">                  mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">                  </span><br><span class="line">          		&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查找结果为false，表明该文件未填满所有消息，跳出循环，结束循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">"recover physics file end, "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//更新MappedFileQueue的flushedWhere和committedWhere指针</span></span><br><span class="line">        processOffset += mappedFileOffset;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class="line">        <span class="comment">//删除offset之后的所有文件</span></span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxPhyOffsetOfConsumeQueue &gt;= processOffset) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMessageStore.truncateDirtyLogicFiles(processOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MappedFileQueue#truncateDirtyFiles</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">truncateDirtyFiles</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    List&lt;MappedFile&gt; willRemoveFiles = <span class="keyword">new</span> ArrayList&lt;MappedFile&gt;();</span><br><span class="line">	<span class="comment">//遍历目录下文件</span></span><br><span class="line">    <span class="keyword">for</span> (MappedFile file : <span class="keyword">this</span>.mappedFiles) &#123;</span><br><span class="line">        <span class="comment">//文件尾部的偏移量</span></span><br><span class="line">        <span class="keyword">long</span> fileTailOffset = file.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize;</span><br><span class="line">        <span class="comment">//文件尾部的偏移量大于offset</span></span><br><span class="line">        <span class="keyword">if</span> (fileTailOffset &gt; offset) &#123;</span><br><span class="line">            <span class="comment">//offset大于文件的起始偏移量</span></span><br><span class="line">            <span class="keyword">if</span> (offset &gt;= file.getFileFromOffset()) &#123;</span><br><span class="line">                <span class="comment">//更新wrotePosition、committedPosition、flushedPosistion</span></span><br><span class="line">                file.setWrotePosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">                file.setCommittedPosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">                file.setFlushedPosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//offset小于文件的起始偏移量,说明该文件是有效文件后面创建的,释放mappedFile占用内存,删除文件</span></span><br><span class="line">                file.destroy(<span class="number">1000</span>);</span><br><span class="line">                willRemoveFiles.add(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.deleteExpiredFile(willRemoveFiles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3）异常恢复"><a href="#3）异常恢复" class="headerlink" title="3）异常恢复"></a>3）异常恢复</h4><p>Broker异常停止文件恢复的实现为CommitLog#recoverAbnormally。异常文件恢复步骤与正常停止文件恢复流程基本相同，其主要差别有两个。首先，正常停止默认从倒数第三个文件开始进行恢复，而异常停止则需要从最后一个文件往前走，找到第一个消息存储正常的文件。其次，如果CommitLog目录没有消息文件，如果消息消费队列目录下存在文件，则需要销毁。</p>
<p><strong><em>代码：CommitLog#recoverAbnormally</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// Looking beginning to recover from which file</span></span><br><span class="line">    <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">1</span>;</span><br><span class="line">    MappedFile mappedFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        mappedFile = mappedFiles.get(index);</span><br><span class="line">        <span class="comment">//判断消息文件是否是一个正确的文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isMappedFileMatchedRecover(mappedFile)) &#123;</span><br><span class="line">            log.info(<span class="string">"recover from this mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//根据索引取出mappedFile文件</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        mappedFile = mappedFiles.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...验证消息的合法性,并将消息转发到消息消费队列和索引文件</span></span><br><span class="line">       </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//未找到mappedFile,重置flushWhere、committedWhere都为0，销毁消息队列文件</span></span><br><span class="line">    <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="刷盘机制-1"><a href="#刷盘机制-1" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><p>RocketMQ的存储是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘。</p>
<h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>消息追加到内存后，立即将数据刷写到磁盘文件</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029326.png" alt></p>
<p><strong><em>代码：CommitLog#handleDiskFlush</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷盘服务</span></span><br><span class="line"><span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line"><span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">    <span class="comment">//封装刷盘请求</span></span><br><span class="line">    GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">    <span class="comment">//提交刷盘请求</span></span><br><span class="line">    service.putRequest(request);</span><br><span class="line">    <span class="comment">//线程阻塞5秒，等待刷盘结束</span></span><br><span class="line">    <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">        putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>GroupCommitRequest</em></strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029556.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> nextOffset;	<span class="comment">//刷盘点偏移量</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);	<span class="comment">//倒计树锁存器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;	<span class="comment">//刷盘结果;默认为false</span></span><br></pre></td></tr></table></figure>
<p><strong><em>代码：GroupCommitService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//线程等待10ms</span></span><br><span class="line">            <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//执行提交</span></span><br><span class="line">            <span class="keyword">this</span>.doCommit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：GroupCommitService#doCommit</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历requestsRead</span></span><br><span class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                <span class="comment">// two times the flush</span></span><br><span class="line">                <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    flushOK = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">					<span class="comment">//刷盘</span></span><br><span class="line">                    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                        CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//唤醒发送消息客户端</span></span><br><span class="line">                req.wakeupCustomer(flushOK);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//更新刷盘监测点</span></span><br><span class="line">            <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;               CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">            <span class="comment">// will come to this process</span></span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>在消息追加到内存后，立即返回给消息发送端。如果开启transientStorePoolEnable，RocketMQ会单独申请一个与目标物理文件（commitLog）同样大小的堆外内存，该堆外内存将使用内存锁定，确保不会被置换到虚拟内存中去，消息首先追加到堆外内存，然后提交到物理文件的内存映射中，然后刷写到磁盘。如果未开启transientStorePoolEnable，消息直接追加到物理文件直接映射文件中，然后刷写到磁盘中。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022359901.png" alt="image-20240902235930720"></p>
<p>开启transientStorePoolEnable后异步刷盘步骤:</p>
<ol>
<li>将消息直接追加到ByteBuffer（堆外内存）</li>
<li>CommitRealTimeService线程每隔200ms将ByteBuffer新追加内容提交到MappedByteBuffer中</li>
<li>MappedByteBuffer在内存中追加提交的内容，wrotePosition指针向后移动</li>
<li>commit操作成功返回，将committedPosition位置恢复</li>
<li>FlushRealTimeService线程默认每500ms将MappedByteBuffer中新追加的内存刷写到磁盘</li>
</ol>
<p><strong><em>代码：CommitLog$CommitRealTimeService#run</em></strong></p>
<p>提交线程工作机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//间隔时间,默认200ms</span></span><br><span class="line"><span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次提交的至少页数</span></span><br><span class="line"><span class="keyword">int</span> commitDataLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</span><br><span class="line"></span><br><span class="line"><span class="comment">//两次真实提交的最大间隔,默认200ms</span></span><br><span class="line"><span class="keyword">int</span> commitDataThoroughInterval =</span><br><span class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上次提交间隔超过commitDataThoroughInterval,则忽略提交commitDataThoroughInterval参数,直接提交</span></span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= (<span class="keyword">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastCommitTimestamp = begin;</span><br><span class="line">    commitDataLeastPages = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行提交操作,将待提交数据提交到物理文件的内存映射区</span></span><br><span class="line"><span class="keyword">boolean</span> result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.commit(commitDataLeastPages);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastCommitTimestamp = end; <span class="comment">// result = false means some data committed.</span></span><br><span class="line">    <span class="comment">//now wake up flush thread.</span></span><br><span class="line">    <span class="comment">//唤醒刷盘线程</span></span><br><span class="line">    flushCommitLogService.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end - begin &gt; <span class="number">500</span>) &#123;</span><br><span class="line">    log.info(<span class="string">"Commit data to file costs &#123;&#125; ms"</span>, end - begin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.waitForRunning(interval);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog$FlushRealTimeService#run</em></strong></p>
<p>刷盘线程工作机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示await方法等待,默认false</span></span><br><span class="line"><span class="keyword">boolean</span> flushCommitLogTimed = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line"><span class="comment">//线程执行时间间隔</span></span><br><span class="line"><span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line"><span class="comment">//一次刷写任务至少包含页数</span></span><br><span class="line"><span class="keyword">int</span> flushPhysicQueueLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line"><span class="comment">//两次真实刷写任务最大间隔</span></span><br><span class="line"><span class="keyword">int</span> flushPhysicQueueThoroughInterval =</span><br><span class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//距离上次提交间隔超过flushPhysicQueueThoroughInterval,则本次刷盘任务将忽略flushPhysicQueueLeastPages,直接提交</span></span><br><span class="line"><span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="keyword">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">    flushPhysicQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">    printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//执行一次刷盘前,先等待指定时间间隔</span></span><br><span class="line"><span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">    Thread.sleep(interval);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//刷写磁盘</span></span><br><span class="line">CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line"><span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line"><span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//更新存储监测点文件的时间戳</span></span><br><span class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br></pre></td></tr></table></figure>
<h3 id="过期文件删除机制"><a href="#过期文件删除机制" class="headerlink" title="过期文件删除机制"></a>过期文件删除机制</h3><p>由于RocketMQ操作CommitLog、ConsumerQueue文件是基于内存映射机制并在启动的时候回加载CommitLog、ConsumerQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久存储在消息服务器上，所以要引入一种机制来删除已过期的文件。RocketMQ顺序写CommitLog、ConsumerQueue文件，所有写操作全部落在最后一个CommitLog或者ConsumerQueue文件上，之前的文件在下一个文件创建后将不会再被更新。RocketMQ清除过期文件的方法时：如果当前文件在在一定时间间隔内没有再次被消费，则认为是过期文件，可以被删除，RocketMQ不会关注这个文件上的消息是否全部被消费。默认每个文件的过期时间为72小时，通过在Broker配置文件中设置fileReservedTime来改变过期时间，单位为小时。</p>
<p><strong><em>代码：DefaultMessageStore#addScheduleTask</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//每隔10s调度一次清除文件</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.cleanFilesPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span>, <span class="keyword">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#cleanFilesPeriodically</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanFilesPeriodically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清除存储文件</span></span><br><span class="line">    <span class="keyword">this</span>.cleanCommitLogService.run();</span><br><span class="line">    <span class="comment">//清除消息消费队列文件</span></span><br><span class="line">    <span class="keyword">this</span>.cleanConsumeQueueService.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#deleteExpiredFiles</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteExpiredFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除的数量</span></span><br><span class="line">    <span class="keyword">int</span> deleteCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//文件保留的时间</span></span><br><span class="line">    <span class="keyword">long</span> fileReservedTime = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getFileReservedTime();</span><br><span class="line">    <span class="comment">//删除物理文件的间隔</span></span><br><span class="line">    <span class="keyword">int</span> deletePhysicFilesInterval = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDeleteCommitLogFilesInterval();</span><br><span class="line">    <span class="comment">//线程被占用,第一次拒绝删除后能保留的最大时间,超过该时间,文件将被强制删除</span></span><br><span class="line">    <span class="keyword">int</span> destroyMapedFileIntervalForcibly = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> timeup = <span class="keyword">this</span>.isTimeToDelete();</span><br><span class="line"><span class="keyword">boolean</span> spacefull = <span class="keyword">this</span>.isSpaceToDelete();</span><br><span class="line"><span class="keyword">boolean</span> manualDelete = <span class="keyword">this</span>.manualDeleteFileSeveralTimes &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (timeup || spacefull || manualDelete) &#123;</span><br><span class="line">	...执行删除逻辑</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...无作为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除文件操作的条件</p>
<ol>
<li>指定删除文件的时间点，RocketMQ通过deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认4点</li>
<li>磁盘空间如果不充足，删除过期文件</li>
<li>预留，手工触发。</li>
</ol>
<p><strong><em>代码：CleanCommitLogService#isSpaceToDelete</em></strong></p>
<p>当磁盘空间不足时执行删除过期文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSpaceToDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//磁盘分区的最大使用量</span></span><br><span class="line">    <span class="keyword">double</span> ratio = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDiskMaxUsedSpaceRatio() / <span class="number">100.0</span>;</span><br><span class="line">	<span class="comment">//是否需要立即执行删除过期文件操作</span></span><br><span class="line">    cleanImmediately = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        String storePathPhysic = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getStorePathCommitLog();</span><br><span class="line">        <span class="comment">//当前CommitLog目录所在的磁盘分区的磁盘使用率</span></span><br><span class="line">        <span class="keyword">double</span> physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);</span><br><span class="line">        <span class="comment">//diskSpaceWarningLevelRatio:磁盘使用率警告阈值,默认0.90</span></span><br><span class="line">        <span class="keyword">if</span> (physicRatio &gt; diskSpaceWarningLevelRatio) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskFull();</span><br><span class="line">            <span class="keyword">if</span> (diskok) &#123;</span><br><span class="line">                DefaultMessageStore.log.error(<span class="string">"physic disk maybe full soon "</span> + physicRatio + <span class="string">", so mark disk full"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//diskSpaceCleanForciblyRatio:强制清除阈值,默认0.85</span></span><br><span class="line">            cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (physicRatio &gt; diskSpaceCleanForciblyRatio) &#123;</span><br><span class="line">            cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskOK();</span><br><span class="line">            <span class="keyword">if</span> (!diskok) &#123;</span><br><span class="line">            DefaultMessageStore.log.info(<span class="string">"physic disk space OK "</span> + physicRatio + <span class="string">", so mark disk ok"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (physicRatio &lt; <span class="number">0</span> || physicRatio &gt; ratio) &#123;</span><br><span class="line">        DefaultMessageStore.log.info(<span class="string">"physic disk maybe full soon, so reclaim space, "</span> + physicRatio);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MappedFileQueue#deleteExpiredFileByTime</em></strong></p>
<p>执行文件销毁和删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mfsLength; i++) &#123;</span><br><span class="line">    <span class="comment">//遍历每隔文件</span></span><br><span class="line">    MappedFile mappedFile = (MappedFile) mfs[i];</span><br><span class="line">    <span class="comment">//计算文件存活时间</span></span><br><span class="line">    <span class="keyword">long</span> liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime;</span><br><span class="line">    <span class="comment">//如果超过72小时,执行文件删除</span></span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &gt;= liveMaxTimestamp || cleanImmediately) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedFile.destroy(intervalForcibly)) &#123;</span><br><span class="line">            files.add(mappedFile);</span><br><span class="line">            deleteCount++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (files.size() &gt;= DELETE_FILES_BATCH_MAX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (deleteFilesInterval &gt; <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) &lt; mfsLength) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(deleteFilesInterval);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//avoid deleting files in the middle</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>RocketMQ的存储文件包括消息文件（Commitlog）、消息消费队列文件（ConsumerQueue）、Hash索引文件（IndexFile）、监测点文件（checkPoint）、abort（关闭异常文件）。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。RocketMQ组织文件以文件的起始偏移量来命令文件，这样根据偏移量能快速定位到真实的物理文件。RocketMQ基于内存映射文件机制提供了同步刷盘和异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的文件数据刷写到磁盘。</p>
<p>CommitLog，消息存储文件，RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储所有主题消息，保证消息存储是完全的顺序写，但这样给文件读取带来了不便，为此RocketMQ为了方便消息消费构建了消息消费队列文件，基于主题与队列进行组织，同时RocketMQ为消息实现了Hash索引，可以为消息设置索引键，根据索引能够快速从CommitLog文件中检索消息。</p>
<p>当消息达到CommitLog后，会通过ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。为了安全起见，RocketMQ引入abort文件，记录Broker的停机是否是正常关闭还是异常关闭，在重启Broker时为了保证CommitLog文件，消息消费队列文件与Hash索引文件的正确性，分别采用不同策略来恢复文件。</p>
<p>RocketMQ不会永久存储消息文件、消息消费队列文件，而是启动文件过期机制并在磁盘空间不足或者默认凌晨4点删除过期文件，文件保存72小时并且在删除文件时并不会判断该消息文件上的消息是否被消费。</p>
<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><h3 id="消息消费概述"><a href="#消息消费概述" class="headerlink" title="消息消费概述"></a>消息消费概述</h3><p>消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费者组可订阅多个主题，消费组之间有ff式和广播模式两种消费模式。集群模式，主题下的同一条消息只允许被其中一个消费者消费。广播模式，主题下的同一条消息，将被集群内的所有消费者消费一次。消息服务器与消费者之间的消息传递也有两种模式：推模式、拉模式。所谓的拉模式，是消费端主动拉起拉消息请求，而推模式是消息达到消息服务器后，推送给消息消费者。RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务。</p>
<p>集群模式下，多个消费者如何对消息队列进行负载呢？消息队列负载机制遵循一个通用思想：一个消息队列同一个时间只允许被一个消费者消费，一个消费者可以消费多个消息队列。</p>
<p>RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。不支持消息全局顺序消费，如果要实现某一个主题的全局顺序消费，可以将该主题的队列数设置为1，牺牲高可用性。</p>
<h3 id="消息消费初探"><a href="#消息消费初探" class="headerlink" title="消息消费初探"></a>消息消费初探</h3><p><strong><u>消息推送模式</u></strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029954.png" alt></p>
<p><strong><u>消息消费重要方法</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span>：发送消息确认</span></span><br><span class="line"><span class="function">Set&lt;MessageQueue&gt; <span class="title">fetchSubscribeMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> :获取消费者对主题分配了那些消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerConcurrently messageListener)</span>：注册并发事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerOrderly messageListener)</span>：注册顺序消息事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String subExpression)</span>：基于主题订阅消息，消息过滤使用表达式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String fullClassName,<span class="keyword">final</span> String filterClassSource)</span>：基于主题订阅消息，消息过滤使用类模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> MessageSelector selector)</span> ：订阅消息，并指定队列选择器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">final</span> String topic)</span>：取消消息订阅</span></span><br></pre></td></tr></table></figure>
<p><strong><u>DefaultMQPushConsumer</u></strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029996.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者组</span></span><br><span class="line"><span class="keyword">private</span> String consumerGroup;	</span><br><span class="line"><span class="comment">//消息消费模式</span></span><br><span class="line"><span class="keyword">private</span> MessageModel messageModel = MessageModel.CLUSTERING;	</span><br><span class="line"><span class="comment">//指定消费开始偏移量（最大偏移量、最小偏移量、启动时间戳）开始消费</span></span><br><span class="line"><span class="keyword">private</span> ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br><span class="line"><span class="comment">//集群模式下的消息队列负载策略</span></span><br><span class="line"><span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br><span class="line"><span class="comment">//订阅信息</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String <span class="comment">/* topic */</span>, String <span class="comment">/* sub expression */</span>&gt; subscription = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//消息业务监听器</span></span><br><span class="line"><span class="keyword">private</span> MessageListener messageListener;</span><br><span class="line"><span class="comment">//消息消费进度存储器</span></span><br><span class="line"><span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line"><span class="comment">//消费者最小线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMin = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//消费者最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMax = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//并发消息消费时处理队列最大跨度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeConcurrentlyMaxSpan = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//每1000次流控后打印流控日志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pullThresholdForQueue = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//推模式下任务间隔时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> pullInterval = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//推模式下任务拉取的条数,默认32条</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pullBatchSize = <span class="number">32</span>;</span><br><span class="line"><span class="comment">//每次传入MessageListener#consumerMessage中消息的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeMessageBatchMaxSize = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//是否每次拉取消息都订阅消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> postSubscriptionWhenPull = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//消息重试次数,-1代表16次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxReconsumeTimes = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//消息消费超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> consumeTimeout = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<h3 id="消费者启动流程"><a href="#消费者启动流程" class="headerlink" title="消费者启动流程"></a>消费者启动流程</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029258.png" alt></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">			<span class="comment">//检查消息者是否合法</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line">			<span class="comment">//构建主题订阅信息</span></span><br><span class="line">            <span class="keyword">this</span>.copySubscription();</span><br><span class="line">			<span class="comment">//设置消费者客户端实例名称为进程ID</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//创建MQClient实例</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line">			<span class="comment">//构建rebalanceImpl</span></span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactor</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                mQClientFactory,</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookLis</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           		<span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">               </span><br><span class="line">           	    <span class="keyword">case</span> BROADCASTING:	 <span class="comment">//消息消费广播模式,将消费进度保存在本地</span></span><br><span class="line">           	        <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">           	            <span class="keyword">break</span>;</span><br><span class="line">           	        <span class="keyword">case</span> CLUSTERING:	<span class="comment">//消息消费集群模式,将消费进度保存在远端Broker</span></span><br><span class="line">           	            <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">           	            <span class="keyword">break</span>;</span><br><span class="line">           	        <span class="keyword">default</span>:</span><br><span class="line">           	            <span class="keyword">break</span>;</span><br><span class="line">           	    &#125;</span><br><span class="line">           	    <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">           	&#125;</span><br><span class="line">            <span class="keyword">this</span>.offsetStore.load</span><br><span class="line">            <span class="comment">//创建顺序消息消费服务</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                <span class="comment">//创建并发消息消费服务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消息消费服务启动</span></span><br><span class="line">            <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line">            <span class="comment">//注册消费者实例</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//启动消费者客户端</span></span><br><span class="line">            mQClientFactory.start();</span><br><span class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h3><p>消息消费模式有两种模式：广播模式与集群模式。广播模式比较简单，每一个消费者需要拉取订阅主题下所有队列的消息。本文重点讲解集群模式。在集群模式下，同一个消费者组内有多个消息消费者，同一个主题存在多个消费队列，消费者通过负载均衡的方式消费消息。</p>
<p>消息队列负载均衡，通常的作法是一个消息队列在同一个时间只允许被一个消费消费者消费，一个消息消费者可以同时消费多个消息队列。</p>
<h4 id="1）PullMessageService实现机制"><a href="#1）PullMessageService实现机制" class="headerlink" title="1）PullMessageService实现机制"></a>1）PullMessageService实现机制</h4><p>从MQClientInstance的启动流程中可以看出，RocketMQ使用一个单独的线程PullMessageService来负责消息的拉取。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409030000550.png" alt="image-20240903000027369"></p>
<p><strong><em>代码：PullMessageService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">	<span class="comment">//循环拉取消息</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从请求队列中获取拉取消息请求</span></span><br><span class="line">            PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="comment">//拉取消息</span></span><br><span class="line">            <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Pull Message Service Run Method exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u><strong>PullRequest</strong></u></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409030000786.png" alt="image-20240903000046625"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String consumerGroup;	<span class="comment">//消费者组</span></span><br><span class="line"><span class="keyword">private</span> MessageQueue messageQueue;	<span class="comment">//待拉取消息队列</span></span><br><span class="line"><span class="keyword">private</span> ProcessQueue processQueue;	<span class="comment">//消息处理队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextOffset;	<span class="comment">//待拉取的MessageQueue偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>;	<span class="comment">//是否被锁定</span></span><br></pre></td></tr></table></figure>
<p><strong><em>代码：PullMessageService#pullMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得消费者实例</span></span><br><span class="line">    <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//强转为推送模式消费者</span></span><br><span class="line">        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        <span class="comment">//推送消息</span></span><br><span class="line">        impl.pullMessage(pullRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">"No matched consumer for the PullRequest &#123;&#125;, drop it"</span>, pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）ProcessQueue实现机制"><a href="#2）ProcessQueue实现机制" class="headerlink" title="2）ProcessQueue实现机制"></a>2）ProcessQueue实现机制</h4><p>ProcessQueue是MessageQueue在消费端的重现、快照。PullMessageService从消息服务器默认每次拉取32条消息，按照消息的队列偏移量顺序存放在ProcessQueue中，PullMessageService然后将消息提交到消费者消费线程池，消息成功消费后从ProcessQueue中移除。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029329.png" alt></p>
<p><strong><u>属性</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lockTreeMap = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//ProcessQueue总消息树</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong msgCount = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">//ProcessQueue队列最大偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> queueOffsetMax = <span class="number">0L</span>;</span><br><span class="line"><span class="comment">//当前ProcessQueue是否被丢弃</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> dropped = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//上一次拉取时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPullTimestamp = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//上一次消费时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastConsumeTimestamp = System.currentTimeMillis();</span><br></pre></td></tr></table></figure>
<p><strong><u>方法</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除消费超时消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredMsg</span><span class="params">(DefaultMQPushConsumer pushConsumer)</span></span></span><br><span class="line"><span class="function"><span class="comment">//添加消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取消息最大间隔</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxSpan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//移除消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将consumingMsgOrderlyTreeMap中消息重新放在msgTreeMap,并清空consumingMsgOrderlyTreeMap   </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//将consumingMsgOrderlyTreeMap消息清除,表示成功处理该批消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//重新处理该批消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMessageToCosumeAgain</span><span class="params">(List&lt;MessageExt&gt; msgs)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//从processQueue中取出batchSize条消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageExt&gt; <span class="title">takeMessags</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> batchSize)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3）消息拉取基本流程"><a href="#3）消息拉取基本流程" class="headerlink" title="3）消息拉取基本流程"></a>3）消息拉取基本流程</h4><h5 id="1-客户端发起拉取请求"><a href="#1-客户端发起拉取请求" class="headerlink" title="1.客户端发起拉取请求"></a>1.客户端发起拉取请求</h5><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029332.png" alt></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl#pullMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从pullRequest获得ProcessQueue</span></span><br><span class="line">    <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">    <span class="comment">//如果处理队列被丢弃,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">        log.info(<span class="string">"the pull request[&#123;&#125;] is dropped."</span>, pullRequest.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果处理队列未被丢弃,更新时间戳</span></span><br><span class="line">    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        log.warn(<span class="string">"pullMessage exception, consumer state not ok"</span>, e);</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果处理队列被挂起,延迟1s后再执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPause()) &#123;</span><br><span class="line">        log.warn(<span class="string">"consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获得最大待处理消息数量</span></span><br><span class="line">	<span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">    <span class="comment">//获得最大待处理消息大小</span></span><br><span class="line">	<span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">	<span class="comment">//从数量进行流控</span></span><br><span class="line">	<span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">	    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">	    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">	        log.warn(</span><br><span class="line">	            <span class="string">"the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</span><br><span class="line">	            <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从消息大小进行流控</span></span><br><span class="line">	<span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">	    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">	    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">	        log.warn(</span><br><span class="line">	            <span class="string">"the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</span><br><span class="line">	            <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">//获得订阅信息</span></span><br><span class="line">		 <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">    	    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">    	    log.warn(<span class="string">"find the consumer's subscription failed, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">    	    <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//与服务端交互,获取消息</span></span><br><span class="line">	    <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">	    pullRequest.getMessageQueue(),</span><br><span class="line">	    subExpression,</span><br><span class="line">	    subscriptionData.getExpressionType(),</span><br><span class="line">	    subscriptionData.getSubVersion(),</span><br><span class="line">	    pullRequest.getNextOffset(),</span><br><span class="line">	    <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">	    sysFlag,</span><br><span class="line">	    commitOffsetValue,</span><br><span class="line">	    BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">	    CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">	    CommunicationMode.ASYNC,</span><br><span class="line">	    pullCallback</span><br><span class="line">	);</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-消息服务端Broker组装消息"><a href="#2-消息服务端Broker组装消息" class="headerlink" title="2.消息服务端Broker组装消息"></a>2.消息服务端Broker组装消息</h5><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029387.png" alt></p>
<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息过滤器</span></span><br><span class="line">MessageFilter messageFilter;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">    messageFilter = <span class="keyword">new</span> ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    messageFilter = <span class="keyword">new</span> ExpressionMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用MessageStore.getMessage查找消息</span></span><br><span class="line"><span class="keyword">final</span> GetMessageResult getMessageResult =</span><br><span class="line">    <span class="keyword">this</span>.brokerController.getMessageStore().getMessage(</span><br><span class="line">    				requestHeader.getConsumerGroup(), <span class="comment">//消费组名称								</span></span><br><span class="line">    				requestHeader.getTopic(),	<span class="comment">//主题名称</span></span><br><span class="line">        			requestHeader.getQueueId(), <span class="comment">//队列ID</span></span><br><span class="line">    				requestHeader.getQueueOffset(), 	<span class="comment">//待拉取偏移量</span></span><br><span class="line">    				requestHeader.getMaxMsgNums(), 	<span class="comment">//最大拉取消息条数</span></span><br><span class="line">    				messageFilter	<span class="comment">//消息过滤器</span></span><br><span class="line">    		);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#getMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line"><span class="keyword">long</span> nextBeginOffset = offset;	<span class="comment">//查找下一次队列偏移量</span></span><br><span class="line"><span class="keyword">long</span> minOffset = <span class="number">0</span>;		<span class="comment">//当前消息队列最小偏移量</span></span><br><span class="line"><span class="keyword">long</span> maxOffset = <span class="number">0</span>;		<span class="comment">//当前消息队列最大偏移量</span></span><br><span class="line">GetMessageResult getResult = <span class="keyword">new</span> GetMessageResult();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> maxOffsetPy = <span class="keyword">this</span>.commitLog.getMaxOffset();	<span class="comment">//当前commitLog最大偏移量</span></span><br><span class="line"><span class="comment">//根据主题名称和队列编号获取消息消费队列</span></span><br><span class="line">ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">minOffset = consumeQueue.getMinOffsetInQueue();</span><br><span class="line">maxOffset = consumeQueue.getMaxOffsetInQueue();</span><br><span class="line"><span class="comment">//消息偏移量异常情况校对下一次拉取偏移量</span></span><br><span class="line"><span class="keyword">if</span> (maxOffset == <span class="number">0</span>) &#123;	<span class="comment">//表示当前消息队列中没有消息</span></span><br><span class="line">    status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; minOffset) &#123;	<span class="comment">//待拉取消息的偏移量小于队列的其实偏移量</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_TOO_SMALL;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == maxOffset) &#123;	<span class="comment">//待拉取偏移量为队列最大偏移量</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, offset);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; maxOffset) &#123;	<span class="comment">//偏移量越界</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == minOffset) &#123;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//根据偏移量从CommitLog中拉取32条消息</span></span><br><span class="line">SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据拉取结果填充responseHeader</span></span><br><span class="line">response.setRemark(getMessageResult.getStatus().name());</span><br><span class="line">responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</span><br><span class="line">responseHeader.setMinOffset(getMessageResult.getMinOffset());</span><br><span class="line">responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断如果存在主从同步慢,设置下一次拉取任务的ID为主节点</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">    <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SLAVE:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//GetMessageResult与Response的Code转换</span></span><br><span class="line"><span class="keyword">switch</span> (getMessageResult.getStatus()) &#123;</span><br><span class="line">    <span class="keyword">case</span> FOUND:			<span class="comment">//成功</span></span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MESSAGE_WAS_REMOVING:	<span class="comment">//消息存放在下一个commitLog中</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);	<span class="comment">//消息重试</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NO_MATCHED_LOGIC_QUEUE:	<span class="comment">//未找到队列</span></span><br><span class="line">    <span class="keyword">case</span> NO_MESSAGE_IN_QUEUE:	<span class="comment">//队列中未包含消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != requestHeader.getQueueOffset()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">            requestHeader.getQueueOffset(),</span><br><span class="line">            getMessageResult.getNextBeginOffset(),</span><br><span class="line">            requestHeader.getTopic(),</span><br><span class="line">            requestHeader.getQueueId(),</span><br><span class="line">            requestHeader.getConsumerGroup()</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NO_MATCHED_MESSAGE:	<span class="comment">//未找到消息</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_FOUND_NULL:	<span class="comment">//消息物理偏移量为空</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_OVERFLOW_BADLY:	<span class="comment">//offset越界</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">        <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">        log.info(<span class="string">"the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;"</span>,</span><br><span class="line">                requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_OVERFLOW_ONE:	<span class="comment">//offset在队列中未找到</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_TOO_SMALL:	<span class="comment">//offset未在队列中</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">        requestHeader.getConsumerGroup(), </span><br><span class="line">        requestHeader.getTopic(), </span><br><span class="line">        requestHeader.getQueueOffset(),</span><br><span class="line">        getMessageResult.getMinOffset(), channel.remoteAddress());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果CommitLog标记可用,并且当前Broker为主节点,则更新消息消费进度</span></span><br><span class="line"><span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;</span><br><span class="line">storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</span><br><span class="line">storeOffsetEnable = storeOffsetEnable</span><br><span class="line">    &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</span><br><span class="line"><span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">    <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">        requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-消息拉取客户端处理消息"><a href="#3-消息拉取客户端处理消息" class="headerlink" title="3.消息拉取客户端处理消息"></a>3.消息拉取客户端处理消息</h5><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409030002706.png" alt="image-20240903000211528"></p>
<p><strong><em>代码：MQClientAPIImpl#processPullResponse</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PullResult <span class="title">processPullResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> RemotingCommand response)</span> <span class="keyword">throws</span> MQBrokerException, RemotingCommandException </span>&#123;</span><br><span class="line">    PullStatus pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">   	<span class="comment">//判断响应结果</span></span><br><span class="line">    <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">            pullStatus = PullStatus.FOUND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">            pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">            pullStatus = PullStatus.NO_MATCHED_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">            pullStatus = PullStatus.OFFSET_ILLEGAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQBrokerException(response.getCode(), response.getRemark());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解码响应头</span></span><br><span class="line">    PullMessageResponseHeader responseHeader =</span><br><span class="line">        (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);</span><br><span class="line">	<span class="comment">//封装PullResultExt返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),</span><br><span class="line">        responseHeader.getMaxOffset(), <span class="keyword">null</span>, responseHeader.getSuggestWhichBrokerId(), response.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u><strong>PullResult类</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullStatus pullStatus;	<span class="comment">//拉取结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> nextBeginOffset;	<span class="comment">//下次拉取偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> minOffset;	<span class="comment">//消息队列最小偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxOffset;	<span class="comment">//消息队列最大偏移量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MessageExt&gt; msgFoundList;	<span class="comment">//拉取的消息列表</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409030002173.png" alt></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl$PullCallback#OnSuccess</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将拉取到的消息存入processQueue</span></span><br><span class="line"><span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line"><span class="comment">//将processQueue提交到consumeMessageService中供消费者消费</span></span><br><span class="line">DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">    pullResult.getMsgFoundList(),</span><br><span class="line">    processQueue,</span><br><span class="line">    pullRequest.getMessageQueue(),</span><br><span class="line">    dispatchToConsume);</span><br><span class="line"><span class="comment">//如果pullInterval大于0,则等待pullInterval毫秒后将pullRequest对象放入到PullMessageService中的pullRequestQueue队列中</span></span><br><span class="line"><span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-消息拉取总结"><a href="#4-消息拉取总结" class="headerlink" title="4.消息拉取总结"></a>4.消息拉取总结</h5><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029815.png" alt></p>
<h4 id="4）消息拉取长轮询机制分析"><a href="#4）消息拉取长轮询机制分析" class="headerlink" title="4）消息拉取长轮询机制分析"></a>4）消息拉取长轮询机制分析</h4><p>RocketMQ未真正实现消息推模式，而是消费者主动向消息服务器拉取消息，RocketMQ推模式是循环向消息服务端发起消息拉取请求，如果消息消费者向RocketMQ拉取消息时，消息未到达消费队列时，如果不启用长轮询机制，则会在服务端等待shortPollingTimeMills时间后（挂起）再去判断消息是否已经到达指定消息队列，如果消息仍未到达则提示拉取消息客户端PULL—NOT—FOUND（消息不存在）；如果开启长轮询模式，RocketMQ一方面会每隔5s轮询检查一次消息是否可达，同时一有消息达到后立马通知挂起线程再次验证消息是否是自己感兴趣的消息，如果是则从CommitLog文件中提取消息返回给消息拉取客户端，否则直到挂起超时，超时时间由消息拉取方在消息拉取是封装在请求参数中，PUSH模式为15s，PULL模式通过DefaultMQPullConsumer#setBrokerSuspendMaxTimeMillis设置。RocketMQ通过在Broker客户端配置longPollingEnable为true来开启长轮询模式。</p>
<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当没有拉取到消息时，通过长轮询方式继续拉取消息</span></span><br><span class="line"><span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">    <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">        <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">            pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String topic = requestHeader.getTopic();</span><br><span class="line">        <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">        <span class="keyword">int</span> queueId = requestHeader.getQueueId();</span><br><span class="line">        <span class="comment">//构建拉取请求对象</span></span><br><span class="line">        PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">        <span class="comment">//处理拉取请求</span></span><br><span class="line">        <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">        response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><u>PullRequestHoldService方式实现长轮询</u></strong></p>
<p><strong><em>代码：PullRequestHoldService#suspendPullRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将拉取消息请求，放置在ManyPullRequest集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspendPullRequest</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">    ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mpr) &#123;</span><br><span class="line">        mpr = <span class="keyword">new</span> ManyPullRequest();</span><br><span class="line">        ManyPullRequest prev = <span class="keyword">this</span>.pullRequestTable.putIfAbsent(key, mpr);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mpr = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpr.addPullRequest(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：PullRequestHoldService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"&#123;&#125; service started"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果开启长轮询每隔5秒判断消息是否到达</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有开启长轮询,每隔1s再次尝试</span></span><br><span class="line">              <span class="keyword">this</span>.waitForRunning(<span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</span><br><span class="line">            <span class="keyword">this</span>.checkHoldRequest();</span><br><span class="line">            <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span>, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"&#123;&#125; service end"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：PullRequestHoldService#checkHoldRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历拉取任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkHoldRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String key : <span class="keyword">this</span>.pullRequestTable.keySet()) &#123;</span><br><span class="line">        String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == kArray.length) &#123;</span><br><span class="line">            String topic = kArray[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> queueId = Integer.parseInt(kArray[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//获得消息偏移量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通知有消息达到</span></span><br><span class="line">                <span class="keyword">this</span>.notifyMessageArriving(topic, queueId, offset);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;"</span>, topic, queueId, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：PullRequestHoldService#notifyMessageArriving</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果拉取消息偏移大于请求偏移量,如果消息匹配调用executeRequestWhenWakeup处理消息</span></span><br><span class="line"><span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">        <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">    <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">    <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                request.getRequestCommand());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果过期时间超时,则不继续等待将直接返回给客户端消息未找到</span></span><br><span class="line"><span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">            request.getRequestCommand());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了长轮询机制，PullRequestHoldService会每隔5s被唤醒去尝试检测是否有新的消息的到来才给客户端响应，或者直到超时才给客户端进行响应，消息实时性比较差，为了避免这种情况，RocketMQ引入另外一种机制：当消息到达时唤醒挂起线程触发一次检查。</p>
<p><strong><u>DefaultMessageStore$ReputMessageService机制</u></strong></p>
<p><strong><em>代码：DefaultMessageStore#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长轮询入口</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore$ReputMessageService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//长轮询核心逻辑代码入口</span></span><br><span class="line">            <span class="keyword">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore$ReputMessageService#deReput</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当新消息达到是,进行通知监听器进行处理</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">    &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">    DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：NotifyMessageArrivingListener#arriving</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arriving</span><span class="params">(String topic, <span class="keyword">int</span> queueId, <span class="keyword">long</span> logicOffset, <span class="keyword">long</span> tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pullRequestHoldService.notifyMessageArriving(topic, queueId, logicOffset, tagsCode,</span><br><span class="line">        msgStoreTime, filterBitMap, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息队列负载与重新分布机制"><a href="#消息队列负载与重新分布机制" class="headerlink" title="消息队列负载与重新分布机制"></a>消息队列负载与重新分布机制</h3><p>RocketMQ消息队列重新分配是由RebalanceService线程来实现。一个MQClientInstance持有一个RebalanceService实现，并随着MQClientInstance的启动而启动。</p>
<p><strong><em>代码：RebalanceService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">	<span class="comment">//RebalanceService线程默认每隔20s执行一次mqClientFactory.doRebalance方法</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">        <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#doRebalance</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//MQClientInstance遍历以注册的消费者,对消费者执行doRebalance()方法</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">        MQConsumerInner impl = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                impl.doRebalance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"doRebalance exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：RebalanceImpl#doRebalance</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历订阅消息对每个主题的订阅的队列进行重新负载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="keyword">this</span>.getSubscriptionInner();</span><br><span class="line">    <span class="keyword">if</span> (subTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"rebalanceByTopic Exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：RebalanceImpl#rebalanceByTopic</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从主题订阅消息缓存表中获取主题的队列信息</span></span><br><span class="line">Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line"><span class="comment">//查找该主题订阅组所有的消费者ID</span></span><br><span class="line">List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给消费者重新分配队列</span></span><br><span class="line"><span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">    mqAll.addAll(mqSet);</span><br><span class="line"></span><br><span class="line">    Collections.sort(mqAll);</span><br><span class="line">    Collections.sort(cidAll);</span><br><span class="line"></span><br><span class="line">    AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">    List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        allocateResult = strategy.allocate(</span><br><span class="line">            <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">            mqAll,</span><br><span class="line">            cidAll);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</span><br><span class="line">            e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>RocketMQ默认提供5中负载均衡分配算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AllocateMessageQueueAveragely:平均分配</span><br><span class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</span><br><span class="line">分配如下:</span><br><span class="line">c1:q1,q2,q3</span><br><span class="line">c2:q4,q5,a6</span><br><span class="line">c3:q7,q8</span><br><span class="line">AllocateMessageQueueAveragelyByCircle:平均轮询分配</span><br><span class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</span><br><span class="line">分配如下:</span><br><span class="line">c1:q1,q4,q7</span><br><span class="line">c2:q2,q5,a8</span><br><span class="line">c3:q3,q6</span><br></pre></td></tr></table></figure>
<p>注意：消息队列的分配遵循一个消费者可以分配到多个队列，但同一个消息队列只会分配给一个消费者，故如果出现消费者个数大于消息队列数量，则有些消费者无法消费消息。</p>
<h3 id="消息消费过程"><a href="#消息消费过程" class="headerlink" title="消息消费过程"></a>消息消费过程</h3><p>PullMessageService负责对消息队列进行消息拉取，从远端服务器拉取消息后将消息存储ProcessQueue消息队列处理队列中，然后调用ConsumeMessageService#submitConsumeRequest方法进行消息消费，使用线程池来消费消息，确保了消息拉取与消息消费的解耦。ConsumeMessageService支持顺序消息和并发消息，核心类图如下：</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409022029494.png" alt></p>
<p><strong><u>并发消息消费</u></strong></p>
<p><strong><em>代码：ConsumeMessageConcurrentlyService#submitConsumeRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息批次单次</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line"><span class="comment">//msgs.size()默认最多为32条。</span></span><br><span class="line"><span class="comment">//如果msgs.size()小于consumeBatchSize,则直接将拉取到的消息放入到consumeRequest,然后将consumeRequest提交到消费者线程池中</span></span><br><span class="line"><span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">    ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;	<span class="comment">//如果拉取的消息条数大于consumeBatchSize,则对拉取消息进行分页</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">   		    List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">   		    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">   		        <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">   		            msgThis.add(msgs.get(total));</span><br><span class="line">   		        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		            <span class="keyword">break</span>;</span><br><span class="line">   		        &#125;</span><br><span class="line">   		</span><br><span class="line">   		    ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">   		    <span class="keyword">try</span> &#123;</span><br><span class="line">   		        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">   		    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">   		        <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">   		            msgThis.add(msgs.get(total));</span><br><span class="line">   		 </span><br><span class="line">   		        <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">   		    &#125;</span><br><span class="line">   		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：ConsumeMessageConcurrentlyService$ConsumeRequest#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查processQueue的dropped,如果为true,则停止该队列消费。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.info(<span class="string">"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;"</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//执行消息处理的钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">    consumeMessageContext.setMq(messageQueue);</span><br><span class="line">    consumeMessageContext.setMsgList(msgs);</span><br><span class="line">    consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//调用应用程序消息监听器的consumeMessage方法,进入到具体的消息消费业务处理逻辑</span></span><br><span class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行消息处理后的钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext.setStatus(status.toString());</span><br><span class="line">    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时消息机制"><a href="#定时消息机制" class="headerlink" title="定时消息机制"></a>定时消息机制</h3><p>定时消息是消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，如果要支持任意时间精度定时调度，不可避免地需要在Broker层做消息排序，再加上持久化方面的考量，将不可避免的带来巨大的性能消耗，所以RocketMQ只支持特定级别的延迟消息。消息延迟级别在Broker端通过messageDelayLevel配置，默认为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，delayLevel=1表示延迟消息1s,delayLevel=2表示延迟5s,依次类推。</p>
<p>RocketMQ定时消息实现类为ScheduleMessageService，该类在DefaultMessageStore中创建。通过在DefaultMessageStore中调用load方法加载该类并调用start方法启动。</p>
<p><strong><em>代码：ScheduleMessageService#load</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载延迟消息消费进度的加载与delayLevelTable的构造。延迟消息的进度默认存储路径为/store/config/delayOffset.json</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.parseDelayLevel();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：ScheduleMessageService#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历延迟队列创建定时任务,遍历延迟级别，根据延迟级别level从offsetTable中获取消费队列的消费进度。如果不存在，则使用0</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">    Integer level = entry.getKey();</span><br><span class="line">    Long timeDelay = entry.getValue();</span><br><span class="line">    Long offset = <span class="keyword">this</span>.offsetTable.get(level);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">        offset = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每隔10s持久化一次延迟队列的消息消费进度</span></span><br><span class="line"><span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (started.get()) ScheduleMessageService.<span class="keyword">this</span>.persist();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"scheduleAtFixedRate flush exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br></pre></td></tr></table></figure>
<p><strong><u>调度机制</u></strong></p>
<p>ScheduleMessageService的start方法启动后，会为每一个延迟级别创建一个调度任务，每一个延迟级别对应SCHEDULE_TOPIC_XXXX主题下的一个消息消费队列。定时调度任务的实现类为DeliverDelayedMessageTimerTask，核心实现方法为executeOnTimeup</p>
<p><strong><em>代码：ScheduleMessageService$DeliverDelayedMessageTimerTask#executeOnTimeup</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据队列ID与延迟主题查找消息消费队列</span></span><br><span class="line">ConsumeQueue cq =</span><br><span class="line">    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</span><br><span class="line">        delayLevel2QueueId(delayLevel));</span><br><span class="line">...</span><br><span class="line"><span class="comment">//根据偏移量从消息消费队列中获取当前队列中所有有效的消息</span></span><br><span class="line">SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//遍历ConsumeQueue,解析消息队列中消息</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">    <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">    <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">    <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">            tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//can't find ext content.So re compute tags code.</span></span><br><span class="line">            log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;"</span>,</span><br><span class="line">                tagsCode, offsetPy, sizePy);</span><br><span class="line">            <span class="keyword">long</span> msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</span><br><span class="line">            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//根据消息偏移量与消息大小,从CommitLog中查找消息.</span></span><br><span class="line">  	MessageExt msgExt =</span><br><span class="line">   ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">       offsetPy, sizePy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序消息-1"><a href="#顺序消息-1" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>顺序消息实现类是org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService</p>
<p><strong><em>代码：ConsumeMessageOrderlyService#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果消息模式为集群模式，启动定时任务，默认每隔20s执行一次锁定分配给自己的消息消费队列</span></span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ConsumeMessageOrderlyService.<span class="keyword">this</span>.lockMQPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：ConsumeMessageOrderlyService#submitConsumeRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息任务,并提交消费线程池中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> dispathToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(processQueue, messageQueue);</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>代码：ConsumeMessageOrderlyService$ConsumeRequest#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果消息队列为丢弃,则停止本次消费任务</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.warn(<span class="string">"run, the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从消息队列中获取一个对象。然后消费消息时先申请独占objLock锁。顺序消息一个消息消费队列同一时刻只会被一个消费线程池处理</span></span><br><span class="line"><span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line"><span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>RocketMQ消息消费方式分别为集群模式、广播模式。</p>
<p>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载，根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一个时间只会分配给一个消费者。</p>
<p>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认每次拉取32条消息，提交给消费者消费线程后继续下一次消息拉取。如果消息消费过慢产生消息堆积会触发消息消费拉取流控。 </p>
<p>并发消息消费指消费线程池中的线程可以并发对同一个消息队列的消息进行消费，消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中，集群模式消息消费进度存储在Broker（消息服务器），广播模式消息消费进度存储在消费者端。</p>
<p>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，例如1s、2s、5s等，可通过在broker配置文件中设置messageDelayLevel。</p>
<p>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费。并并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况。</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式知识梳理]]></title>
      <url>/p/8vugk/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>软件设计原则</p>
<p>开闭   <strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
<p>想要达到这样的效果，我们需要使用接口和抽象类</p>
<p>依赖倒置。对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合</p>
<p>迪米特  最少知道原则。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性</p>
<p>里氏替换 任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法</p>
<p>接口隔离   客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上</p>
<p>合成复用</p>
<p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<p>通常类的复用分为继承复用和合成复用两种。</p>
<p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p>
<ol>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>对象间的耦合度低。可以在类的成员位置声明抽象。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象</li>
</ol>
<p>单一职责原则 ： 不要存在多于一个导致类变更的原因，简单来说， 一个类只负责唯一<br>项职责</p>
<p>创建</p>
<p>创建型模式(Creational Pattern)关注的是对象的创建，将创建对象(类的实例化)的过程进行了抽象和封装，分离了对象创建和对象使用。作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。帮助一个系统独立于如何创建、组合和表示它的那些对象。</p>
<p>n创建型模式有两个重要的特点：</p>
<p> 1） 客户不知道对象的具体类是什么（除非看源代码）</p>
<p> 2） 隐藏了对象实例是如何被创建和组织的</p>
<p>当想要使用new运算符的时候，就可以考虑创建型模式</p>
<p>结构</p>
<p>简单工厂</p>
<p>简单工厂模式(Simple Factory Pattern)：又称为<strong>静态工厂方法**</strong>(Static Factory Method)<strong>**模式</strong>。在简单工厂模式中，可以<strong>根据参数的不同返回不同类的实例</strong>。简单工厂模式<strong>专门定义一个类来负责创建其他类的实例</strong>，**被创建的实例通常都具有共同的父类。 </p>
<p>和配置文件结合使用</p>
<p>在以下情况下可以使用简单工厂模式</p>
<p><strong>工厂类负责创建的对象比较少</strong>：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</p>
<p> <strong>客户端只知道传入工厂类的参数，对于如何创建对象不关心</strong>：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数</p>
<p>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TV</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>如果需要增加一种新类型的按钮，如椭圆形按钮，那么<strong>除了增加一个新的具体产品类之外，还需要修改工厂类的代码，这就使得整个设计在一定程度上违反了“开闭原则”</strong></p>
<p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类</p>
<p><strong>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。</strong>这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得<strong>工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品</strong></p>
<p>电视机工厂</p>
<p>日志记录器</p>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h2 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h2><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>使用原型模式来复制一个对象的自身，从而<strong>克隆出多个与原型对象一模一样的对象</strong></p>
<p>原型模式的基本工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝原型自己来实现创建过程</p>
<p>在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单</p>
<p>能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常</p>
<p>通常情况下，一个类包含一些成员对象，在使用原型模式克隆对象时，<strong>根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆和浅克隆</strong></p>
<p>浅克隆复制对象的字段值：对于基本数据类型，则复制值；对于复合数据类型，仅复制该字段值，如数组变量则复制地址，对于对象变量则复制对象的reference</p>
<p>深克隆与浅克隆的区别在于对复合数据类型的复制。若对象中的某个字段为复合类型，在克隆对象的时候，需要为该字段重新创建一个对象</p>
<p>当创建新的对象实例较为复杂时，使用原型模式可以<strong>简化对象的创建过程</strong>，通过一个已有实例可以<strong>提高新实例的创建效率</strong></p>
<p>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响</p>
<p>原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品</p>
<p>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作</p>
<p><strong>创建新对象成本较大</strong>，如创建对象的构造函数非常的复杂，在执行这个构造函数时会消耗较多的CPU或内存资源，同时，这个构造函数中的一些信息又没有什么变化，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其属性稍作修改</p>
<p>如果<strong>系统要保存对象的状态</strong>，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好</p>
<p>原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便扩展</p>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p><strong>让类自身负责保存它的唯一实例</strong>。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机</p>
<p>单例模式(Singleton Pattern)：单例模式<strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例</strong>，这个类称为单例类，它提供全局访问的方法</p>
<p>单例模式有三个要点：一是<strong>某个类只能有一个实例</strong>；二是<strong>它必须自行创建这个实例</strong>；三是<strong>它必须自行向整个系统提供这个实例</strong>。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式</p>
<p>懒汉考虑多线程</p>
<p>结构</p>
<p>结构型模式(Structural Pattern)描述<strong>如何将类或者对象结合在一起形成更大的结构</strong></p>
<p>结构型模式可以分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>：</p>
<p>•类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。</p>
<p>对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式</p>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>通常情况下，<strong>客户端可以通过目标类的接口访问它所提供的服务</strong>。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的</p>
<p>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是<strong>适配器</strong>(Adapter)<strong>，它所包装的对象就是</strong>适配者，即被适配的类</p>
<p>适配器模式既可以作为类结构型模式，也可以作为对象结构型模式</p>
<p>典型的类适配器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		specificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的对象适配器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		adaptee.specificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>两个独立变化维度 抽象和实现分离。很多设计模式内部就有这种模式的影子</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>树形结构在软件中随处可见，例如操作系统中的目录结构、应用软件中的菜单、办公系统中的公司组织结构等等，如何运用面向对象的方式来处理这种树形结构是组合模式需要解决的问题</p>
<p>对于树形结构，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行。（递归调用）</p>
<p>由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下我们希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。</p>
<p>组合模式就是为解决此类问题而诞生，它通过一种巧妙的设计方案使得客户端可以一致性地处理整个树形结构或者树形结构的一部分，也可以一致性地处理树形结构中的叶子节点（不包含子节点的节点）和容器节点（包含子节点的节点）</p>
<p>组合模式(Composite Pattern)：组合多个对象形成树形结构以表示“整体-部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>在软件设计中，一般有两种方式可以实现给一个类或对象增加行为（新功能）：</p>
<p>•继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</p>
<p>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)。</p>
<p>•继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</p>
<p>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)。</p>
<p>Java IO</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式是迪米特原则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度</p>
<p>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系</p>
<p>在享元模式中可以共享的相同内容称为内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的</p>
<p>在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能</p>
<p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p>
<p>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。 </p>
<p>(1) 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。</p>
<p>(2) 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。 </p>
<p>在以下情况下可以使用享元模式</p>
<p>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费</p>
<p>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式</p>
<p>享元模式与其他模式的联用 </p>
<p>•在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。</p>
<p>•在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。</p>
<p>•享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。</p>
<p>远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)</p>
<p>远程代理是一种常用代理模式，它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求</p>
<p>远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用</p>
<p>行为</p>
<p>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化</p>
<p>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用</p>
<p>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行</p>
<p>行为型模式分为类行为型模式和对象行为型模式两种：</p>
<p>•类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。</p>
<p>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式</p>
<h2 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h2><p>职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求</p>
<p>链上的每一个对象都是请求的处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦。这就是职责链模式的模式动机</p>
<p>发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任</p>
<p>职责链模式分为纯的职责链模式和不纯的职责链模式两种</p>
<p>一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的职责链模式</p>
<p>在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</p>
<p>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</p>
<p><strong>命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联</strong></p>
<p>宏命令又称为组合命令，它是命令模式和组合模式联用的产物。</p>
<p>宏命令是一个具体命令类，它拥有一个集合属性，在该集合中包含了对其他命令对象的引用。通常宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法。当调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员可以是简单命令，还可以继续是宏命令。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理</p>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>解释器模式(Interpreter Pattern) ：定义语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”意思是使用规定格式和语法的代码，它是一种类行为型模式</p>
<p>抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符和非终结符类。</p>
<p>在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一个语法规则，使得系统具有较好的扩展性和灵活性</p>
<p>可以使用解释器模式，通过C++、Java、C#等面向对象语言开发简单的编译器，如数学表达式解析器、正则表达式解析器等，用于增强这些语言的功能，使之增加一些新的文法规则，用于解释一些特定类型的语句</p>
<p>解释器模式的缺点</p>
<p>•对于复杂文法难以维护。</p>
<p>•执行效率较低。</p>
<p>•应用场景很有限。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>n在软件开发中，也存在大量类似电视机一样的类，它们可以存储多个成员对象（元素），这些类通常称为聚合类(Aggregate Classes)，对应的对象称为聚合对象。</p>
<p>聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的</p>
<p>因此，我们比照电视机遥控器的功能角色，将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责原则”的要求。</p>
<p>n同时还可以灵活地为聚合对象增加不同的遍历方法，还可以访问一个聚合对象中的元素但又不需要暴露它的内部结构。</p>
<p>迭代器模式(Iterator Pattern) ：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</p>
<p>在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了工厂方法模式</p>
<p>聚合对象 迭代器工厂角色</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408141500993.png" alt="image-20240814150045145"></p>
<h2 id="中介者"><a href="#中介者" class="headerlink" title="中介者"></a>中介者</h2><p>qq群。聊天室</p>
<p>中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</p>
<p>中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”</p>
<h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><p>备忘录模式是一种给我们的软件提供后悔药的机制，通过它可以使系统恢复到某一特定的历史状态</p>
<p>理解备忘录模式并不难，但关键在于如何设计备忘录类和负责人类。由于在备忘录中存储的是原发器的中间状态，因此需要防止原发器以外的其他对象访问备忘录，特别是不允许其他对象来修改备忘录</p>
<p>使用备忘录模式时首先应该存在一个原发器类Originator，在真实业务中，原发器类是一个具体的业务类，它包含一些用于存储成员数据的属性</p>
<p>负责人类存储备忘录集合</p>
<p>备忘录模式和原型模式</p>
<p>这两个模式可以组合使用。</p>
<p>在原发器对象创建备忘录对象的时候，如果原发器对象中全部或者大部分的状态都需要保存，一个简洁的方式就是直接克隆一个原发器对象。也就是说，这个时候备忘录对象里面存放的是一个原发器对象的实例</p>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>在软件系统中，有些对象也像水一样具有多种状态，这些状态在某些情况下能够相互转换，而且对象在不同的状态下也将具有不同的行为。为了更好地对这些具有多种状态的对象进行设计，我们将学习用于描述对象状态及其转换的状态模式</p>
<p>n状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</p>
<p>状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。<strong>状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中</strong>，<strong>使得对象状态可以灵活变化</strong>，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>在软件系统中，要实现如查找/排序的功能，有许多算法可以实现。一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源程序；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难</p>
<p>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体算法，在这里，每一个封装算法的类都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</p>
<p>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，一定程度上增加了客户端的使用难度</p>
<p>策略模式与状态模式的比较</p>
<p>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式</p>
<p>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</p>
<p>策略模式中，具体策略类无须关心环境类；而状态模式中具体状态往往需要维护一个环境类的引用，以便通过该引用实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</p>
<p>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构</p>
<p>模版方法</p>
<p>n模板方法模式(Template Method Pattern)：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。</p>
<p>模板方法模式是一种基于继承的代码复用技术，它是一种<strong>类行为型模式</strong></p>
<p>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</p>
<p>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则</p>
<p>模板方法模式和策略模式</p>
<p>从表面上看，两个模式都能实现算法的封装，但是模板方法封装的是算法的骨架，这个算法骨架是不变的，变化的是算法中某些步骤的具体实现；而策略模式是把某个步骤的具体实现算法封装起来，所有封装的算法对象是等价的，可以相互替换。</p>
<p>可以在模板方法中使用策略模式，就是把那些变化的算法步骤通过使用策略模式来实现。</p>
<p>也可以在策略模式中使用模板方法</p>
<h2 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h2><p>对于系统中的某些对象，它们存储在同一个集合中，且具有不同的类型，而且对于该集合中的对象，可以接受一类称为访问者的对象来访问，而且不同的访问者其访问方式有所不同，访问者模式为解决这类问题而诞生</p>
<p>访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式，这就是访问者模式的模式动机</p>
<p>访问者模式的主要目的是抽象处理某种数据结构中各元素的操作，可以在不改变数据结构<br>的前提下，添加处理数据结构中指定元素的新操作</p>
<p>Asm</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java并发编程基本概念]]></title>
      <url>/p/8vugj/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h1><p>CPU（中央处理器）的结构是计算机系统的核心部分，负责执行各种指令和处理数据。现代CPU结构通常由多个复杂的子系统组成，这些子系统共同协作以实现高效的计算。以下是CPU结构的主要组成部分及其功能：</p>
<h3 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h3><p>ALU，Arithmetic Logic Unit</p>
<ul>
<li><strong>功能</strong>：ALU 是CPU中执行算术和逻辑运算的核心部分。它负责处理整数加法、减法、乘法、除法以及逻辑运算（如与、或、非、异或等）。</li>
<li><strong>作用</strong>：执行基本的计算任务，比如加法、减法、乘法等，是处理器执行程序的基础。</li>
</ul>
<h3 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h3><p>CU，Control Unit</p>
<ul>
<li><strong>功能</strong>：控制单元负责指挥CPU的操作，协调各个部分的工作。它通过从内存中读取指令，并根据指令控制其他组件执行相应的操作。</li>
<li><strong>作用</strong>：解码指令，控制数据流动和指令执行的顺序，协调CPU内部各部分的工作。</li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>Registers</p>
<ul>
<li><strong>功能</strong>：寄存器是CPU内部用于临时存储数据和指令的高速存储器。寄存器的存取速度极快，通常用来保存正在处理的数据或指令的地址。</li>
<li><strong>作用</strong>：存储CPU当前操作的数据、指令或其他临时信息，提高处理效率。</li>
<li>常见寄存器：<ul>
<li><strong>通用寄存器</strong>：用于存储一般性数据，例如累加器（Accumulator）。</li>
<li><strong>专用寄存器</strong>：用于特定目的，如程序计数器（PC）存储当前指令的地址，堆栈指针（SP）管理堆栈内存。</li>
</ul>
</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Cache</p>
<ul>
<li><strong>功能</strong>：缓存是位于CPU与主内存之间的小容量但高速的存储器，用于存储频繁访问的数据和指令。</li>
<li><strong>作用</strong>：减少CPU访问主内存的时间，提升整体处理速度。</li>
<li>层次：<ul>
<li><strong>L1缓存</strong>：最接近CPU核心，速度最快，容量最小。</li>
<li><strong>L2缓存</strong>：速度稍慢于L1，容量较大。</li>
<li><strong>L3缓存</strong>：速度最慢但容量最大，用于多个核心共享。</li>
</ul>
</li>
</ul>
<h3 id="总线接口单元"><a href="#总线接口单元" class="headerlink" title="总线接口单元"></a>总线接口单元</h3><p>BIU，Bus Interface Unit</p>
<ul>
<li><strong>功能</strong>：BIU负责在CPU和其他系统组件（如内存、I/O设备）之间传输数据。它管理CPU与外部设备之间的通信，确保数据能够顺利进出处理器。</li>
<li><strong>作用</strong>：连接CPU与外部设备，传递指令和数据。</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li><strong>功能</strong>：前端是处理器获取和解码指令的部分。它负责从内存中获取指令，并将其解码成可执行的微操作。</li>
<li>组成部分：<ul>
<li><strong>指令提取单元</strong>：从内存或缓存中获取指令。</li>
<li><strong>指令解码单元</strong>：将指令翻译成CPU可以执行的微指令。</li>
<li><strong>分支预测单元</strong>：预测程序执行中可能的分支路径，以减少处理器等待时间。</li>
</ul>
</li>
</ul>
<h3 id="执行单元"><a href="#执行单元" class="headerlink" title="执行单元"></a>执行单元</h3><ul>
<li><strong>功能</strong>：执行单元负责执行已经解码的指令。它包括ALU、浮点单元（FPU）、加载/存储单元等。</li>
<li><strong>作用</strong>：完成算术运算、逻辑运算、浮点运算，以及内存访问等操作。</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul>
<li><strong>功能</strong>：后端负责指令的最终执行和结果的写回。它包括寄存器重命名、指令调度等部分。</li>
<li>组成部分：<ul>
<li><strong>寄存器重命名</strong>：消除数据依赖冲突，提高指令执行效率。</li>
<li><strong>指令调度器</strong>：根据执行单元的可用性，调度指令的执行顺序。</li>
</ul>
</li>
</ul>
<h3 id="浮点单元"><a href="#浮点单元" class="headerlink" title="浮点单元"></a>浮点单元</h3><p>FPU</p>
<ul>
<li><strong>功能</strong>：FPU专门用于处理浮点运算，如小数和科学计数法的计算。与整数运算不同，浮点运算涉及更复杂的数学计算。</li>
<li><strong>作用</strong>：加速处理浮点数运算，特别是在图形处理、科学计算等领域。</li>
</ul>
<h3 id="分支预测单元"><a href="#分支预测单元" class="headerlink" title="分支预测单元"></a>分支预测单元</h3><ul>
<li><strong>功能</strong>：分支预测单元用于预测程序执行中的分支结果（例如，if-else语句中的路径选择），以减少流水线停顿和指令执行延迟。</li>
<li><strong>作用</strong>：通过预测程序分支，减少不必要的计算浪费，提高指令执行效率。</li>
</ul>
<h3 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h3><p>MMU</p>
<ul>
<li><strong>功能</strong>：MMU负责管理虚拟内存地址与物理内存地址之间的映射，处理内存保护、分页等功能。</li>
<li><strong>作用</strong>：支持虚拟内存，管理内存访问权限，提升系统的内存使用效率和安全性。</li>
</ul>
<h3 id="输入输出控制器"><a href="#输入输出控制器" class="headerlink" title="输入输出控制器"></a>输入输出控制器</h3><ul>
<li><strong>功能</strong>：I/O控制器管理CPU与外围设备（如硬盘、键盘、显示器等）之间的数据交换。</li>
<li><strong>作用</strong>：控制输入和输出操作，管理外设的通信。</li>
</ul>
<h3 id="时钟与控制逻辑"><a href="#时钟与控制逻辑" class="headerlink" title="时钟与控制逻辑"></a>时钟与控制逻辑</h3><ul>
<li><strong>功能</strong>：时钟逻辑为CPU提供时间基准，控制逻辑确保各个部分按正确顺序执行操作。</li>
<li><strong>作用</strong>：同步CPU内部各个部分的工作，确保操作按预定时间进行。</li>
</ul>
<h3 id="现代CPU架构特点"><a href="#现代CPU架构特点" class="headerlink" title="现代CPU架构特点"></a>现代CPU架构特点</h3><ul>
<li><strong>多核架构</strong>：现代CPU通常包含多个核心（Core），每个核心都是一个完整的处理单元，可以独立执行指令。多核设计可以提高并行处理能力。</li>
<li><strong>超标量架构</strong>：允许CPU在同一个时钟周期内执行多条指令，通过多个执行单元实现指令级并行。</li>
<li><strong>超线程技术（Hyper-Threading）</strong>：通过硬件虚拟化，允许每个物理核心同时处理多个线程，提高并行处理能力。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CPU结构包含了多个子系统，这些子系统紧密协作，共同执行复杂的计算任务。从基本的算术逻辑单元和控制单元，到高级的缓存和多核架构，每个部分都在优化计算性能和效率方面发挥着重要作用。理解这些组件及其功能，有助于更好地理解处理器的工作原理和性能特点。</p>
<p>java集合</p>
<p>ArrayList. 10.    1.5倍</p>
<p>FailFast   </p>
<p>ArrayList有modCount. 迭代器创建时有expectedModCount 在迭代器调用next()方法时会判断二者是否相等,不等会抛出ConcurrentModificationException异常</p>
<p>FailSafe. </p>
<p>CopyOnWriteArrayList. 写时复制 迭代器遍历的是旧数组</p>
<p>添加元素是新建了一个新数组,在新数组中添加</p>
<p>而且next()方法没有expectedModCount,也不检查二者是否相等</p>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>Java 作为一门广泛应用于企业级应用开发的编程语言，为了保障程序的稳定性和安全性，通常限制了开发者对底层内存和硬件的直接访问。然而，Java 中的 <code>Unsafe</code> 类却为开发者提供了一种突破这些限制的方式，让他们可以<strong>直接操作内存、线程和对象</strong>，同时也引发了一系列潜在的风险和挑战</p>
<h2 id="反射获取Unsafe对象"><a href="#反射获取Unsafe对象" class="headerlink" title="反射获取Unsafe对象"></a>反射获取Unsafe对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(unsafe);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取域的偏移地址</span></span><br><span class="line">        <span class="keyword">long</span> idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">"id"</span>));</span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">// 2. 执行 cas 操作</span></span><br><span class="line">        unsafe.compareAndSwapInt(t, idOffset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        unsafe.compareAndSwapObject(t, nameOffset, <span class="keyword">null</span>, <span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192335920.png" alt="image-20240819233521731"></p>
<h2 id="Unsafe实现原子整数"><a href="#Unsafe实现原子整数" class="headerlink" title="Unsafe实现原子整数"></a>Unsafe实现原子整数</h2><p>封装获取Unsafe对象的工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNSAFE = UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = <span class="keyword">this</span>.value;</span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAtomicInteger</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java创建进程方式"><a href="#java创建进程方式" class="headerlink" title="java创建进程方式"></a>java创建进程方式</h1><p>在Java中，可以使用 <code>ProcessBuilder</code> 或 <code>Runtime</code> 类来创建和管理进程。以下是两种方法的示例：</p>
<h3 id="1-使用-ProcessBuilder"><a href="#1-使用-ProcessBuilder" class="headerlink" title="1. 使用 ProcessBuilder"></a>1. 使用 <code>ProcessBuilder</code></h3><p><code>ProcessBuilder</code> 提供了更灵活的方式来创建和管理进程。可以设置环境变量、工作目录等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessBuilderExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ProcessBuilder 实例</span></span><br><span class="line">        ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置要执行的命令</span></span><br><span class="line">        processBuilder.command(<span class="string">"notepad.exe"</span>); <span class="comment">// Windows 示例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选：设置工作目录</span></span><br><span class="line">        <span class="comment">// processBuilder.directory(new File("path/to/your/directory"));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动进程</span></span><br><span class="line">            Process process = processBuilder.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待进程结束</span></span><br><span class="line">            <span class="keyword">int</span> exitCode = process.waitFor();</span><br><span class="line">            System.out.println(<span class="string">"Exited with code: "</span> + exitCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-Runtime"><a href="#2-使用-Runtime" class="headerlink" title="2. 使用 Runtime"></a>2. 使用 <code>Runtime</code></h3><p><code>Runtime</code> 类提供了一个更简单的方式来执行命令，但不如 <code>ProcessBuilder</code> 灵活。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 Runtime 执行命令</span></span><br><span class="line">            Process process = Runtime.getRuntime().exec(<span class="string">"notepad.exe"</span>); <span class="comment">// Windows 示例</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待进程结束</span></span><br><span class="line">            <span class="keyword">int</span> exitCode = process.waitFor();</span><br><span class="line">            System.out.println(<span class="string">"Exited with code: "</span> + exitCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>命令的路径</strong>：确保要执行的命令在系统的 PATH 环境变量中，或者提供完整路径。</li>
<li><strong>处理输入输出</strong>：可以通过 <code>Process</code> 对象获取进程的输入流、输出流和错误流，以便进行更复杂的交互。</li>
<li><strong>异常处理</strong>：要处理 <code>IOException</code> 和 <code>InterruptedException</code>，以确保程序的健壮性。</li>
</ol>
<p>以上示例展示了如何在Java中创建和管理进程。根据具体需求，可以选择使用 <code>ProcessBuilder</code> 或 <code>Runtime</code>。</p>
<h1 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h1><p>进程通信（Inter-Process Communication, IPC）是指不同进程之间交换数据和信息的方式。在操作系统中，由于进程之间的内存空间是独立的，因此需要一些机制来实现它们之间的通信。以下是几种常见的进程通信方式：</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li><strong>无名管道</strong>：用于具有亲缘关系的进程（如父子进程）之间的通信。数据在管道中是单向流动的。</li>
<li><strong>命名管道</strong>：可以在没有亲缘关系的进程之间进行通信，使用文件系统中的名称来标识。</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>通过一个消息队列，进程可以发送和接收消息。消息队列允许进程以异步方式进行通信，支持优先级。</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li>进程可以共享一块内存区域，以便快速交换数据。共享内存的效率很高，但需要通过其他同步机制（如信号量）来控制对共享内存的访问。</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>信号量是一种用于控制对共享资源访问的同步机制。它可以用于进程间的协调和同步。</li>
</ul>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><ul>
<li>套接字可以用于同一台机器上的进程间通信，也可以用于不同机器上的进程间通信。常见于网络编程。</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>信号是一种异步通信机制，允许一个进程向另一个进程发送通知。信号可以用于处理异常情况或通知特定事件的发生。</li>
</ul>
<h3 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h3><ul>
<li>RPC 允许程序在不同的地址空间（通常是不同的机器）上调用另一个程序的子程序或服务。</li>
</ul>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ul>
<li>通过将文件映射到进程的地址空间，多个进程可以共享数据。适合于大数据量的共享。</li>
</ul>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul>
<li>进程可以通过读写文件来进行通信。虽然效率较低，但实现简单且可用于持久化数据。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>不同的进程通信方式各有优缺点，选择合适的通信方式通常取决于应用场景、性能需求和复杂性。</p>
<h1 id="匿名管道和命名管道区别"><a href="#匿名管道和命名管道区别" class="headerlink" title="匿名管道和命名管道区别"></a>匿名管道和命名管道区别</h1><p>命名管道和匿名管道是两种不同类型的管道，用于进程间通信（IPC）。它们之间有几个主要区别：</p>
<h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><ul>
<li><strong>命名管道</strong>：有一个特定的名称，可以在文件系统中查看和访问。进程可以通过这个名称来打开和使用管道。</li>
<li><strong>匿名管道</strong>：没有名称，通常只能在创建它的进程及其子进程之间使用。它们存在于进程的内存中，无法在文件系统中找到。</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><strong>命名管道</strong>：可以在不相关的进程之间通信，因为它们是通过名称来引用的。</li>
<li><strong>匿名管道</strong>：通常用于父子进程之间的通信，因为它们只能在创建它的进程及其子进程之间使用。</li>
</ul>
<h3 id="创建和使用"><a href="#创建和使用" class="headerlink" title="创建和使用"></a>创建和使用</h3><ul>
<li><strong>命名管道</strong>：需要使用特定的系统调用（如 <code>mkfifo</code> 或 <code>CreateNamedPipe</code>）来创建，并且可以在多个进程中打开和使用。</li>
<li><strong>匿名管道</strong>：使用简单的系统调用（如 <code>pipe()</code>）来创建，通常在进程创建时使用。</li>
</ul>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><ul>
<li><strong>命名管道</strong>：在进程结束后仍然存在，直到显式删除。</li>
<li><strong>匿名管道</strong>：在创建它的进程结束后，管道也会被销毁。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>命名管道</strong>适用于需要跨多个不相关进程进行通信的场景，具有持久性和可命名性。</li>
<li><strong>匿名管道</strong>则更适合父子进程之间的简单、临时通信。</li>
</ul>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><ol>
<li>继承Thread</li>
</ol>
<p>Thread t=new Thread()</p>
<ol>
<li>实现Runnable接口 实现run方法</li>
</ol>
<p>Thread t=new Thread(Runnable r)</p>
<ol>
<li>FutureTask</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191854010.png" alt="image-20240819185433268"></p>
<ul>
<li><p>FutureTask实现了Runnable接口和Future接口,内部有一个Callable接口的引用</p>
<ul>
<li>Future接口 get方法阻塞获取值. 内部用park. 这个返回值是FutureTask的outcome</li>
<li>Callable接口。定义基本逻辑 和返回值</li>
</ul>
</li>
<li><p>FutureTask的run()执行逻辑</p>
<ul>
<li>在run方法中调用Callable接口的call,设置outcome变量为Callable接口的返回值,run方法执行最后会调用unpark,唤醒调用get方法的线程</li>
</ul>
</li>
</ul>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>Java线程6种</p>
<p><strong>六种状态及转换</strong></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192341949.png" alt="image-20240819234137720"></p>
<p>分别是</p>
<ul>
<li>新建<ul>
<li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li>
<li>此时未与操作系统底层线程关联</li>
</ul>
</li>
<li>可运行<ul>
<li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li>
<li>此时与底层线程关联，由操作系统调度执行</li>
</ul>
</li>
<li>终结<ul>
<li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li>
<li>此时会取消与底层线程关联</li>
</ul>
</li>
<li>阻塞<ul>
<li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li>
<li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li>
</ul>
</li>
<li>等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
<li>有时限等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
</ul>
<p><strong><em>其它情况</em></strong></p>
<ul>
<li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li>
<li>park，unpark 等方法也可以让线程等待和唤醒</li>
</ul>
<p>操作系统5种</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192343116.png" alt="image-20240819234324890"></p>
<ul>
<li>运行态：分到 cpu 时间，能真正执行线程内代码的</li>
<li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li>
<li>阻塞态：没资格分到 cpu 时间的<ul>
<li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li>
<li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li>
</ul>
</li>
<li>新建与终结态：与 java 中同名状态类似</li>
</ul>
<p>查看线程状态 getState()</p>
<h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><p>线程使用cpu 到不使用cpu会发生上下文切换。操作系统需要保存线程状态。 恢复另一个线程的状态</p>
<h1 id="Java对象内存布局和对象头"><a href="#Java对象内存布局和对象头" class="headerlink" title="Java对象内存布局和对象头"></a>Java对象内存布局和对象头</h1><h2 id="对象在堆内存中布局"><a href="#对象在堆内存中布局" class="headerlink" title="对象在堆内存中布局"></a>对象在堆内存中布局</h2><p>对象内部结构分为：对象头、实例数据、对齐填充（保证8个字节的倍数）。 对象头分为对象标记（markOop）和类元信息（klassOop），类元信息存储的是指向该对象类元数据（klass）的首地址</p>
<p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节</p>
<p>指针压缩</p>
<p> 默认存储对象的HashCode、分代年龄和锁标志位等信息</p>
<h4 id="对象头多大"><a href="#对象头多大" class="headerlink" title="对象头多大"></a>对象头多大</h4><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存放类的属性(Field)数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存占4字节。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐。</p>
<p>markword(64位)分布图</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211948847.png" alt="image-20240821194834567"></p>
<p>Synchronized 即使发生上下文切换。另外的线程也不能执行代码会处于阻塞状态</p>
<h2 id="Synchronized的性能变化"><a href="#Synchronized的性能变化" class="headerlink" title="Synchronized的性能变化"></a>Synchronized的性能变化</h2><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的<br>Mark Word 中就被设置指向 Monitor 对象的指针</p>
<p>java5以前，只有Synchronized，这个是操作系统级别的重量级操作，重量级锁，假如锁的竞争比较激烈的话，性能下降</p>
<p>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p>
<p> 在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因 Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p>
<p>Mutex Lock Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所以synchronized是Java语言中的一个重量级操作。</p>
<p>Monitor与java对象以及线程是如何关联 ？ 1.如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址 2.Monitor的Owner字段会存放拥有相关联对象锁的线程id</p>
<p>Mutex Lock 的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。</p>
<p>Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"10进制hash码："</span>+o.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"16进制hash码："</span>+Integer.toHexString(o.hashCode()));</span><br><span class="line">        System.out.println(<span class="string">"2进制hash码："</span>+Integer.toBinaryString(o.hashCode()));</span><br><span class="line"></span><br><span class="line">        System.out.println( ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212021496.png" alt="image-20240821202136373"></p>
<p>不开启指针压缩是16个字节,这里默认开启所以对象头12个字节,最后是填充4字节达到8字节的整数倍16</p>
<p>第一个字节01如下图所示</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212027272.png" alt="image-20240821202744146"></p>
<p>然后是hashcode,倒着读每1个字节,共有31位</p>
<p>4b1210ee -&gt;ee 10 12 4b</p>
<p>对象头最高25位是unused,4b的最高位是0所以hashcode也是4b,而且之后都是00</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的出现是为了解决只有在一个线程执行同步时提高性能</p>
<p>54位线程id</p>
<p>通过CAS方式修改markword中的线程ID,之后直接比较线程ID是否相等</p>
<p>技术实现： 一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还 会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向本身的ID，无需再进入 Monitor 去竞争对象了。</p>
<p>一个对象创建时：</p>
<ul>
<li><p>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的</p>
<p>thread、epoch、age 都为 0</p>
</li>
<li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -</p>
<p>XX:BiasedLockingStartupDelay=0 来禁用延迟</p>
</li>
<li><p>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、</p>
<p>age 都为 0，第一次用到 hashcode 时才会赋值</p>
</li>
</ul>
<p>偏向锁JVM命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial |grep BiasedLock*</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 实际上偏向锁在JDK1.6之后是默认开启的，但是启动时间有延迟，</span><br><span class="line">* 所以需要添加参数-XX:BiasedLockingStartupDelay=0，让其在程序启动时立刻启动。</span><br><span class="line">*</span><br><span class="line">* 开启偏向锁：</span><br><span class="line">* -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br><span class="line">*</span><br><span class="line">* 关闭偏向锁：关闭之后程序默认会直接进入------------------------------------------&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   轻量级锁状态。</span><br><span class="line">* -XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>
<p>调用hashCode 会撤销偏向锁 到无锁状态。markword存不下线程id(和hashCode冲突)</p>
<p>轻量级锁不会 hashCode存在栈帧锁记录 解锁再恢复hashCode</p>
<p>重量级锁hashCode存在monitor对象。解锁再恢复hashCode</p>
<p>Wait notify 是重量级锁的,调用就变成重量级锁</p>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁</p>
<p>竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。</p>
<blockquote>
<p>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。 撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行：</p>
<p>① 第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。 此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。 ② 第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。</p>
</blockquote>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212107085.png" alt="image-20240821210751004"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以<br>使用轻量级锁来优化</p>
<p>栈帧创建锁记录（Lock Record）对象(jvm层面的)，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p>
<h4 id><a href="#" class="headerlink" title></a><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212138072.png" alt="image-20240821213844962"></h4><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212139546.png" alt="image-20240821213950449"></p>
<p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212140423.png" alt="image-20240821214022316"></p>
<ul>
<li>如果 cas 失败，有两种情况<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212142102.png" alt="image-20240821214226940"></p>
<p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重<br>入计数减一</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212142597.png" alt="image-20240821214253495"></p>
<ul>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，</p>
<p>这时使用 cas 将 Mark Word 的值恢复给对象头</p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<p>栈帧创建锁记录对象(jvm层面的)。锁记录对象有 对象指针 锁记录地址</p>
<p>对象指针指向锁对象</p>
<p>锁记录地址 cas 对象头的markword.   交换。表示加锁</p>
<p>成功后锁记录的锁记录地址存的是原来的markword,对象头的markword存的是锁记录的地址</p>
<p>赋值锁记录。 对象的markword指针指向</p>
<p>锁膨胀</p>
<p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212146003.png" alt="image-20240821214636908"></p>
<ul>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408212147868.png" alt="image-20240821214748726"></p>
<p>自旋优化</p>
<p>升级重量级锁之前进行</p>
<h4 id="轻量锁与偏向锁的区别和不同"><a href="#轻量锁与偏向锁的区别和不同" class="headerlink" title="轻量锁与偏向锁的区别和不同"></a>轻量锁与偏向锁的区别和不同</h4><p>争夺轻量级锁失败时，自旋尝试抢占锁</p>
<p>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁(全局安全点)</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>偏向锁:适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法/代码块则使用偏向锁。 轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法/代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。 重量级锁：适用于竞争激烈的情况，如果同步方法/代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</p>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><p>减少上锁时间<br>同步代码块中尽量短</p>
<p>减少锁的粒度<br>将一个锁拆分为多个锁提高并发度，例如：</p>
<ul>
<li>ConcurrentHashMap</li>
<li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li>
<li>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</li>
</ul>
<p>锁粗化<br>多次循环进入同步块不如同步块内多次循环<br>另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，<br>没必要重入多次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> StringBuffer().append(<span class="string">"a"</span>).append(<span class="string">"b"</span>).append(<span class="string">"c"</span>);</span><br></pre></td></tr></table></figure>
<p>锁消除<br>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候<br>就会被即时编译器忽略掉所有同步操作。</p>
<p>读写分离<br>CopyOnWriteArrayList<br>ConyOnWriteSet</p>
<h2 id="JIT编译器对锁的优化"><a href="#JIT编译器对锁的优化" class="headerlink" title="JIT编译器对锁的优化"></a>JIT编译器对锁的优化</h2><p>锁消除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁消除</span></span><br><span class="line"><span class="comment"> * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，</span></span><br><span class="line"><span class="comment"> * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockClearUPDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();<span class="comment">//正常的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//锁消除,JIT会无视它，synchronized(对象锁)不存在了。不正常的</span></span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"-----hello LockClearUPDemo"</span>+<span class="string">"\t"</span>+o.hashCode()+<span class="string">"\t"</span>+objectLock.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LockClearUPDemo demo = <span class="keyword">new</span> LockClearUPDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                demo.m1();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁粗化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁粗化</span></span><br><span class="line"><span class="comment"> * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，</span></span><br><span class="line"><span class="comment"> * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBigDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"11111"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"22222"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"33333"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"a"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"44444"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"55555"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"66666"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"b"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h1 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h1><p>2个线程互相改变对方结束条件,最后谁也无法结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">"count: &#123;&#125;"</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">"count: &#123;&#125;"</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h1><p>线程优先级太低,得不到cpu,自己又在死等</p>
<p>读写锁有饥饿问题</p>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>线程安全是指在多线程环境中，多个线程同时访问某个资源（例如变量、数据结构或对象）时，能够正确地操作该资源而不会导致数据不一致,如果一段代码有多个线程同时进入可能会导致数据不一致就有线程安全问题,要加同步代码块synchronized等方式解决.</p>
<h3 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h3><ol>
<li><strong>互斥锁（Mutex）</strong>：使用互斥锁来保护共享资源，确保同一时间只有一个线程可以访问该资源。</li>
<li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享数据，但在写入时会阻止其他线程的读取和写入。</li>
<li><strong>原子操作（Atomic Operations）</strong>：使用原子操作来确保某些操作在执行时不会被中断，从而避免数据竞争。</li>
<li><strong>线程局部存储（Thread Local Storage）</strong>：为每个线程分配独立的存储空间，避免共享状态。</li>
<li><strong>不可变对象（Immutable Objects）</strong>：使用不可变对象，确保对象在创建后不会被修改，从而避免并发问题。</li>
</ol>
<p><strong>成员变量和静态变量是否线程安全？</strong></p>
<ul>
<li>如果它们没有共享，则线程安全 </li>
<li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 </p>
</li>
<li><ul>
<li>如果只有读操作，则线程安全 </li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里的共享指被多个线程访问</p>
</blockquote>
<p><strong>局部变量是否线程安全？</strong> </p>
<ul>
<li>局部变量是线程安全的 </li>
<li><p>但局部变量引用的对象则未必 </p>
</li>
<li><ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的 </li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>主要是看这段代码是否有共享(被多线程访问) ,并且有多线程读写(如果全是读操作没有线程安全问题)</p>
<h3 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h3><ul>
<li>String </li>
<li>Integer </li>
<li>StringBuffer </li>
<li>Random </li>
<li>Vector </li>
<li>Hashtable </li>
<li>java.util.concurrent 包下的类</li>
</ul>
<blockquote>
<p>线程安全类的组合调用方法不是线程安全的</p>
</blockquote>
<ul>
<li>它们的每个方法是原子的 </li>
<li>但<strong>注意</strong>它们多个方法的组合不是原子的，见后面分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">"key"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    table.put(<span class="string">"key"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211652379.png" alt="image-20240821165240117"></p>
<h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 </p>
<p>对String修改的replace,substring等方法都是创建新对象,也就是对象内部的状态不会改变</p>
<p>无状态类也是线程安全的(没有成员变量)</p>
<h1 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h1><p>关于打断的三个方法</p>
<ul>
<li><p>Thread.interrupted() 静态方法。返回当前打断标记。 但是会清除打断标记。也就是下次获取是false</p>
</li>
<li><p>isInterrupted  返回当前打断标记。 不会清除打断标记</p>
</li>
<li><p>interrupt(). 打断线程,对于正在运行线程和处于waiting状态线程效果不同</p>
</li>
</ul>
<p>interrupt()打断正常运行状态线程,不抛出异常,记录打断标记为true</p>
<p>interrupt()打断waiting状态线程</p>
<ul>
<li><p>sleep.  抛出异常 打断标记清除</p>
</li>
<li><p>park. 不抛出异常 打断标记不清除。 再次park会失败,需要人为清除打断标记</p>
</li>
</ul>
<h1 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h1><p>需要和同步块结合使用。 </p>
<p>正确用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">  <span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">      lock.wait();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//干活</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    改变条件,使前面的线程条件成立</span><br><span class="line">  	lock.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能存在虚假唤醒,  虽然唤醒了但是条件不满足还是会执行lock.wait();继续处于waiting状态</p>
<p>要用多把锁,一个锁一个条件</p>
<p>同步块中不要用sleep代替wait sleep不释放锁</p>
<p>sleep和wait都释放cpu,wait会释放锁但是sleep不释放锁</p>
<h1 id="park-amp-unpark"><a href="#park-amp-unpark" class="headerlink" title="park&amp;unpark"></a>park&amp;unpark</h1><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"start..."</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">"park..."</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">"resume..."</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">"unpark..."</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻</p>
<ul>
<li><p>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中</p>
<p>的备用干粮（0 为耗尽，1 为充足）</p>
</li>
<li><p>调用 park 就是要看需不需要停下来歇息</p>
<ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ul>
</li>
<li><p>调用 unpark，就好比令干粮充足</p>
<ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ul>
<li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="await-amp-signal"><a href="#await-amp-signal" class="headerlink" title="await&amp;signal"></a>await&amp;signal</h1><p>和ReentrantLock.lock   ReentrantLock.unlock配合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition c=lock.newCondition();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//c.await();</span></span><br><span class="line">  <span class="comment">//c.signal();</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h1><h2 id="顺序打印"><a href="#顺序打印" class="headerlink" title="顺序打印"></a>顺序打印</h2><p>先打印2后打印1</p>
<h3 id="wait-amp-notify-1"><a href="#wait-amp-notify-1" class="headerlink" title="wait &amp;notify"></a>wait &amp;notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 表示 t2 是否运行过</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> t2runned = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!t2runned) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">"1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">"2"</span>);</span><br><span class="line">                t2runned = <span class="keyword">true</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="park-amp-unpark-1"><a href="#park-amp-unpark-1" class="headerlink" title="park&amp;unpark"></a>park&amp;unpark</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">"1"</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"2"</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h2><h3 id="wait-amp-notify-2"><a href="#wait-amp-notify-2" class="headerlink" title="wait &amp;notify"></a>wait &amp;notify</h3><p>线程1输出a 5次</p>
<p>线程2输出b 5次</p>
<p>线程3输出c 5次</p>
<p>要求输出abcabcabcabcabc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify wn = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">"a"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">"b"</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wn.print(<span class="string">"c"</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出内容       等待标记     下一个标记</span></span><br><span class="line"><span class="comment">   a           1             2</span></span><br><span class="line"><span class="comment">   b           2             3</span></span><br><span class="line"><span class="comment">   c           3             1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印               a           1             2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotify</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始标记设置为1,线程1等待标记为1先打印a,再将标记设置为2</p>
<p>线程2等待标记为2打印b,再将标记设置为3</p>
<p>线程3等待标记为3打印c,再将标记设置为1</p>
<h3 id="await-amp-signal-1"><a href="#await-amp-signal-1" class="headerlink" title="await.&amp;signal"></a>await.&amp;signal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a = awaitSignal.newCondition();</span><br><span class="line">        Condition b = awaitSignal.newCondition();</span><br><span class="line">        Condition c = awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">"a"</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">"b"</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">"c"</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始..."</span>);</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition current, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="park-amp-unpack"><a href="#park-amp-unpack" class="headerlink" title="park&amp;unpack"></a>park&amp;unpack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test31</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark pu = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">"a"</span>, t2);</span><br><span class="line">        &#125;);</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">"b"</span>, t3);</span><br><span class="line">        &#125;);</span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            pu.print(<span class="string">"c"</span>, t1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="两阶段终止"><a href="#两阶段终止" class="headerlink" title="两阶段终止"></a>两阶段终止</h1><p>利用停止标记(volatile修饰)</p>
<p> 初始为false</p>
<p>其他线程终止设置停止标记为true</p>
<p>当前线程判断停止标记为true则终止当前线程</p>
<p>利用打断标记</p>
<p>interrupt打断,</p>
<p>线程在可运行状态记录打断标记可以设置终止动作</p>
<p>线程在waiting状态会抛出异常,清除打断标记.我们可以catch异常设置打断标记为true,设置终止动作</p>
<h1 id="保护性暂停模式"><a href="#保护性暂停模式" class="headerlink" title="保护性暂停模式"></a>保护性暂停模式</h1><p>同步模式,一个线程拿另一个线程的结果 </p>
<p>Wait&amp;notify</p>
<h1 id="同步模式之-Balking-犹豫"><a href="#同步模式之-Balking-犹豫" class="headerlink" title="同步模式之 Balking(犹豫)"></a>同步模式之 Balking(犹豫)</h1><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来表示是否已经有线程已经在执行启动了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> starting;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"尝试启动监控线程..."</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真正启动监控线程...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它还经常用来实现线程安全的单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。</p>
<h1 id="CPU流水线和指令级并行"><a href="#CPU流水线和指令级并行" class="headerlink" title="CPU流水线和指令级并行"></a>CPU流水线和指令级并行</h1><p>CPU流水线和指令级并行（Instruction-Level Parallelism, ILP）是现代处理器设计中提升性能的关键技术。它们通过并行执行指令来加快指令处理速度。下面将分别解释这两个概念。</p>
<h2 id="1-CPU流水线（Pipeline）"><a href="#1-CPU流水线（Pipeline）" class="headerlink" title="1. CPU流水线（Pipeline）"></a>1. <strong>CPU流水线（Pipeline）</strong></h2><p>流水线是一种通过将指令的执行过程分成多个阶段，并让多个指令在不同阶段并行处理的技术。它类似于生产线上的流水作业，可以显著提高CPU的指令处理速度。</p>
<h3 id="流水线的基本工作原理："><a href="#流水线的基本工作原理：" class="headerlink" title="流水线的基本工作原理："></a>流水线的基本工作原理：</h3><ul>
<li><strong>分阶段执行</strong>：指令的执行被分解为多个阶段，例如取指令、解码、执行、存储结果等。每个阶段由不同的硬件单元负责。</li>
<li><strong>并行处理</strong>：不同的指令可以同时在流水线的不同阶段中执行。比如，当一条指令在执行阶段时，另一条指令可以在取指阶段，这样在一个时钟周期内处理多条指令。</li>
</ul>
<h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><p>假设一条指令的执行被分为以下5个阶段：</p>
<ol>
<li><strong>取指令（IF）</strong></li>
<li><strong>解码（ID）</strong></li>
<li><strong>执行（EX）</strong></li>
<li><strong>访存（MEM）</strong></li>
<li><strong>写回（WB）</strong></li>
</ol>
<p>在传统的非流水线处理器中，这5个阶段是顺序执行的，需要5个时钟周期来完成一条指令。而在流水线处理器中，当第一条指令进入第二阶段时，第二条指令已经进入了第一阶段。这样，当流水线填满时，每个时钟周期都可以完成一条指令，显著提高了指令处理的吞吐量。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><strong>提高指令吞吐量</strong>：流水线可以让CPU在每个时钟周期执行一条指令，从而大幅度提高了指令的执行速度。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><strong>流水线阻塞</strong>：如果某条指令需要等待数据（如数据依赖），整个流水线可能会被阻塞，影响性能。</li>
</ul>
<h2 id="2-指令级并行（ILP）"><a href="#2-指令级并行（ILP）" class="headerlink" title="2. 指令级并行（ILP）"></a>2. <strong>指令级并行（ILP）</strong></h2><p>指令级并行指的是通过并行执行多条不相关指令（即指令之间没有数据依赖关系），进一步提高CPU的效率。ILP可以通过硬件和软件两种方式来实现。</p>
<h3 id="ILP的实现方式："><a href="#ILP的实现方式：" class="headerlink" title="ILP的实现方式："></a>ILP的实现方式：</h3><ul>
<li><strong>硬件支持的并行</strong>：超标量处理器是硬件实现ILP的典型例子。它们可以在同一个时钟周期内同时执行多条指令。CPU内部有<strong>多个执行单元</strong>，可以并行处理多条指令。</li>
<li><strong>编译器优化</strong>：编译器可以在编译时重新排列指令的顺序，使得更多的指令可以并行执行。通过消除指令之间的依赖关系，编译器可以提高程序的并行性。</li>
</ul>
<h3 id="举例说明：-1"><a href="#举例说明：-1" class="headerlink" title="举例说明："></a>举例说明：</h3><p>假设有以下两条指令：</p>
<ol>
<li>加法：<code>R1 = R2 + R3</code></li>
<li>乘法：<code>R4 = R5 * R6</code></li>
</ol>
<p>这两条指令之间没有依赖关系，可以并行执行。如果CPU有两个执行单元，那么可以同时执行这两条指令，而不必等待加法指令完成再执行乘法指令。</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><strong>提高指令并行度</strong>：ILP使得多个指令可以同时执行，提高了CPU的利用率和整体性能。</li>
</ul>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><strong>复杂性增加</strong>：实现高效的ILP需要复杂的硬件和编译器支持，可能会增加功耗和设计难度。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li><strong>流水线</strong>通过分阶段并行处理指令，提升了指令的执行速度，是一种垂直的并行处理方式。</li>
<li><strong>指令级并行</strong>通过并行执行不同指令，进一步提高了处理器的性能，是一种横向的并行处理方式。</li>
</ul>
<p>两者结合起来，可以显著提高CPU的整体性能。</p>
<h2 id="CPU执行单元"><a href="#CPU执行单元" class="headerlink" title="CPU执行单元"></a>CPU执行单元</h2><p>CPU的执行单元数量取决于其架构和设计。执行单元是处理器内部负责执行指令的功能模块，<strong>不同类型</strong>的执行单元负责不同的任务。常见的执行单元包括整数运算单元、浮点运算单元、加载/存储单元等。现代高性能CPU通常具有<strong>多个执行单元</strong>，以实现指令级并行和提高处理效率。</p>
<h3 id="不同类型的执行单元："><a href="#不同类型的执行单元：" class="headerlink" title="不同类型的执行单元："></a>不同类型的执行单元：</h3><ol>
<li><strong>整数运算单元（Integer Execution Units）</strong>：负责处理整数运算，如加法、减法、逻辑运算等。</li>
<li><strong>浮点运算单元（Floating-Point Units, FPU）</strong>：负责处理浮点数运算，如小数计算、科学计算等。</li>
<li><strong>加载/存储单元（Load/Store Units）</strong>：负责处理内存数据的加载和存储操作。</li>
<li><strong>分支执行单元（Branch Execution Units）</strong>：负责处理分支指令，如条件跳转和循环控制。</li>
<li><strong>向量执行单元（Vector Execution Units）</strong>：负责处理SIMD（单指令多数据）操作，用于并行处理多个数据点，常用于多媒体、图形计算。</li>
</ol>
<h2 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h2><p>现代 CPU 支持<strong>多级指令流水线</strong>，例如支持同时执行 <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理器，就可以称之为<strong>五级指令流水线</strong>。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率</p>
<p>下面5条指令</p>
<ol>
<li><strong>取指令（IF）</strong></li>
<li><strong>解码（ID）</strong></li>
<li><strong>执行（EX）</strong></li>
<li><strong>访存（MEM）</strong></li>
<li><strong>写回（WB）</strong></li>
</ol>
<p>这5个阶段就对应着CPU不同的执行单元,可以在支持流水线的处理器中同时执行</p>
<ul>
<li>第1条指令的WB阶段</li>
<li>第2条指令的MEM阶段</li>
<li>第3条指令的EX阶段</li>
<li>第4条指令的ID阶段</li>
<li>第5条指令的IF阶段</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211522431.png" alt="image-20240821152233123"></p>
<p>大多数处理器包含多个执行单元，并不是所有计算功能都集中在一起，可以再细分为整数运算单元、浮点数运算单 </p>
<p>元等，这样可以把多条指令也可以做到并行获取、译码等，CPU 可以在一个时钟周期内，执行多于一条指令，IPC&gt; 1</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211523466.png" alt="image-20240821152353243"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h4 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h4><p>CPU的执行单元数量取决于其架构和设计。执行单元是处理器内部负责执行指令的功能模块，<strong>不同类型</strong>的执行单元负责不同的任务。常见的执行单元包括整数运算单元、浮点运算单元、加载/存储单元等。现代高性能CPU通常具有<strong>多个执行单元</strong>，以实现指令级并行和提高处理效率。</p>
<h4 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h4><p>编译器可以在编译时重新排列指令的顺序，使得更多的指令可以并行执行。通过消除指令之间的依赖关系，编译器可以提高程序的并行性。</p>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><h2 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h2><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211454363.png" alt="image-20240821145440983"></p>
<ol>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211455767.png" alt="image-20240821145526492"></p>
<ol>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211455781.png" alt="image-20240821145546591"></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>使用volatile（易变关键字） </p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p>
<p>一个写线程写volatile变量，多个读线程读volatile变量可以获取最新值</p>
<p>这个例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性， 也就是 volatile 可以处理可见性问题,但不能处理原子性问题</p>
<p>程安全时举的例子：两个线程一个 i++ 一个 i— ，只能保证看到最新值，不能解决指令交错</p>
<h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>指令重排的前提是，重排指令不能影响结果，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以重排的例子</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// 指令2</span></span><br><span class="line">System.out.println( a + b );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能重排的例子</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="keyword">int</span> b = a - <span class="number">5</span>; <span class="comment">// 指令2</span></span><br></pre></td></tr></table></figure>
<p>为什么要有重排指令这项优化呢？从 CPU 执行指令的原理来理解一下吧,可以看前面介绍的指令级并行</p>
<h2 id="指令重排序导致诡异的结果"><a href="#指令重排序导致诡异的结果" class="headerlink" title="指令重排序导致诡异的结果"></a>指令重排序导致诡异的结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//这里可能发生指令重排序</span></span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？ </p>
<p>有同学这么分析 </p>
<ul>
<li>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1 </li>
<li>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支,结果为1 </li>
<li>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了） </li>
</ul>
<p>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！ </p>
<p>这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2 </p>
<p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，指令重排单线程没有问题,多线程就会出现问题了</p>
<p>这个现象需要通过大量测试才能复现</p>
<p>可以借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>volatile 修饰的变量，可以禁用指令重排</p>
<h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><p>volatile 修饰的变量可以保证可见性和有序性,但不能保证原子性(不同线程间指令交错)</p>
<h2 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a>volatile保证可见性</h2><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li><strong>对 volatile 变量的 写指令后会加入写屏障 :</strong> 保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对 volatile 变量的 读指令前会加入读屏障 :</strong> 在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>写屏障是本线程的volatile写操作和之前的写操作对其他线程可见</p>
</li>
<li><p>读屏障是其他线程的写操作对当前线程可见</p>
</li>
</ol>
<h2 id="volatile保证有序性"><a href="#volatile保证有序性" class="headerlink" title="volatile保证有序性"></a>volatile保证有序性</h2><ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211542620.png" alt="image-20240821154222396"></p>
<p>不能解决指令交错： </p>
<ul>
<li><p>写屏障仅仅是保证之后的volatile读和volatile读之后的读操作能够读到最新的结果，</p>
<p>但不能保证别的线程的读操作不会跑到它前面去,拿着旧数据操作设置回主存会🈶️丢失更新的情况</p>
</li>
<li><p>而有序性的保证也只是保证了本线程内相关代码不被重排序</p>
</li>
</ul>
<h3 id="volatile应用"><a href="#volatile应用" class="headerlink" title="volatile应用"></a><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408211545787.png" alt="image-20240821154505562">volatile应用</h3><p>线程安全的双重检查锁单例模式用到了volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>INSTANCE = new Singleton();有三条指令</p>
<ol>
<li><p>分配内存</p>
</li>
<li><p>调用Singleton()构造函数</p>
</li>
<li><p>给INSTANCE赋值</p>
</li>
</ol>
<p>这三条指令会发生重排序,就可能会导致2,3颠倒顺序,这时INSTANCE!=null但是还没有调用Singleton()构造函数,假设此时另一个线程在第一个if条件进行判断发现INSTANCE!=null就会返回一个未经过调用Singleton()构造函数的对象,这是不符合预期的.</p>
<p>可以用volatile修饰,这样第三条指令就是volatile变量的写操作,volatile禁止指令重排序,2,3不会颠倒顺序就不会发生上述情况</p>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><h2 id="CAS概述"><a href="#CAS概述" class="headerlink" title="CAS概述"></a>CAS概述</h2><p>compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它是原子操作</p>
<p>其实 CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p>
<ul>
<li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li>
</ul>
<p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
<h2 id="synchronized和CAS比较"><a href="#synchronized和CAS比较" class="headerlink" title="synchronized和CAS比较"></a>synchronized和CAS比较</h2><p>synchronized 和 cas 没有绝对的谁效率高,要看所处的场景</p>
<ul>
<li><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</p>
</li>
<li><ul>
<li>打个比喻, 线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火,等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大 </li>
</ul>
</li>
<li><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于分配的时间片到时间了，仍然会进入可运行状态让出cpu，还是会导致上下文切换。</p>
</li>
</ul>
<h2 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h2><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。 </p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 </li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 </li>
<li><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 </p>
</li>
<li><ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h1 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens Before规则"></a>Happens Before规则</h1><p>共享变量可见性的总结.  </p>
<p>变量都是指成员变量或静态成员变量</p>
<p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛<br>开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>
<p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待<br>它结束）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">"t1"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>
<p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过<br>t2.interrupted 或 t2.isInterrupted）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"t2"</span>);</span><br><span class="line">t2.start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">t2.interrupt();</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">y = <span class="number">10</span>;</span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span></span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<h1 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191745877.png" alt="image-20240819174553708"></p>
<p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、<br>AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的</p>
<h2 id="原子整型"><a href="#原子整型" class="headerlink" title="原子整型"></a>原子整型</h2><p>AtomicInteger AtomicLong AtomicBoolean</p>
<p>incrementAndGet</p>
<p>getAndIncrement</p>
<p>getAndAdd</p>
<p>addAndGet</p>
<p>updateAndGet.    类似++i</p>
<p>getAndUpdate.    类似i++</p>
<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><p> AtomicIntegerArray AtomicLongArray. AtomicReferenceArray</p>
<p>AtomicIntegerArray array=new AtomicIntegerArray(length)</p>
<p>array.getAndIncrement(index)</p>
<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>AtomicReference. AtomicStampedReference. AtomicMarkableReference</p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">"A"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        testAtomicReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"main start..."</span>);</span><br><span class="line">        <span class="comment">// 获取值 A</span></span><br><span class="line">        String prev = ref.get();</span><br><span class="line">        <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">        otherReference();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 尝试改为 C</span></span><br><span class="line">        log.debug(<span class="string">"change A-&gt;C &#123;&#125;"</span>, ref.compareAndSet(prev, <span class="string">"C"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"change A-&gt;B &#123;&#125;"</span>, ref.compareAndSet(ref.get(), <span class="string">"B"</span>));</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"change B-&gt;A &#123;&#125;"</span>, ref.compareAndSet(ref.get(), <span class="string">"A"</span>));</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192253053.png" alt="image-20240819225333928"></p>
<p>AtomicStampedReference 加版本号解决ABA</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">"A"</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        testAtomicStampedReference ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomicStampedReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"main start..."</span>);</span><br><span class="line">        <span class="comment">// 获取值 A</span></span><br><span class="line">        String prev = stampedReference.getReference();</span><br><span class="line">        <span class="comment">// 获取版本号</span></span><br><span class="line">        <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">        log.debug(<span class="string">"版本 &#123;&#125;"</span>, stamp);</span><br><span class="line">        <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">        other();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 尝试改为 C</span></span><br><span class="line">        log.debug(<span class="string">"change A-&gt;C &#123;&#125;"</span>, stampedReference.compareAndSet(prev, <span class="string">"C"</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"change A-&gt;B &#123;&#125;"</span>, stampedReference.compareAndSet(stampedReference.getReference(), <span class="string">"B"</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            log.debug(<span class="string">"更新版本为 &#123;&#125;"</span>, stampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"change B-&gt;A &#123;&#125;"</span>, stampedReference.compareAndSet(stampedReference.getReference(), <span class="string">"A"</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            log.debug(<span class="string">"更新版本为 &#123;&#125;"</span>, stampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192254977.png" alt="image-20240819225426774"></p>
<p>AtomicmarkableReference  关心是否修改过,维护一个布尔变量. 不能解决ABA</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        GarbageBag bag = <span class="keyword">new</span> GarbageBag(<span class="string">"装满了垃圾"</span>);</span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"start..."</span>);</span><br><span class="line">        GarbageBag prev = ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"start..."</span>);</span><br><span class="line">            bag.setDesc(<span class="string">"空垃圾袋"</span>);</span><br><span class="line">            <span class="keyword">boolean</span> b = ref.compareAndSet (bag, bag, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            log.info (<span class="string">"bb..&#123;&#125;"</span>,b);</span><br><span class="line">            log.info (<span class="string">"bb...&#123;&#125;"</span>,ref.isMarked ());</span><br><span class="line">            log.debug(bag.toString());</span><br><span class="line">        &#125;,<span class="string">"保洁阿姨"</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">"想换一只新垃圾袋？"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println (ref.getReference ()==prev);</span><br><span class="line">        System.out.println (ref.getReference ()==bag);</span><br><span class="line">        <span class="keyword">boolean</span> success = ref.compareAndSet(prev, <span class="keyword">new</span> GarbageBag(<span class="string">"空垃圾袋"</span>), <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        log.debug(<span class="string">"换了么？"</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GarbageBag</span> </span>&#123;</span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GarbageBag</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">" "</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子字段更新器"><a href="#原子字段更新器" class="headerlink" title="原子字段更新器"></a>原子字段更新器</h2><p>AtomicIntegerFieldUpdater. AtomicLongFieldUpdater. AtomicReferenceFieldUpdater</p>
<p>必须和volatile配合使用,否则会有异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> t=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        AtomicReferenceFieldUpdater updater =</span><br><span class="line">                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(updater.compareAndSet(stu, <span class="keyword">null</span>, <span class="string">"张三"</span>));</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">        AtomicIntegerFieldUpdater integerFieldUpdater=AtomicIntegerFieldUpdater.newUpdater (Test40.class,<span class="string">"t"</span>);</span><br><span class="line"></span><br><span class="line">        Test40 test40=<span class="keyword">new</span> Test40 ();</span><br><span class="line">        System.out.println(integerFieldUpdater.compareAndSet(test40, <span class="number">10</span>, <span class="number">13</span>));</span><br><span class="line">        System.out.println(test40.t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><p>LongAdder DoubleAdder  LongAccumulator</p>
<h3 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h3><p>LongAdder只能用来计算加法，且从零开始计算</p>
<p>LongAccumulator提供了自定义的函数操作</p>
<p><code>LongAccumulator</code> 是 Java 8 引入的一个类，位于 <code>java.util.concurrent.atomic</code> 包中。它允许在多线程环境中对 <code>long</code> 值进行并发累加操作，并支持自定义的累加函数。</p>
<p>以下是一个简单的 <code>LongAccumulator</code> 使用示例，演示如何在多线程环境中安全地进行累加操作。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAccumulator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAccumulatorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 LongAccumulator，初始值为 0，使用加法作为累加函数</span></span><br><span class="line">        LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator(Long::sum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程进行累加操作</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                accumulator.accumulate(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">101</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">                accumulator.accumulate(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">201</span>; i &lt;= <span class="number">300</span>; i++) &#123;</span><br><span class="line">                accumulator.accumulate(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">            thread3.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最终结果</span></span><br><span class="line">        <span class="keyword">long</span> result = accumulator.get();</span><br><span class="line">        System.out.println(<span class="string">"最终累加结果: "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>创建 <code>LongAccumulator</code></strong>：</p>
<ul>
<li>使用 <code>Long::sum</code> 作为累加函数，初始值为 <code>0</code>。</li>
</ul>
</li>
<li><p><strong>创建多个线程</strong>：</p>
<ul>
<li>每个线程对不同范围的整数进行累加。</li>
</ul>
</li>
<li><p><strong>启动线程</strong>：</p>
<ul>
<li>启动所有线程并等待它们完成。</li>
</ul>
</li>
<li><p><strong>获取结果</strong>：</p>
<ul>
<li>使用 <code>accumulator.get()</code> 获取最终的累加结果，并打印出来。</li>
</ul>
</li>
</ol>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行上述代码后，您将看到输出的最终累加结果，该结果是所有线程累加的值之和。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>LongAccumulator</code> 是线程安全的，适用于高并发场景。</li>
<li>可以根据需要自定义累加函数，例如使用乘法、最大值、最小值等操作。只需替换 <code>Long::sum</code> 为相应的函数即可。</li>
</ul>
<p>这个示例展示了如何使用 <code>LongAccumulator</code> 进行并发累加，您可以根据具体需求进行扩展和修改。</p>
<p>对象由对象头，实例数据，对齐填充组成，而对象头又由mark word（8字节），类型指针（8字节），数组长度组成</p>
<h3 id="LongAdder源码"><a href="#LongAdder源码" class="headerlink" title="LongAdder源码"></a>LongAdder源码</h3><h4 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>
<h4 id="缓存行伪共享"><a href="#缓存行伪共享" class="headerlink" title="缓存行伪共享"></a>缓存行伪共享</h4><p>@Contended. 解决缓存行伪共享</p>
<p>一个缓存行可以放2个cell对象。有缓存行伪共享问题。 一个失效都跟着失效</p>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组</span></span><br><span class="line">    <span class="comment">// b 为基础值</span></span><br><span class="line">    <span class="comment">// x 为累加值</span></span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">    <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span></span><br><span class="line">    <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// uncontended 表示 cell 没有竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// as 还没有创建</span></span><br><span class="line">            as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 当前线程对应的 cell 还没有</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="longAccumulate"><a href="#longAccumulate" class="headerlink" title="longAccumulate"></a>longAccumulate</h5><p>有竞争时进入if条件,当前线程的 cell 累加失败时执行longAccumulate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,<span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 probe</span></span><br><span class="line">        ThreadLocalRandom.current();</span><br><span class="line">        <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collide 为 true 表示需要扩容</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">// 已经有了 cells</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还没有 cell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span></span><br><span class="line">                <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还没有 cells, 尝试给 cellsBusy 加锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span></span><br><span class="line">            <span class="comment">// 成功则 break;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上两种情况失败, 尝试给 base 累加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h4><p>获取最终结果通过 sum 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h1><p>DateTimeFormatter</p>
<p>String  ( char数组。9以后是字节数组)</p>
<ul>
<li>不可变类的使用 </li>
<li>不可变类设计 </li>
<li>无状态类设计</li>
</ul>
<p>创建副本避免共享。保护性拷贝</p>
<p>和享元模式配合</p>
<p>jdk中享元模式</p>
<p>StringTable </p>
<p>Byte Short Integer Long    valueOf()方法会重用对象。缓存-128-127。大于这个范围才会创建新对象</p>
<p>Character。缓存0-127</p>
<p>Integer 默认缓存-128-127。最小值不能变。最大值能用虚拟机参数改变. -Djava.lang.Integer.IntegerCache.high</p>
<p>Boolean 缓存TRUE FALSE</p>
<p>BigDecimal. BigInteger. 也用到了享元模式</p>
<h1 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h1><h2 id="设置final变量的原理"><a href="#设置final变量的原理" class="headerlink" title="设置final变量的原理"></a>设置final变量的原理</h2><p>分配空间。赋值。final保证其他线程只能看到赋值后的变量</p>
<p>Putfield字节码后有写屏障</p>
<h2 id="获取final变量的原理"><a href="#获取final变量的原理" class="headerlink" title="获取final变量的原理"></a>获取final变量的原理</h2><p>BIPUSH    没超过short类型最大值。直接复制到栈内存中   final</p>
<p>ldc  超过short类型最大值。 final   常量池</p>
<p>getstatic  不加final    效率差</p>
<p>Happens before</p>
<h1 id="单例模式写法"><a href="#单例模式写法" class="headerlink" title="单例模式写法"></a>单例模式写法</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><p>静态字段直接new对象</p>
<p>枚举</p>
<h2 id="懒汉"><a href="#懒汉" class="headerlink" title="懒汉"></a>懒汉</h2><p>Synchronized 直接加在方法上</p>
<p>双重检查锁</p>
<p>静态内部类</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>七大参数</strong></p>
<ol>
<li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li>
<li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li>
<li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li>
<li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li>
<li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li>
<li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol>
<li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li>
<li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li>
<li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li>
<li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li>
</ol>
</li>
</ol>
<h2 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a>Executors工具类</h2><p>Executors 工厂方法 可以创建四种线程池,</p>
<ol>
<li><p>有缺陷不建议生产上使用可能会发生内存溢出(阻塞队列任务过多或者创建线程数过多)</p>
</li>
<li><p>自己简单测试无所谓,可以使用</p>
</li>
</ol>
<h3 id="单线程池"><a href="#单线程池" class="headerlink" title="单线程池"></a>单线程池</h3><h3 id="固定大小线程池"><a href="#固定大小线程池" class="headerlink" title="固定大小线程池"></a>固定大小线程池</h3><h3 id="带缓冲线程池"><a href="#带缓冲线程池" class="headerlink" title="带缓冲线程池"></a>带缓冲线程池</h3><p>核心线程是0。非核心线程Integer.MAX_VALUE </p>
<p>SynchronousQueue</p>
<p>来任务就创建新线程</p>
<p>60s</p>
<h3 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h3><p>阻塞队列用DelayQueue.   内部PriorityQueue 而PriorityQueue是基于数组实现的堆。每次增加一个任务时间复杂度O(log n)</p>
<p>时间轮 O(1)。循环队列+链表</p>
<p>Timer 单线程  会有很大可能延迟。出现异常,剩下的任务都不能执行了</p>
<h4 id="延迟执行任务"><a href="#延迟执行任务" class="headerlink" title="延迟执行任务"></a>延迟执行任务</h4><h5 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h5><p>调整核心线程数大小和sleep时间测试 </p>
<p>核心线程数比提交任务大 任务延迟互不影响</p>
<p>核心线程数设置为1时,延迟受上一个提交任务的完成时间影响(取最大值)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        pool.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"task1"</span>);</span><br><span class="line">                <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">                sleep (<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"error:"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        pool.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"task2"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"error:"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h4 id="定时执行任务"><a href="#定时执行任务" class="headerlink" title="定时执行任务"></a>定时执行任务</h4><h5 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h5><p>取任务执行时间和延时时间最大值作为下一个任务的执行时间,和核心线程数的设置无关,核心线程数足够大也是这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">"start..."</span>);</span><br><span class="line">        pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            sleep (<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">"running..."</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h5 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h5><p>任务完成后再延时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        pool.scheduleWithFixedDelay (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"task1"</span>);</span><br><span class="line">                <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">                sleep (<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"error:"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                              <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>shutdown</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shutdownNow</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务列表作为返回值,并将队列中的任务清空</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 打断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tomcat线程池</p>
<p>可以自定义拒绝策略</p>
<ol>
<li>死等</li>
</ol>
<p>2) 带超时等待</p>
<p>3) 让调用者放弃任务执行</p>
<p>4) 让调用者抛出异常</p>
<p>5) 让调用者自己执行任务</p>
<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><p>非线程安全集合</p>
<h2 id="并发丢数据"><a href="#并发丢数据" class="headerlink" title="并发丢数据"></a>并发丢数据</h2><p>1.7,1.8  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">"a"</span>, <span class="keyword">new</span> Object()); <span class="comment">// 97  =&gt; 1</span></span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">"1"</span>, <span class="keyword">new</span> Object()); <span class="comment">// 49 =&gt; 1</span></span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println (map.size ());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以正常方式运行,可能不会出现问题</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190849514.png" alt="image-20240819084922235"></p>
<h3 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h3><p>在HashMap源码中加入条件断点</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190851685.png" alt="image-20240819085111412"></p>
<p>再依次走完线程t1,t2, 此时数据会覆盖</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408190852270.png" alt="image-20240819085248093"></p>
<h2 id="并发死链"><a href="#并发死链" class="headerlink" title="并发死链"></a>并发死链</h2><p>1.7头插法,1.8 尾插法。用1.7会出现并发死链问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试 java 7 中哪些数字的 hash 结果相等</span></span><br><span class="line">        System.out.println(<span class="string">"长度为16时，桶下标为1的key"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash(i) % <span class="number">16</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"长度为32时，桶下标为1的key"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash(i) % <span class="number">32</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1, 35, 16, 50 当大小为16时，它们在一个桶内</span></span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">// 放 12 个元素</span></span><br><span class="line">        map.put(<span class="number">2</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">10</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">16</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">35</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"扩容前大小[main]:"</span>+map.size());</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">                map.put(<span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">                System.out.println(<span class="string">"扩容后大小[Thread-0]:"</span>+map.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">                map.put(<span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">                System.out.println(<span class="string">"扩容后大小[Thread-1]:"</span>+map.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>先加入12个元素,还没有触发扩容,当加入第13个元素时触发扩容,而此时有2个线程都要执行扩容操作</p>
<p>如果是单线程扩容最后结果</p>
<p>扩容前1号插槽</p>
<p>1-&gt;35-&gt;16</p>
<p>扩容后1号插槽</p>
<p>35-&gt;1</p>
<h3 id="debug调试-1"><a href="#debug调试-1" class="headerlink" title="debug调试"></a>debug调试</h3><p>Hashmap源码 transfer方法加条件断点</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191958517.png" alt="image-20240819195847384"></p>
<p>断点1条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newTable.length==<span class="number">32</span>&amp;&amp;</span><br><span class="line">        (</span><br><span class="line">Thread.currentThread ().getName ().equals (<span class="string">"Thread-0"</span>)||</span><br><span class="line">        Thread.currentThread ().getName ().equals (<span class="string">"Thread-1"</span>)      </span><br><span class="line">                )</span><br></pre></td></tr></table></figure>
<p>断点2条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread ().getName ().equals (<span class="string">"Thread-0"</span>)</span><br></pre></td></tr></table></figure>
<p>程序先停在断点1处,2个线程都会执行扩容操作,然后让线程1停在第二个断点处,线程2走完扩容操作</p>
<p>线程1的e和next变量</p>
<p>扩容前</p>
<p>e 1-&gt;35-&gt;16</p>
<p>next 35-&gt;16</p>
<p>扩容后</p>
<p>e   1-&gt;null </p>
<p>next   35-&gt;1-&gt;null</p>
<p>这时候HashMap中table已经是线程2扩容后的table,但线程1还没走完扩容操作,在这个场景下,for循环3次就出现了死循环链表,如下图所示</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408192010738.png" alt="image-20240819201054506"></p>
<h1 id="ConcurrenthashMap源码"><a href="#ConcurrenthashMap源码" class="headerlink" title="ConcurrenthashMap源码"></a>ConcurrenthashMap源码</h1><h2 id="JDK-7-ConcurrentHashMap"><a href="#JDK-7-ConcurrentHashMap" class="headerlink" title="JDK 7 ConcurrentHashMap"></a>JDK 7 ConcurrentHashMap</h2><p>它维护了一个 segment 数组，每个 segment 对应一把锁 </p>
<ul>
<li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的 </li>
<li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化 </li>
</ul>
<h3 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        		concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// segmentShift 默认是 32 - 4 = 28</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="comment">// segmentMask 默认是 15 即 0000 0000 0000 1111</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        		initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        		++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        		cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 创建 segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">        (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment </p>
<p>例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位</p>
<h3 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h3><p>新增操作发生在扩容之后</p>
<p>segment继承ReentrantLock. put</p>
<h3 id="rehash-流程"><a href="#rehash-流程" class="headerlink" title="rehash 流程"></a>rehash 流程</h3><p>rehash是扩容时调用的方法</p>
<p>发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全</p>
<p>一部分直接移动。一部分新建</p>
<h3 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h3><p>get 时并未加锁，用了 UNSAFE 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新<br>表取内容</p>
<h3 id="size-计算流程"><a href="#size-计算流程" class="headerlink" title="size 计算流程"></a>size 计算流程</h3><ul>
<li>计算元素个数前，先不加锁计算两次，如果前后两次结果一样，认为个数正确返回 </li>
<li>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</li>
</ul>
<h2 id="JDK-8-ConcurrentHashMap"><a href="#JDK-8-ConcurrentHashMap" class="headerlink" title="JDK 8 ConcurrentHashMap"></a>JDK 8 ConcurrentHashMap</h2><h3 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="构造器分析-1"><a href="#构造器分析-1" class="headerlink" title="构造器分析"></a>构造器分析</h3><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p>
<p>get流程</p>
<p>put流程</p>
<p>默认覆盖</p>
<p>链表为单位扩容。发现-1 锁住链表头帮助扩容</p>
<h3 id="size-计算流程-1"><a href="#size-计算流程-1" class="headerlink" title="size 计算流程"></a>size 计算流程</h3><p>size 计算实际发生在 put，remove 改变集合元素的操作之中 </p>
<ul>
<li>没有竞争发生，向 baseCount 累加计数 </li>
<li><p>有竞争发生，新建 counterCells，向其中的一个 cell 累加计数 </p>
</li>
<li><ul>
<li>counterCells 初始有两个 cell </li>
<li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li>
</ul>
</li>
</ul>
<p>有误差。不是精确值(在计算过程中其他线程可能有操作影响)</p>
<p>transfer扩容</p>
<p>computeIfAbsent</p>
<p>1.7。 Reentrantlock. 16个小哈希表</p>
<p>头插法</p>
<p>1.8</p>
<p>尾插法。整个作为一个哈希表</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>thread有threadLocalMap-&gt;Entry数组 Entry有key和value. key是弱引用 指向threadlocal变量 当方法执行完,如果是用的线程池,线程还没有销毁,threadlocal变量是被弱引用指着的可以被垃圾回收,但是key和value还有强引用关系,此时会有内存泄漏</p>
<p><strong>作用</strong></p>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
</ul>
<p><strong>原理</strong></p>
<p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2/3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<p><strong>弱引用 key</strong></p>
<p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p>
<ul>
<li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li>
</ul>
<p><strong>内存释放时机</strong></p>
<ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>
<h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><p>Jol</p>
<p>无锁</p>
<p>偏向锁</p>
<p>轻量锁</p>
<p>重量锁</p>
<p>锁消除 synchronized块中锁的对象是局部变量,没有必要用synchronized</p>
<p>锁粗化  连续的synchronized块 并且锁的都是一个对象</p>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>ReentrantReadWriteLock</p>
<p>写锁降级</p>
<p>StampedLock.  升级</p>
<h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一种新的线程池</p>
<p>任务拆分。合并</p>
<p>提交给ForkJoin线程池的任务需要继承RecursiveTask或者RecursiveAction</p>
<p>RecursiveTask有返回值</p>
<p>RecursiveAction无返回值</p>
<p>二者都继承了ForkJoinTask</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>加入ForkJoinPool的任务类AddTask1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask1</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTask1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;"</span> + n + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"join() &#123;&#125;"</span>, n);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        AddTask1 t1 = <span class="keyword">new</span> AddTask1(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        t1.fork();</span><br><span class="line">        log.debug(<span class="string">"fork() &#123;&#125; + &#123;&#125;"</span>, n, t1);</span><br><span class="line">        <span class="keyword">int</span> result = n + t1.join();</span><br><span class="line">        log.debug(<span class="string">"join() &#123;&#125; + &#123;&#125; = &#123;&#125;"</span>, n, t1, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">        System.out.println(pool.invoke(<span class="keyword">new</span> AddTask1(<span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.851</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - fork() <span class="number">2</span> + &#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.851</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - fork() <span class="number">4</span> + &#123;<span class="number">3</span>&#125;</span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.851</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - fork() <span class="number">5</span> + &#123;<span class="number">4</span>&#125;</span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.851</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>] - fork() <span class="number">3</span> + &#123;<span class="number">2</span>&#125;</span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">1</span></span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">2</span> + &#123;<span class="number">1</span>&#125; = <span class="number">3</span></span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>] - join() <span class="number">3</span> + &#123;<span class="number">2</span>&#125; = <span class="number">6</span></span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - join() <span class="number">4</span> + &#123;<span class="number">3</span>&#125; = <span class="number">10</span></span><br><span class="line"><span class="number">22</span>:<span class="number">17</span>:<span class="number">00.853</span> c.AddTask [ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - join() <span class="number">5</span> + &#123;<span class="number">4</span>&#125; = <span class="number">15</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>AbstractQueuedSynchronizer的重要属性有</p>
<ul>
<li>private volatile int state;</li>
<li>private transient volatile Node head;</li>
<li>private transient volatile Node tail;</li>
</ul>
<p>两个内部类<strong>Node</strong>,<strong>ConditionObject</strong></p>
<ol>
<li><p>Node的prev,next和AQS自身的head,tail组成双向链表EntryList</p>
</li>
<li><p>ConditionObject自己维护Node类型引用firstWaiter,lastWaiter.和Node的nextWaiter字段构成单向链表WaitSet</p>
</li>
</ol>
<h3 id="EntryList"><a href="#EntryList" class="headerlink" title="EntryList"></a>EntryList</h3><p>AbstractQueuedSynchronizer有一个静态内部类Node,属性有</p>
<ul>
<li>volatile Thread thread;</li>
<li>volatile Node prev;</li>
<li>volatile Node next;</li>
<li>volatile int waitStatus;</li>
<li>Node nextWaiter;</li>
</ul>
<p>EntryList用prev,next</p>
<p>WaitSet用nextWaiter</p>
<h3 id="WaitSet"><a href="#WaitSet" class="headerlink" title="WaitSet"></a>WaitSet</h3><p>内部类ConditionObject,条件变量来实现等待、唤醒机制，支持多个条件变量</p>
<h3 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h3><ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁 <ul>
<li>getState - 获取 state 状态 </li>
<li>setState - 设置 state 状态 </li>
<li>compareAndSetState - cas 机制设置 state 状态 </li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
</ul>
<h3 id="需要子类实现的方法"><a href="#需要子类实现的方法" class="headerlink" title="需要子类实现的方法"></a>需要子类实现的方法</h3><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException） </p>
<ul>
<li>tryAcquire </li>
<li>tryRelease </li>
<li>tryAcquireShared </li>
<li>tryReleaseShared </li>
<li>isHeldExclusively</li>
</ul>
<h3 id="获取锁的姿势"><a href="#获取锁的姿势" class="headerlink" title="获取锁的姿势"></a>获取锁的姿势</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">     <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="释放锁的姿势"><a href="#释放锁的姿势" class="headerlink" title="释放锁的姿势"></a>释放锁的姿势</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">   <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现不可重入锁"><a href="#实现不可重入锁" class="headerlink" title="实现不可重入锁"></a>实现不可重入锁</h2><p>acquire调用tryAcquire,tryAcquire判断失败进入EntryList</p>
<p>release调用tryRelease,tryRelease成功唤醒EntryList上节点</p>
<h3 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占锁  同步器类</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">              <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isHeldExclusively())&#123;</span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">          setState(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h3><p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 释放锁  会唤醒线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 生成条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"locking..."</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"unlocking..."</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"locking..."</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"unlocking..."</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>AQS 要实现的功能目标 </p>
<ul>
<li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire </li>
<li>获取锁超时机制</li>
<li>通过打断取消机制 </li>
<li>独占机制及共享机制 </li>
<li>条件不满足时的等待机制 </li>
</ul>
<p>要点 </p>
<ul>
<li>原子维护 state 状态 </li>
<li>阻塞及恢复线程 </li>
<li>维护队列 </li>
</ul>
<p>阻塞恢复设计 </p>
<ul>
<li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细 </li>
<li>park 线程还可以通过 interrupt 打断</li>
</ul>
<p>队列设计 </p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/393192/1650080165361-18864833-42e6-47a3-beb0-d97886e8fe71.png" alt="img"></p>
<p><a href="https://cloud.tencent.com/developer/article/2031273" target="_blank" rel="noopener">ConditionObject源码解析</a></p>
<p>自定义锁</p>
<p>用AQS实现 的并发工具类</p>
<p>静态内部类Sync</p>
<p> FairSync</p>
<p>NonFairSync</p>
<p>Sync引用</p>
<h1 id="ReentrantLock源码。"><a href="#ReentrantLock源码。" class="headerlink" title="ReentrantLock源码。"></a>ReentrantLock源码。</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408201047785.png" alt="image-20240820104721523"></p>
<p>超时 打断 多条件变量 公平锁</p>
<h2 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h2><p>默认非公平</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NonfairSync 继承自 AQS </p>
<h3 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p>ReentrantLock.lock()直接调用NonfairSync.lock()</p>
<p>NonfairSync#lock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>加锁成功</strong>,设置state为1,exclusiveOwnerThread字段设置为加锁成功线程</p>
</li>
<li><p><strong>加锁失败</strong>,走else分支,调用acquire(1)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h5><ul>
<li>tryAcquire尝试加锁,最后调用nonfairTryAcquire(),如果state=0,尝试设置为1.state=1就看持有锁的是否是自己,是自己就走重入锁逻辑进行加锁,不是则返回false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h5><ul>
<li><p>tryAcquire失败先调用addWaiter创建Node节点加入双向链表,head和tail是NonfairSync中的字段,</p>
<p>head指向哨兵节点(节点没有线程,Node节点的thread字段是null),</p>
<p>tail指向最后一个节点,也就是当前节点(Node节点的thread字段是当前线程)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><ul>
<li><p>创建完Node节点后调用acquireQueued,这个时候先看一下自己所在的节点是不是head节点的后继,是的话再尝试加锁,失败了就调用shouldParkAfterFailedAcquire</p>
<ul>
<li><p>shouldParkAfterFailedAcquire将前驱节点waitStatus设置为-1,这次返回false.</p>
<p>再次尝试加锁,如果又失败这次shouldParkAfterFailedAcquire返回true,调用parkAndCheckInterrupt</p>
</li>
<li><p>parkAndCheckInterrupt 将现在的线程阻塞,处于waiting状态,可以被打断,</p>
<p>打断后调用interrupted清除打断标记,防止下次park会失败</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h6><p>下面是shouldParkAfterFailedAcquire,首先看前驱的waitStatus字段值,前驱是CANCELLED状态才大于0其他状态都小于0,</p>
<ol>
<li>如果前驱是CANCELLED状态,就找前面第一个不是取消状态的节点,设置不是取消状态的节点为当前节点的前驱,</li>
</ol>
<p>​        并且设置不是取消状态的节点后继为当前节点,忽略那些取消的节点</p>
<ol>
<li><p>设置前驱节点waitStatus字段值为SIGNAL,也就是-1,</p>
<p>如果进入时已经是-1直接返回true,否则返回false</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>waitStatus状态值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h6 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解锁流程"><a href="#解锁流程" class="headerlink" title="解锁流程"></a>解锁流程</h3><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h4><p>ReentrantLock.unlock()调用AQS的release方法,tryRelease由Sync实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h5><p>tryRelease 流程，如果成功 </p>
<ul>
<li>设置 exclusiveOwnerThread 为 null </li>
<li>state = 0</li>
</ul>
<p>tryRelease 流程，失败情况</p>
<ul>
<li><p>如果不是持有锁的线程解锁抛异常</p>
</li>
<li><p>可重入锁解锁state!=0就返回false</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h5><p>传入head指向的节点,唤醒下一个没有取消的节点</p>
<ol>
<li><p>通常是head指向节点的后继,执行unpark唤醒</p>
</li>
<li><p>如果后继取消,就从tail指向节点从后向前找head指向的第一个waitStatus不为CANCEL的Node节点,执行unpark唤醒</p>
</li>
<li>如果没有找到,则不执行unpark</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="解锁竞争成功"><a href="#解锁竞争成功" class="headerlink" title="解锁竞争成功"></a>解锁竞争成功</h4><ul>
<li>线程之前阻塞在parkAndCheckInterrupt,线程被唤醒的情况</li>
</ul>
<ol>
<li><p>可能是被打断,此时设置interrupted = true</p>
</li>
<li><p>解锁调用unpark</p>
</li>
</ol>
<ul>
<li>唤醒后再次尝试加锁,假设加锁成功<ul>
<li>断开之前的头节点,设置当前节点是头节点,并且当前节点thread字段设置为null</li>
<li>设置failed=false,返回打断标记(记录是否被打断过)</li>
</ul>
</li>
</ul>
<h4 id="解锁竞争失败"><a href="#解锁竞争失败" class="headerlink" title="解锁竞争失败"></a>解锁竞争失败</h4><p>非公平锁,可能有新来的线程还未加入EntryList直接加锁成功,导致被唤醒的线程尝试加锁失败,再次陷入阻塞</p>
<p>在acquireQueued的for循环中产生了异常,并且failed=true,则取消当前节点在EntryList的等待,调整链表结构</p>
<p>取消的逻辑代码</p>
<p>从当前节点向前找第一个waitStatus不是取消状态的节点,判断这个不是取消状态的节点waitStatus是不是-1,</p>
<p>是的话调整链表结构 不是取消状态的节点后继设置为当前节点的后继</p>
<p>不是就唤醒当前节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h2><p>通过state计数的增加减少来实现可重入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state-- </span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h2><h4 id="不可打断模式-默认"><a href="#不可打断模式-默认" class="headerlink" title="不可打断模式 (默认)"></a>不可打断模式 (默认)</h4><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p>
<p>被打断时只是记录下被打断过,等获得锁以后才继续向下运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h4><p>加锁过程可打断。被打断时直接抛 InterruptedException</p>
<p>Reentraantlock.lockInterruptibly()调用acquireInterruptibly</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="超时原理"><a href="#超时原理" class="headerlink" title="超时原理"></a>超时原理</h2><p>ReentrantLock调用带超时时间的tryLock方法,加锁过程支持超时,支持打断</p>
<h3 id="tryLock-timeout-unit"><a href="#tryLock-timeout-unit" class="headerlink" title="tryLock(timeout,unit)"></a>tryLock(timeout,unit)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tryAcquireNanos"><a href="#tryAcquireNanos" class="headerlink" title="tryAcquireNanos"></a>tryAcquireNanos</h4><p>先调用tryAcquire尝试加锁,加锁失败调用doAcquireNanos</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="doAcquireNanos"><a href="#doAcquireNanos" class="headerlink" title="doAcquireNanos"></a>doAcquireNanos</h5><p>创建Node节点,放到EntryList最后一个节点</p>
<p>和之前最大区别在于<code>LockSupport.parkNanos(this, nanosTimeout);</code></p>
<p>所以在加锁过程中支持超时,同样在源码中也可看出加锁过程支持打断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h2><p>队列外线程发现 队列中有等待线程那就不会直接抢占锁, 并入队; 从而先到先得,彰显公平</p>
<p>与非公平锁主要区别在于 tryAcquire 方法的实现,先检查 AQS 队列中是否有前驱节点, 没有才去竞争</p>
<h3 id="tryAcquire-1"><a href="#tryAcquire-1" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408201757013.png" alt="image-20240820175724751"></p>
<h4 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            (</span><br><span class="line">            <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">            s.thread != Thread.currentThread()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">(s = h.next) == null</font> 这个条件成立是其他线程在<strong>enq</strong>方法中执行完<code>compareAndSetTail(t, node)</code>,还没有执行<code>t.next = node;</code></p>
<p>这时满足head和tail指向不同节点,但是head.next还没设置,所以<strong>head.next=null</strong></p>
<p><strong>hasQueuedPredecessors</strong>返回true表示其他线程获取锁优先级高(先进入EntryList),可以实现按先进入EntryList的线程先获取锁,实现公平</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>ConditionObject</p>
<h3 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">long</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h4><p>创建Node节点,设置waitStatus=CONDITION(waitStatus=-2),</p>
<ol>
<li><p>如果ConditionObject之前没有节点,就把firstWaiter指向当前节点,</p>
</li>
<li><p>lastWaiter指向当前节点</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// 所有已取消的 Node 从队列链表删除</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="WaitSet和EntryList的区别"><a href="#WaitSet和EntryList的区别" class="headerlink" title="WaitSet和EntryList的区别"></a>WaitSet和EntryList的区别</h5><ol>
<li>EntryList双向链表,WaitSet单向链表</li>
<li>EntryList的head指向哨兵节点,WaitSet的firstWaiter指向真正节点</li>
<li>EntryList中head==tail时说明EntryList没有节点,而firstWaiter==lastWaiter可能没有节点或者有一个节点</li>
<li>一般情况下,EntryList中Node节点waitStatus除了最后一个节点是0,其他都是-1;WaitSet中Node节点waitStatus=-2</li>
<li>EntryList中新加入Node节点要把之前最后一个节点的waitStatus设置为-1(如果最后一个节点的waitStatus是取消,就不设置),</li>
<li>WaitSet只是将节点放到最后一个位置</li>
</ol>
<h4 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h4><p>解锁并唤醒EntryList中的Node节点代表的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> savedState = getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="park"><a href="#park" class="headerlink" title="park"></a>park</h4><p>调用<code>LockSupport.park(this)</code>使当前线程陷入阻塞</p>
<h4 id="acquireQueued-1"><a href="#acquireQueued-1" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><ul>
<li><p>线程在park过程中被打断</p>
</li>
<li><p>持有锁线程解锁 会执行unpack</p>
</li>
<li><p>在signal流程的transferForSignal过程中最后一个if条件满足会执行unpack</p>
</li>
</ul>
<p>在遇到上述情况后线程继续执行acquireQueued尝试获取锁</p>
<h3 id="signal流程"><a href="#signal流程" class="headerlink" title="signal流程"></a>signal流程</h3><p>signal判断当前线程是否持有锁(有权限),没有就抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h4><p>判断当前线程持有锁调用doSignal方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span></span><br><span class="line">            !transferForSignal(first) &amp;&amp;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            (first = firstWaiter) != <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h6><p>transferForSignal把WaitSet第一个节点转移到EntryList最后一个节点,</p>
<p>如果当前节点是取消状态(超时),就尝试把WaitSet下一个节点转移到EntryList最后一个节点</p>
<p>如果加入EntryList后发现前驱被取消或者前驱的waitStatus设置-1失败,就唤醒这个节点的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 上一个节点被取消</span></span><br><span class="line">            ws &gt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">            !compareAndSetWaitStatus(p, ws, Node.SIGNAL) </span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p>读写锁ReentrantReadWriteLock并不是读写分离，它只允许读读共存，而读写和写写依然是互斥的， 大多实际场景是“读/读”线程间并不存在互斥关系，只有”读/写”线程或”写/写”线程间的操作需要互斥的。因此引入ReentrantReadWriteLock</p>
<p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select …<br>from … lock in share mode</p>
<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"获取读锁..."</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"读取"</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"释放读锁..."</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"获取写锁..."</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"写入"</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"释放写锁..."</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试 读锁-读锁 可以并发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.read();</span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.read();</span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">05.970</span> c.DataContainer [t2] - 获取读锁...</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">05.970</span> c.DataContainer [t1] - 获取读锁...</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">05.971</span> c.DataContainer [t2] - 读取</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">05.971</span> c.DataContainer [t1] - 读取</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">06.974</span> c.DataContainer [t1] - 释放读锁...</span><br><span class="line"><span class="number">16</span>:<span class="number">54</span>:<span class="number">06.975</span> c.DataContainer [t2] - 释放读锁...</span><br></pre></td></tr></table></figure>
<p>测试 读锁-写锁 相互阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.read();</span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.write();</span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">测试 写锁-写锁 相互阻塞</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.write();</span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">dataContainer.write();</span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读锁不支持条件变量,写锁支持条件变量</span><br><span class="line"></span><br><span class="line">重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</span><br><span class="line"></span><br><span class="line">重入时降级支持：即持有写锁的情况下去获取读锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以先获得写锁再获得读锁</span><br><span class="line"></span><br><span class="line">不可以先获得读锁再获得写锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">写锁降级为读锁</span><br><span class="line"></span><br><span class="line">(获取写锁 操作 获取读锁 释放写锁 释放读锁)</span><br><span class="line"></span><br><span class="line">持有写锁的线程可能执行写操作后,还有一些读取操作,当前线程希望拿到的数据是最新的,这个时候可以降级成为读锁,不影响当前线程获取最新数据,同时其他想获取读锁的读线程不会阻塞,提高了并发度.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ReentrantReadWriteLock原理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">默认非公平</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 <span class="number">16</span> 位，而读锁</span><br><span class="line">使用的是 state 的高 <span class="number">16</span> 位</span><br><span class="line"></span><br><span class="line">t2 执行 r.lock，这时进入读锁的 sync.acquireShared(<span class="number">1</span>) 流程，首先会进入 tryAcquireShared 流程。如果有写</span><br><span class="line">锁占据，那么 tryAcquireShared 返回 -<span class="number">1</span> 表示失败</span><br><span class="line"></span><br><span class="line">tryAcquireShared 返回值表示</span><br><span class="line">-<span class="number">1</span> 表示失败</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> 表示成功，但后继节点不会继续唤醒</span><br><span class="line">正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>和大于<span class="number">1</span>会在信号量Semaphore用到,在这里就是-<span class="number">1</span>表示失败,<span class="number">1</span>表示成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-<span class="number">1</span>改成<span class="number">0</span>避免其他线程的干扰</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读锁-读锁并发原理</span><br><span class="line"></span><br><span class="line">如果此时加的是读锁,可以继续加读锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解锁时会唤醒在EntryList的线程</span><br><span class="line"></span><br><span class="line">获取读锁线程被唤醒时可以看它所在节点的下一个是不是共享类型的节点(获取读锁的线程),如果是可以把它表示的线程唤醒,被唤醒的线程可以继续执行这个操作,直到遇到了不是共享类型的节点或者已经到了链表尾部</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读锁可重入</span><br><span class="line"></span><br><span class="line">`cachedHoldCounter` 是一个用于缓存当前线程持有的读锁数量的计数器</span><br><span class="line"></span><br><span class="line">获取读锁的操作会增加该计数器，而释放读锁的操作会减少该计数器。通过使用 `cachedHoldCounter`，可以快速检查当前线程持有的读锁数量，而不必每次都去查找更复杂的数据结构（如 `readHolds`）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">readHolds用于存储每个线程持有的读锁数量。每个线程都有自己独立的 `readHolds` 实例</span><br><span class="line"></span><br><span class="line">- `cachedHoldCounter` 主要用于优化性能，通过缓存当前线程持有的读锁数量，减少对readHolds的访问。</span><br><span class="line">- `readHolds` 则用于实现线程安全的读锁计数，支持可重入性，确保每个线程能够正确管理其持有的读锁数量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">写锁上锁流程</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 尝试获得写锁失败</span></span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">            <span class="comment">// 进入 AQS 队列阻塞</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得低 16 位, 代表写锁的 state 计数</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// c != 0 and w == 0 表示有读锁, 或者</span></span><br><span class="line">                w == <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">// 如果 exclusiveOwnerThread 不是自己</span></span><br><span class="line">                current != getExclusiveOwnerThread()</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 获得锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写锁计数超过低 16 位, 报异常</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 写锁重入, 获得锁成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 判断写锁是否该阻塞, 或者</span></span><br><span class="line">            writerShouldBlock() ||</span><br><span class="line">            <span class="comment">// 尝试更改计数失败</span></span><br><span class="line">            !compareAndSetState(c, c + acquires)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 获得锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁成功</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写锁释放流程"><a href="#写锁释放流程" class="headerlink" title="写锁释放流程"></a>写锁释放流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试释放写锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// unpark AQS 中等待的线程</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">        <span class="comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free) &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读锁上锁流程"><a href="#读锁上锁流程" class="headerlink" title="读锁上锁流程"></a>读锁上锁流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果是其它线程持有写锁, 获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> ( </span><br><span class="line">            exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span></span><br><span class="line">            !readerShouldBlock() &amp;&amp;</span><br><span class="line">            <span class="comment">// 小于读锁计数, 并且</span></span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            <span class="comment">// 尝试增加计数成功</span></span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span></span><br><span class="line">    <span class="comment">// true 则该阻塞, false 则不阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再一次尝试获取读锁</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ㈠</span></span><br><span class="line">                        <span class="comment">// r 表示可用资源数, 在这里总是 1 允许传播</span></span><br><span class="line">                        <span class="comment">//（唤醒 AQS 中下一个 Share 节点）</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 当前线程</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 设置自己为 head</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">        <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) &#123;</span><br><span class="line">                <span class="comment">// 进入 ㈡</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 下一个节点 unpark 如果成功获取读锁</span></span><br><span class="line">                    <span class="comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读锁释放流程"><a href="#读锁释放流程" class="headerlink" title="读锁释放流程"></a>读锁释放流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                <span class="comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span></span><br><span class="line">                <span class="comment">// 计数为 0 才是真正释放</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE </span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span></span><br><span class="line">                <span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写锁线程饥饿</p>
<p>一旦读操作比较多的时候，想要获取写锁就变得比较困难了，假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了 因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写</p>
<p>非公平模式,当前是持有读锁,那在EntryList外面的想获取读锁的线程可以直接获取读锁,但写锁只能等读锁释放</p>
<p>可以用公平读写锁,但会降低效率,如果写锁线程饥饿问题严重可以考虑用StampedLock</p>
<h1 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h1><p>StampedLock(后面详细讲解)，会发现它改进之处在于：读的过程中也允许获取写锁介入(相当牛B，读和写两个操作也让你“共享”(注意引号))，这样会导致我们读的数据就可能不一致！所以，需要额外的方法来判断读的过程中是否有写入，这是一种乐观的读锁，O(∩_∩)O哈哈~。 显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行</p>
<p>StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化。</p>
<p>进一步优化读性能</p>
<p>邮戳锁 - 也叫票据锁</p>
<h3 id="它是由锁饥饿问题引出"><a href="#它是由锁饥饿问题引出" class="headerlink" title="它是由锁饥饿问题引出"></a>它是由锁饥饿问题引出</h3><p>可以解决写锁线程饥饿</p>
<h4 id="StampedLock有三种访问模式"><a href="#StampedLock有三种访问模式" class="headerlink" title="StampedLock有三种访问模式"></a>StampedLock有三种访问模式</h4><ol>
<li>Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似</li>
<li>Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似</li>
<li>Optimistic reading（乐观读模式）：无锁机制，类似于数据库中的乐观锁，很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式</li>
</ol>
<p>ReentrantReadWriteLock的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。<br>但是，StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，<br>所以，在获取乐观读锁后，还需要对结果进行校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">"=====写线程准备修改"</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            number = number + <span class="number">13</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">"=====写线程结束修改"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.readLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t come in readlock block,4 seconds continue..."</span>);</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 正在读取中......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> result = number;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">" 获得成员变量值result："</span> + result);</span><br><span class="line">            System.out.println(<span class="string">"写线程没有修改值，因为 stampedLock.readLock()读的时候，不可以写，读写互斥"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乐观读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryOptimisticRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">int</span> result = number;</span><br><span class="line">        <span class="comment">//间隔4秒钟，我们很乐观的认为没有其他线程修改过number值，实际靠判断。</span></span><br><span class="line">        System.out.println(<span class="string">"4秒前stampedLock.validate值(true无修改，false有修改)"</span>+<span class="string">"\t"</span>+stampedLock.validate(stamp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 正在读取中......"</span>+i+</span><br><span class="line">                    <span class="string">"秒后stampedLock.validate值(true无修改，false有修改)"</span>+<span class="string">"\t"</span></span><br><span class="line">                    +stampedLock.validate(stamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stampedLock.validate(stamp)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"有人动过--------存在写操作！"</span>);</span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"从乐观读 升级为 悲观读"</span>);</span><br><span class="line">                result = number;</span><br><span class="line">                System.out.println(<span class="string">"重新悲观读锁通过获取到的成员变量值result："</span> + result);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t finally value: "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StampedLockDemo resource = <span class="keyword">new</span> StampedLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            resource.read();</span><br><span class="line">            <span class="comment">//resource.tryOptimisticRead();</span></span><br><span class="line">        &#125;,<span class="string">"readThread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2秒钟时乐观读失败，6秒钟乐观读取成功resource.tryOptimisticRead();，修改切换演示</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(6); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            resource.write();</span><br><span class="line">        &#125;,<span class="string">"writeThread"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StampedLock的缺点"><a href="#StampedLock的缺点" class="headerlink" title="StampedLock的缺点"></a>StampedLock的缺点</h3><ul>
<li>StampedLock 不支持重入，没有Re开头</li>
<li>StampedLock 的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。</li>
</ul>
<h1 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h1><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>限制同时访问共享资源的线程上限</p>
<h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">"running..."</span>);</span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">"end..."</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">39</span>:<span class="number">59.977</span> c.TestSemaphore [Thread-<span class="number">0</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">39</span>:<span class="number">59.977</span> c.TestSemaphore [Thread-<span class="number">2</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">39</span>:<span class="number">59.977</span> c.TestSemaphore [Thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.984</span> c.TestSemaphore [Thread-<span class="number">0</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.985</span> c.TestSemaphore [Thread-<span class="number">1</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.984</span> c.TestSemaphore [Thread-<span class="number">2</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.985</span> c.TestSemaphore [Thread-<span class="number">3</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.985</span> c.TestSemaphore [Thread-<span class="number">4</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">00.985</span> c.TestSemaphore [Thread-<span class="number">5</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.988</span> c.TestSemaphore [Thread-<span class="number">5</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.988</span> c.TestSemaphore [Thread-<span class="number">3</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.989</span> c.TestSemaphore [Thread-<span class="number">6</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.989</span> c.TestSemaphore [Thread-<span class="number">8</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.989</span> c.TestSemaphore [Thread-<span class="number">4</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">01.990</span> c.TestSemaphore [Thread-<span class="number">7</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">02.991</span> c.TestSemaphore [Thread-<span class="number">7</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">02.992</span> c.TestSemaphore [Thread-<span class="number">9</span>] - running...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">02.993</span> c.TestSemaphore [Thread-<span class="number">6</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">02.994</span> c.TestSemaphore [Thread-<span class="number">8</span>] - end...</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">03.996</span> c.TestSemaphore [Thread-<span class="number">9</span>] - end...</span><br></pre></td></tr></table></figure>
<h3 id="Semaphore原理"><a href="#Semaphore原理" class="headerlink" title="Semaphore原理"></a>Semaphore原理</h3><p>基于AQS实现</p>
<h4 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h4><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h5><h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>可以复用对象,不像CountDownLatch要重新创建对象</p>
<h3 id="简单使用-2"><a href="#简单使用-2" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, ()-&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"task1, task2 finish..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// task1  task2  task1</span></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"task1 begin..."</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await(); <span class="comment">// 2-1=1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"task2 begin..."</span>);</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await(); <span class="comment">// 1-1=0</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">29.732</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">29.732</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - task2 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">29.732</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - task1 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">30.739</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1, task2 finish...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">30.739</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - task2 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">30.739</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">31.744</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1, task2 finish...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">31.744</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task2 begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">42</span>:<span class="number">33.749</span> c.TestCyclicBarrier [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - task1, task2 finish...</span><br></pre></td></tr></table></figure>
<h3 id="CyclicBarrier原理"><a href="#CyclicBarrier原理" class="headerlink" title="CyclicBarrier原理"></a>CyclicBarrier原理</h3><p>借助ReentrantLock实现,先减,减到0后会唤醒其他等待线程,然后重置计数为初始值</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>parties用于恢复初始值</p>
<p>count是实际减的值,减到0会用parties再重置为初始值</p>
<p>barrierCommand是减到0时执行的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="dowait"><a href="#dowait" class="headerlink" title="dowait"></a>dowait</h4><p>await方法会调用dowait,主要逻辑都在这里</p>
<p>先减,没有减到0时,trip条件变量执行await在WaitSet等待</p>
<p>减到0时</p>
<ol>
<li><p>command.run(). 执行barrierAction任务</p>
</li>
<li><p>nextGeneration  </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="nextGeneration"><a href="#nextGeneration" class="headerlink" title="nextGeneration"></a>nextGeneration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒计时锁,用于线程同步,等待所有线程完成倒计时</p>
<h3 id="简单使用-3"><a href="#简单使用-3" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"begin..."</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">            log.debug(<span class="string">"end...&#123;&#125;"</span>, latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"begin..."</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">            log.debug(<span class="string">"end...&#123;&#125;"</span>, latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"begin..."</span>);</span><br><span class="line">            sleep(<span class="number">1.5</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">            log.debug(<span class="string">"end...&#123;&#125;"</span>, latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"waiting..."</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        log.debug(<span class="string">"wait end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">08.027</span> c.TestCountDownLatch [Thread-<span class="number">0</span>] - begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">08.027</span> c.TestCountDownLatch [Thread-<span class="number">2</span>] - begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">08.027</span> c.TestCountDownLatch [Thread-<span class="number">1</span>] - begin...</span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">08.027</span> c.TestCountDownLatch [main] - waiting...</span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">09.034</span> c.TestCountDownLatch [Thread-<span class="number">0</span>] - end...<span class="number">2</span></span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">09.534</span> c.TestCountDownLatch [Thread-<span class="number">2</span>] - end...<span class="number">1</span></span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">10.031</span> c.TestCountDownLatch [Thread-<span class="number">1</span>] - end...<span class="number">0</span></span><br><span class="line"><span class="number">21</span>:<span class="number">02</span>:<span class="number">10.032</span> c.TestCountDownLatch [main] - wait end...</span><br></pre></td></tr></table></figure>
<h3 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h3><p>基于AQS实现</p>
<p>CountDownLatch实现</p>
<p>tryAcquireShared</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>countDown</p>
<p>state减到0时唤醒EntryList节点的线程</p>
<p>await</p>
<p>state!=0 当前线程在EntryList阻塞</p>
<h1 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h1><p>ConcurrentHashMap</p>
<p>ArrayBlockingQueue.  Object数组。ReentrantLock   notEmpty  notFull条件变量</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>单向链表带哨兵节点dummy  基于ReentrantLock实现</p>
<p>两把锁 putLock takeLock</p>
<p>条件变量 notFull  notEmpty分别由两把锁创建</p>
<h3 id="基本的入队出队"><a href="#基本的入队出队" class="headerlink" title="基本的入队出队"></a>基本的入队出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">          E item;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 下列三种情况之一</span></span><br><span class="line"><span class="comment">          * - 真正的后继节点</span></span><br><span class="line"><span class="comment">          * - 自己, 发生在出队时</span></span><br><span class="line"><span class="comment">          * - null, 表示是没有后继节点, 是最后了</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          Node&lt;E&gt; next;</span><br><span class="line">          Node(E x) &#123; item = x; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Current number of elements */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of linked list.</span></span><br><span class="line"><span class="comment">     * Invariant: head.item == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of linked list.</span></span><br><span class="line"><span class="comment">     * Invariant: last.next == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>初始化LinkedBlockingQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>last = head = new Node<e>(null); Dummy 节点用来占位，item 为 null</e></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221514463.png" alt="image-20240822151419353"></p>
<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><p>当一个节点入队 last = last.next = node;</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221514464.png" alt="image-20240822151440366"></p>
<p>再来一个节点入队 last = last.next = node;</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221515767.png" alt="image-20240822151510677"></p>
<h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; h = head;</span><br><span class="line">Node&lt;E&gt; first = h.next;</span><br><span class="line">h.next = h; <span class="comment">// help GC</span></span><br><span class="line">head = first;</span><br><span class="line">E x = first.item;</span><br><span class="line">first.item = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>
<p>h = head</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221516077.png" alt="image-20240822151621937"></p>
<p>first = h.next</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221517247.png" alt="image-20240822151714116"></p>
<p>h.next = h</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221517407.png" alt="image-20240822151758307"></p>
<p>head = first</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221519084.png" alt="image-20240822151917986"></p>
<p>E x = first.item;<br>first.item = null;<br>return x;</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408221519846.png" alt="image-20240822151941712"></p>
<h3 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h3><p>高明之处在于用了两把锁和 dummy 节点</p>
<ul>
<li><p>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</p>
</li>
<li><p>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p>
<ul>
<li><p>消费者与消费者线程仍然串行</p>
</li>
<li><p>生产者与生产者线程仍然串行</p>
</li>
</ul>
</li>
</ul>
<p>线程安全分析</p>
<ul>
<li><p>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是</p>
<p>head 节点的线程安全。两把锁保证了入队和出队没有竞争</p>
</li>
<li><p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p>
</li>
<li><p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 用户 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>
<p>put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="comment">// count 用来维护元素计数</span></span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 满了等待</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 倒过来读就好: 等待 notFull</span></span><br><span class="line">            notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有空位, 入队且计数加一</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        			putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列中有一个元素, 叫醒 take 线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span></span><br><span class="line">            signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">        		notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    		takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span></span><br><span class="line">    <span class="comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由 put 唤醒 put 是为了避免信号不足,</p>
<p>由 take 唤醒 take 也是为了避免信号不足</p>
</blockquote>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较<br>Linked 支持有界，Array 强制有界<br>Linked 实现是链表，Array 实现是数组<br>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组<br>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的<br>Linked 两把锁，Array 一把锁</p>
<p>ConcurrentLinkedQueue.  单向链表。 cas</p>
<p>CopyOnWriteArrayList</p>
<p>synchronizedList</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM基本概念]]></title>
      <url>/p/8vugi/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408231132321.png" alt="image-20240823113239217"></p>
<p>jmap 工具<br>查看堆内存占用情况 jmap - heap 进程id</p>
<p>jconsole 工具<br>图形界面的，多功能的监测工具，可以连续监测</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/zhangxuefeng/Library/Java/JavaVirtualMachines/corretto-<span class="number">1.8</span>.0_392/Contents/Home</span><br></pre></td></tr></table></figure>
<p>输入jconsole</p>
<p>Jvisualvm </p>
<p>jclasslib</p>
<p>jvm</p>
<p>内存区域 </p>
<p>直接内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_26</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);</span><br><span class="line">        System.out.println(<span class="string">"分配完毕..."</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">"开始释放..."</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 显式的垃圾回收，Full GC</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序</p>
<p>查看活动监视器</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408231623984.png" alt="image-20240823162302862"></p>
<p>按回车执行程序下一段逻辑,触发显示垃圾回收,再查看活动监视器</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408231624360.png" alt="image-20240823162445259"></p>
<p>常量池</p>
<p>运行时常量池</p>
<p>StringTable</p>
<p>调整 -XX:StringTableSize=桶个数</p>
<p>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串<br>池中的对象返回<br>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，<br>放入串池， 会把串池中的对象返回</p>
<p>1.6 intern().   创建再把新创建的对象引用放入串池</p>
<p>1.8. intern(). 将字符串对象引用地址放入StringTable</p>
<h1 id="Jmeter插件安装"><a href="#Jmeter插件安装" class="headerlink" title="Jmeter插件安装"></a>Jmeter插件安装</h1><p>Plugin_Manager.   下载jpgc插件</p>
<p>linux进程最大数</p>
<p>cat /proc/sys/kernel/pid_max</p>
<p>linux线程最大数</p>
<p>cat /proc/sys/kernel/threads_max</p>
<h1 id="线程长时间停顿"><a href="#线程长时间停顿" class="headerlink" title="线程长时间停顿"></a>线程长时间停顿</h1><p>死锁,活锁</p>
<p>死循环</p>
<p>等待资源 ,数据库连接,网络资源,设备资源等</p>
<p>jconsole可以看线程状态,或者自己调用getState()方法</p>
<h1 id="垃圾收集jdk源码"><a href="#垃圾收集jdk源码" class="headerlink" title="垃圾收集jdk源码"></a>垃圾收集jdk源码</h1><p>源码目录src/hotspot/share/gc</p>
<h1 id="增量更新和原始快照"><a href="#增量更新和原始快照" class="headerlink" title="增量更新和原始快照"></a>增量更新和原始快照</h1><p>参考:</p>
<p><a href="https://www.cnblogs.com/hongdada/p/14578950.html" target="_blank" rel="noopener">JVM 三色标记 增量更新 原始快照</a></p>
<h1 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h1><p>场景</p>
<p>新生代垃圾回收,老年代对新生代存在引用关系,如果不扫描老年代,只对GcRoots可达性分析,这样会回收那些跨代引用的对象,造成程序崩溃</p>
<p>Remembered Set 新生代记录 对象对应的一块内存区域(这块区域有对象引用当前对象),这个内存区域的精度由卡表决定,是卡表上的一个卡,也是脏卡</p>
<p>CardTable</p>
<p>以新生代的 Card Table 为例，Card Table 的每一个元素用来 标记 老年代的某一块内存区域（Card Page）的所有对象是否引用了新生代对象。</p>
<p>只要存在一个对象引用了新生代对象，那么将对应 Card Table 的数组元素的值标记为 0，说明这个元素变脏（Dirty）</p>
<p>卡页。512字节</p>
<p>HotSpot源码cardTable.hpp中CardValues枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CardValues &#123;</span><br><span class="line">   clean_card                  = (CardValue)-<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">   dirty_card                  =  <span class="number">0</span>,</span><br><span class="line">   last_card                   =  <span class="number">1</span>,</span><br><span class="line">   CT_MR_BS_last_reserved      =  <span class="number">2</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Write-Barrier"><a href="#Write-Barrier" class="headerlink" title="Write Barrier"></a>Write Barrier</h3><p>既然，Card Table 需要将对应下标的数组元素标记为 0，那么这个标记的操作是怎么进行的呢？</p>
<p>在 HotSpot 中，通过 Write Barrier（写屏障）维护 Card Table 的标记</p>
<p>写前屏障</p>
<p>采用 “先检查，再更新”。</p>
<p>先检查 Card Table 的标记，只有当 Card Table 的元素未被标记过，才会将该元素标记为 0</p>
<p>参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/444691935" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/444691935</a></p>
<h1 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h1><p>参考:</p>
<p><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html" target="_blank" rel="noopener">新一代垃圾回收器ZGC的探索与实践</a></p>
<p><a href="https://blog.csdn.net/a860MHz/article/details/119786593" target="_blank" rel="noopener">OpenJDK16 ZGC 源码分析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/364813270" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/364813270</a></p>
<h1 id="GCRoots"><a href="#GCRoots" class="headerlink" title="GCRoots"></a>GCRoots</h1><ul>
<li>虚拟机栈中本地变量表引用的对象</li>
<li>方法区静态属性引用的对象</li>
<li>方法区常量引用的对象</li>
<li>本地方法栈中JNI(native方法)引用的对象</li>
</ul>
<p>在进行文件读取写入时。要在堆内存(HeapByteBuffer)和操作系统内存DirectByteBuffer(用户态) 来回拷贝</p>
<p>直接用DirectByteBuffer(用户态)减少了复制 </p>
<p>类加载</p>
<p>类文件结构</p>
<p>魔数</p>
<p>0~3 字节，表示它是否是【class】类型的文件<br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p>版本</p>
<p>4~7 字节，表示类的版本 00 34（52） 表示是 Java 8<br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p>常量池</p>
<p>访问标识与继承信息</p>
<p>Field</p>
<p>Method</p>
<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 字节码指令 和 操作数栈、常量池的关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v /Users/zhangxuefeng/Downloads/解密JVM/资料-解密JVM/代码/jvm/out/production/jvm/cn/itcast/jvm/t3/bytecode/Demo3_1.class</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/zhangxuefeng/Downloads/解密JVM/资料-解密JVM/代码/jvm/out/production/jvm/cn/itcast/jvm/t3/bytecode/Demo3_1.class</span><br><span class="line">  Last modified <span class="number">2024</span>-<span class="number">8</span>-<span class="number">22</span>; size <span class="number">635</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">1</span>a6413a652bcc5023f130b392deb76a1</span><br><span class="line">  Compiled from <span class="string">"Demo3_1.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">itcast</span>.<span class="title">jvm</span>.<span class="title">t3</span>.<span class="title">bytecode</span>.<span class="title">Demo3_1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#25         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #26            // java/lang/Short</span><br><span class="line">   #3 = Integer            32768</span><br><span class="line">   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #6 = Class              #31            // cn/itcast/jvm/t3/bytecode/Demo3_1</span><br><span class="line">   #7 = Class              #32            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line">  #15 = Utf8               main</span><br><span class="line">  #16 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #17 = Utf8               args</span><br><span class="line">  #18 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #19 = Utf8               a</span><br><span class="line">  #20 = Utf8               I</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               c</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               Demo3_1.java</span><br><span class="line">  #25 = NameAndType        #8:#9          // "&lt;init&gt;":()V</span><br><span class="line">  #26 = Utf8               java/lang/Short</span><br><span class="line">  #27 = Class              #33            // java/lang/System</span><br><span class="line">  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;</span><br><span class="line">  #29 = Class              #36            // java/io/PrintStream</span><br><span class="line">  #30 = NameAndType        #37:#38        // println:(I)V</span><br><span class="line">  #31 = Utf8               cn/itcast/jvm/t3/bytecode/Demo3_1</span><br><span class="line">  #32 = Utf8               java/lang/Object</span><br><span class="line">  #33 = Utf8               java/lang/System</span><br><span class="line">  #34 = Utf8               out</span><br><span class="line">  #35 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #36 = Utf8               java/io/PrintStream</span><br><span class="line">  #37 = Utf8               println</span><br><span class="line">  #38 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> cn.itcast.jvm.t3.bytecode.Demo3_1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         3: ldc           #3                  // int 32768</span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">13</span>: iload_3</span><br><span class="line">        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">18</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">15</span>     <span class="number">1</span>     a   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">12</span>     <span class="number">2</span>     b   I</span><br><span class="line">           <span class="number">10</span>       <span class="number">8</span>     <span class="number">3</span>     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Demo3_1.java"</span></span><br></pre></td></tr></table></figure>
<p><code>LineNumberTable</code> 是 Java 字节码中的一个属性，用于在编译后的类文件中记录源代码行号与字节码指令之间的映射关系</p>
<p>LocalVariableTable。局部变量表</p>
<p>常量池载入运行时常量池</p>
<p>方法字节码载入方法区</p>
<p>执行引擎开始执行字节码</p>
<p>分析i++</p>
<p>注意 iinc 指令是直接在局部变量 slot 上进行运算<br>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</p>
<p>-1到5 iconst 表示</p>
<p>分析x=0</p>
<h2 id="Clinit"><a href="#Clinit" class="headerlink" title="Clinit"></a>Clinit</h2><p>编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方<br>法 <clinit>()V</clinit></p>
<h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p>编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构<br>造方法内的代码总是在最后</p>
<p><clinit>()V 方法会在类加载的初始化阶段被调用</clinit></p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>静态绑定</p>
<p>Invokespecial  构造。私有 final</p>
<p>invokestatic static</p>
<p>动态绑定</p>
<p>invokevirtual</p>
<h2 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h2><h3 id="HSDB使用"><a href="#HSDB使用" class="headerlink" title="HSDB使用"></a>HSDB使用</h3><p>查看java安装路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure>
<p>启动HSDB</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp /Users/zhangxuefeng/Library/Java/JavaVirtualMachines/corretto-<span class="number">1.8</span>.0_392/Contents/Home/lib/sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>
<p>Jps.   找到对应java进程</p>
<p>Attachjava进程</p>
<p>查找某个对象<br>打开 Tools -&gt; Find Object By Query<br>输入 select d from cn.itcast.jvm.t3.bytecode.Dog d 点击 Execute 执行</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230014918.png" alt="image-20240823001447864"></p>
<p>查看对象 Class 的内存地址</p>
<p>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是<br>MarkWord，后 8 字节就是对象的 Class 指针<br>但目前看不到它的实际地址</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230021849.png" alt="image-20240823002125780"></p>
<p>Window console</p>
<p>0x00000003d5702ac8 2</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230020767.png" alt="image-20240823002050717"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000003d5702ac8</span>: <span class="number">0x0000000000000001</span> </span><br><span class="line"><span class="number">0x00000003d5702ad0</span>: <span class="number">0x0000000102a141a0</span></span><br></pre></td></tr></table></figure>
<p>0x0000000000000001 是markword</p>
<p>0x0000000102a141a0 是类型指针</p>
<p>Tools inspector. </p>
<p>输入0x0000000102a141a0</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230031869.png" alt="image-20240823003135809"></p>
<p>Tools -&gt; Class Browser 输入 Dog 查找，可以得到相同的结果</p>
<p>从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址</p>
<p>1a0+1b8  </p>
<p>  0001 1010 0000</p>
<p>+0001 1011 1000 </p>
<p>  0011 0101 1000</p>
<p>358 -&gt;0x0000000102a14358</p>
<p>之前看dog对象有viable长度</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230034247.png" alt="image-20240823003450188"></p>
<p>vtable长度是6</p>
<p>mem 0x0000000102a14358 6</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230037204.png" alt="image-20240823003722123"></p>
<p>除去static final private的支持多态重写的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000102a14358</span>: <span class="number">0x0000000102611b10</span> </span><br><span class="line"><span class="number">0x0000000102a14360</span>: <span class="number">0x00000001026115e8</span> </span><br><span class="line"><span class="number">0x0000000102a14368</span>: <span class="number">0x0000000102a13758</span> </span><br><span class="line"><span class="number">0x0000000102a14370</span>: <span class="number">0x0000000102611540</span> </span><br><span class="line"><span class="number">0x0000000102a14378</span>: <span class="number">0x0000000102611678</span> </span><br><span class="line"><span class="number">0x0000000102a14380</span>: <span class="number">0x0000000102a14148</span></span><br></pre></td></tr></table></figure>
<p>打开Class Browser </p>
<p>输入Dog</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230041336.png" alt="image-20240823004100268"></p>
<p>找到了eat方法</p>
<p>再看父类Animal</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230045338.png" alt="image-20240823004520262"></p>
<p>找到了toString方法</p>
<p>再看Object</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408230049943.png" alt="image-20240823004923891"></p>
<p>0x0000000102611b10. Finalize</p>
<p>0x00000001026115e8  equals</p>
<p>0x0000000102611540 hashCode</p>
<p>0x0000000102611678 clone</p>
<p>当执行 invokevirtual 指令时，</p>
<ol>
<li>先通过栈帧中的对象引用找到对象</li>
<li>分析对象头，找到对象的实际 Class</li>
<li>Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查表得到方法的具体地址</li>
<li>执行方法的字节码</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围<br>内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号<br>8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置</p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>finally写return会吞掉异常。不建议这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_12_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回10</p>
<p>从 JDK 7 开始，switch 可以作用于字符串和枚举类</p>
<p>注意<br>switch 配合 String 和枚举使用时，变量不能为null</p>
<p>可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应<br>byte 类型，第二遍才是利用 byte 执行进行比较</p>
<p>hashCode 是为了提高效率，减少可<br>能的比较；而 equals 是为了防止 hashCode 冲突</p>
<p>方法重写时的桥接方法</p>
<p>我们都知道，方法重写时对返回值分两种情况：<br>父子类的返回值完全一致<br>子类返回值可以是父类返回值的子类</p>
<p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以<br>用下面反射代码来验证：</p>
<p>匿名内部类</p>
<p>这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建<br>Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 val$x 属性，所以 x 不应该再发生变<br>化了，如果变化，那么 val$x 属性没有机会再跟着一起变化</p>
<p>可以使用 -XX:-DoEscapeAnalysis 关闭逃逸分析</p>
<p>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释<br>JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需<br>再编译<br>解释器是将字节码解释为针对所有平台都通用的机器码<br>JIT 会根据平台类型，生成平台特定的机器码</p>
<h1 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h1><p> 在该级别下，未提交的写事务不允许其他事务访问该行，不会出现脏读，但是读取数据的事务允许其他事务访问该行数据，因此会出现不可重复读的情况。</p>
<p>通过查看 ReflectionFactory 源码可知<br>sun.reflect.noInflation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首<br>次生成比较耗时，如果仅反射调用一次，不划算）<br>sun.reflect.inflationThreshold 可以修改膨胀阈值</p>
<h1 id="Arthas使用"><a href="#Arthas使用" class="headerlink" title="Arthas使用"></a>Arthas使用</h1><ol>
<li><code>dashboard</code> 命令用于实时监控 Java 应用程序的运行状态，包括内存使用情况、CPU 使用率、线程信息等。使用 <code>-i</code> 和 <code>-n</code> 选项可以进一步自定义监控的行为</li>
</ol>
<ul>
<li><code>-i &lt;interval&gt;</code>: 设置监控数据的刷新间隔（单位为毫秒）。</li>
<li><code>-n &lt;count&gt;</code>: 设置监控的次数，指定监控的轮数</li>
</ul>
<ol>
<li><p>jad  类名    反编译</p>
</li>
<li><p>classloader -l   列出当前 JVM 中所有的类加载器</p>
</li>
<li><p>classloader -c 类名  显示指定类的类加载器</p>
</li>
<li><p>sc -d 类名。 显示指定类的详细信息,包括类的完整结构，如字段、方法、构造函数、注解等</p>
</li>
<li><p>mc 类名。用于查看 Java 类的字节码</p>
</li>
</ol>
<ul>
<li><code>-n</code>：可以指定方法名称，只查看该方法的字节码。</li>
<li><code>-f</code>：可以指定要查看的字段。</li>
</ul>
<ol>
<li><p><code>dump</code> 命令用于获取 Java 应用程序的线程堆栈或内存快照，帮助开发者进行性能分析和故障排查</p>
<p>默认获取所有线程的堆栈信息,后面加线程号指定线程.-d 生成内存快照 ;-f 输出到文件</p>
<ul>
<li><strong>线程堆栈</strong>: 包括线程名称、状态（如 RUNNABLE、BLOCKED 等）以及调用栈信息。</li>
<li><strong>内存快照</strong>: 包含对象的详细信息、类信息、对象引用等。</li>
</ul>
</li>
<li><p>heapdump -f /xx/xx.hprof  <strong>生成堆内存快照并保存到指定文件</strong>:生成的 <code>.hprof</code> 文件包含了当前 JVM 的堆内存状态，包括对象的详细信息、类信息、对象引用等</p>
</li>
<li><p>trace </p>
</li>
<li><p>watch</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql基本概念]]></title>
      <url>/p/8vugi/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>书籍</p>
<p><strong>深入理解MySQL核心技术</strong></p>
<p><strong>深入理解MySQL</strong></p>
<p>高性能mysql</p>
<p>mysql必知必会</p>
<p>mysql管理之道</p>
<p>MySQL高可用解决方案</p>
<p>分布式事务二阶段提交和三阶段提交</p>
<p>拆分第一个阶段 判断事务参与者是否能参与事务,避免事务协调者在原来2pc时因为参与者不可运行导致不能收到响应而阻塞</p>
<p>加入超时</p>
<p>增加可用性,容错能力</p>
<p>3pc如果发生网络分区问题还是有问题的</p>
<p><a href="https://baijiahao.baidu.com/s?id=1771749950667534630&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1771749950667534630&amp;wfr=spider&amp;for=pc</a></p>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>set session transaction isolation level read uncommitted;</p>
<p>set session transaction isolation level read committed;</p>
<p>set session transaction isolation level repeatable read;</p>
<p>set session transaction isolation level serializable;</p>
<p><strong>在可串行化隔离级别下，即使普通的select查询也会上共享锁，进行当前读，因此右边事务进行update操作时想要获取排它锁需要一直等待，最终超时</strong></p>
<h2 id="Redo日志"><a href="#Redo日志" class="headerlink" title="Redo日志"></a><strong>Redo日志</strong></h2><p>Redo日志不可用时，刷新脏页</p>
<p>不可用是因为对重做日志的设计是循环使用的。重做日志可以被重用的部分，是指当数据库进行恢复操作时不需要的部分。若此时这部分重做日志还有用，将强制执行CheckPoint，将缓冲池的页至少刷新到当前重做日志的位置</p>
<p>flush链表是按第一次修改页面时间来排序的,先修改的在链表末尾</p>
<p>一般脏页占BufferPool一半就刷脏页</p>
<p> CheckPoint会看flush链表最后一个节点lsn. 在lsn之前可以覆盖,如果redolog满了但是checkpoint没有可覆盖的了,把flush链表末尾刷回去再更新checkpoint</p>
<p>参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/641079454" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/641079454</a></p>
<p>事务执行-&gt;redolog(prepare)-&gt;事务提交-&gt;写binlog-&gt;redolog(commit)</p>
<p>调试mysql源码</p>
<p>sudo gem install innodb_ruby</p>
<p>show variables like ‘%datadir%’;</p>
<p>查看table id.   Undo log有用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.innodb_sys_tables WHERE name =<span class="string">'order_db/t_order_1'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">| TABLE_ID | NAME               | FLAG | N_COLS | SPACE | FILE_FORMAT | ROW_FORMAT | ZIP_PAGE_SIZE | SPACE_TYPE |</span><br><span class="line">+----------+--------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">|       <span class="number">40</span> | order_db/t_order_1 |   <span class="number">33</span> |      <span class="number">7</span> |    <span class="number">36</span> | Barracuda   | Dynamic    |             <span class="number">0</span> | Single     |</span><br><span class="line">+----------+--------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p>frm表结构</p>
<p>[server]<br>innodb_file_per_table=0</p>
<p>当 innodb_file_per_table 的值为 0 时，代表使用系统表空间；当 innodb_file_per_table 的值为 1 时，代表<br>使用独立表空间</p>
<p>系统表空间(共享表空间) ibdata1. </p>
<p>独立表空间。ibd.    数据和索引</p>
<p>临时表空间 ibtmp1</p>
<p>通用表空间<br>（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）</p>
<p>MyISAM是如何存储表数据的</p>
<p>MyISAM 中的索引全部都是 二级索引 ，该存储引擎的数据和索引是分开存放的</p>
<p>test.frm<br>test.MYD<br>test.MYI</p>
<p>test.MYD 代表表的数据文件，也就是我们插入的用户记录； test.MYI 代表表的索引文件，我们为该表创建<br>的索引都会放到这个文件中</p>
<p>一个区默认占用1MB空间大小。不论是系统<br>表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组</p>
<p>叶子节点有自己<br>独有的 区 ，非叶子节点也有自己独有的 区 。存放叶子节点的区的集合就算是一个 段 （ segment ），存放非叶<br>子节点的区的集合也算是一个 段 。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段</p>
<p>碎片区直属于表空<br>间，并不属于任何一个段</p>
<p>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。<br>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间</p>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。除了索引<br>的叶子节点段和非叶子节点段之外， InnoDB 中还有为存储一些特殊的数据而定义的段，比如回滚段</p>
<p>控制块。缓存页。占大约5%</p>
<p>当我们最初启动 MySQL 服务器的时候，需要完成对 Buffer Pool 的初始化过程，就是先向操作系统申请 Buffer<br>Pool 的内存空间，然后把它划分成若干对控制块和缓存页</p>
<p>怎么区分 Buffer<br>Pool 中哪些缓存页是空闲的，哪些已经被使用了</p>
<p>把所有空闲的缓存页对应的控制块作为一个节<br>点放到一个链表中，这个链表也可以被称作 free链表</p>
<p>每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 free链表 中<br>取一个空闲的缓存页，并且把该缓存页对应的 控制块 的信息填上（就是该页所在的表空间、页号之类的信<br>息），然后把该缓存页对应的 free链表 节点从链表中移除，表示该缓存页已经被使用了</p>
<p>表空间号 + 页号 来定位一个页的，也就相当于 表空间号 + 页号 是一个 key ，<br>缓存页 就是对应的 value ，怎么通过一个 key 来快速找着一个 value 呢？哈哈，那肯定是哈希表</p>
<p>可以用 表空间号 + 页号 作为 key ， 缓存页 作为 value 创建一个哈希表，在需要访问某个页的数据<br>时，先从哈希表中根据 表空间号 + 页号 看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没<br>有，那就从 free链表 中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置</p>
<p>flush链表的管理</p>
<p>创建一个存储脏页的链表，凡是修改过的缓存页对<br>应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，<br>所以也叫 flush链表 </p>
<p>将 LRU 链表划分为 young 和 old 区域这两个部分，又添加了 innodb_old_blocks_time 这个<br>系统变量，才使得预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为用不到的预读页面以及全<br>表扫描的页面都只会被放到 old 区域，而不影响 young 区域中的缓存页</p>
<p>降低缓存命中率</p>
<p>SHOW VARIABLES LIKE ‘innodb_old_blocks_pct’;</p>
<p>在对某个处在 old 区域的缓存页进行第一次访问时就在它对应的控制块中<br>记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被<br>从old区域移动到young区域的头部，否则将它移动到young区域的头部。上述的这个间隔时间是由系统变量<br>innodb_old_blocks_time 控制的</p>
<p>SHOW VARIABLES LIKE ‘innodb_old_blocks_time’;</p>
<p>这个 innodb_old_blocks_time 的默认值是 1000 ，它的单位是毫秒，也就意味着对于从磁盘上被加载到<br>LRU 链表的 old 区域的某个页来说，如果第一次和最后一次访问该页面的时间间隔小于 1s （很明显在一次<br>全表扫描的过程中，多次访问一个页面中的时间不会超过 1s ），那么该页是不会被加入到 young 区域的</p>
<p>刷新脏页到磁盘</p>
<p>redo 日志的 checkpoint</p>
<p>写入实际上是在 Buffer Pool 中完成的，我们需要为这个页面的修改记录一条 redo<br>日志，以便在系统奔溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页面的修改是极其<br>简单的， redo 日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥<br>就好了，设计 InnoDB 的大叔把这种极其简单的 redo 日志称之为 物理日志</p>
<p>redo日志会把事务在执行过程<br>中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来</p>
<p>redo log buffer</p>
<p>我们可以通过启动参数 innodb_log_buffer_size 来指定 log buffer 的大小，在 MySQL 5.7.21 这个版本中，该<br>启动参数的默认值为 16MB</p>
<p>redo日志刷盘时机</p>
<p>redo日志文件组</p>
<p>MySQL 的数据目录（使用 SHOW VARIABLES LIKE ‘datadir’ 查看）下默认有两个名为 ib_logfile0 和<br>ib_logfile1 的文件， log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中</p>
<p>LSN</p>
<p>innodb_flush_log_at_trx_commit的用法</p>
<p>我们前边说为了保证事务的 持久性 ，用户线程在事务提交时需要将该事务执行过程中产生的所有 redo 日志都刷<br>新到磁盘上。这一条要求太狠了，会很明显的降低数据库性能。如果有的同学对事务的 持久性 要求不是那么强<br>烈的话，可以选择修改一个称为 innodb_flush_log_at_trx_commit 的系统变量的值</p>
<p>0 ：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步 redo 日志，这个任务是交给后台线程<br>做的。<br>这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将 redo 日志刷新到<br>磁盘，那么该事务对页面的修改会丢失。<br>1 ：当该系统变量值为1时，表示在事务提交时需要将 redo 日志同步到磁盘，可以保证事务的 持久性 。 1<br>也是 innodb_flush_log_at_trx_commit 的默认值。<br>2 ：当该系统变量值为2时，表示在事务提交时需要将 redo 日志写到操作系统的缓冲区中，但并不需要保<br>证将日志真正的刷新到磁盘。<br>这种情况下如果数据库挂了，操作系统没挂的话，事务的 持久性 还是可以保证的，但是操作系统也挂了的<br>话，那就不能保证 持久性 了</p>
<p>undo日志具体写入过程</p>
<p>128 个回滚段</p>
<p>配置undo表空间<br>默认情况下，针对普通表设立的回滚段（第 0 号以及第 33~127 号回滚段）都是被分配到系统表空间的。其中的<br>第第 0 号回滚段是一直在系统表空间的，但是第 33~127 号回滚段可以通过配置放到自定义的 undo表空间 中。<br>但是这种配置只能在系统初始化（创建数据目录时）的时候使用，一旦初始化完成，之后就不能再次更改了</p>
<p>通过 innodb_undo_directory 指定 undo表空间 所在的目录，如果没有指定该参数，则默认 undo表空间 所<br>在的目录就是数据目录。<br>通过 innodb_undo_tablespaces 定义 undo表空间 的数量。该参数的默认值为 0 ，表明不创建任何 undo表<br>空间 </p>
<p>/Users/zhangxuefeng/Downloads/mysql-5.7.32/data/</p>
<p><strong>通过Innodb_space查看系统表空间信息</strong></p>
<p>Cd /Users/zhangxuefeng/Downloads/mysql-5.7.32/data/</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_space -s ibdata1 system-spaces;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">name                            pages       indexes</span><br><span class="line">(system)                        <span class="number">768</span>         <span class="number">7</span></span><br><span class="line">mysql/engine_cost               <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/gtid_executed             <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/help_category             <span class="number">7</span>           <span class="number">2</span></span><br><span class="line">mysql/help_keyword              <span class="number">18</span>          <span class="number">2</span></span><br><span class="line">mysql/help_relation             <span class="number">10</span>          <span class="number">1</span></span><br><span class="line">mysql/help_topic                <span class="number">576</span>         <span class="number">2</span></span><br><span class="line">mysql/innodb_index_stats        <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/innodb_table_stats        <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/plugin                    <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/server_cost               <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/servers                   <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/slave_master_info         <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/slave_relay_log_info      <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/slave_worker_info         <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/time_zone                 <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/time_zone_leap_second     <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/time_zone_name            <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/time_zone_transition      <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">mysql/time_zone_transition_type <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">order_db/t_order_1              <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">order_db/t_order_2              <span class="number">6</span>           <span class="number">1</span></span><br><span class="line">t/zhang                         <span class="number">6</span>           <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>pages：总数据页数量，这里project表，一共使用到了704个 page页</p>
<p>indexes：总索引个数，project表我这里就是聚簇索引和唯一索引，分别就是PRIMARY主键，index（<code>tenantsid</code>, <code>code</code>）索引。</p>
<p><strong>指定表查看索引空间信息</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_space -s ibdata1 -T t/zhang space-indexes;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408241038609.png" alt="image-20240824103801499"></p>
<p>id ：索引ID，相同的ID表示是同一个索引</p>
<p>root：当前索引的根page页编号 ，可以看出来</p>
<p>fseg：类型，page的说明</p>
<p>used：索引使用到了多少page页，比如PRIMARY的叶子类型中为95，表明使用到了95个page页来存储数据（因为聚簇索引叶子节点存储了数据信息）</p>
<p>allocated：分配了多少page</p>
<p>fill_factor：page使用占比 ：used / allocated</p>
<p>PRIMARY 索引树使用使用了1个root节点，该节点根page编号为3，leaf节点数据为95个page，实际分配了96个数据页。这里可以看出来，PRIMARY索引树是一个2层的多叉树结构</p>
<p><strong>查看节点page空间信息</strong></p>
<p><strong>查看主键PRIMARY root页面空间信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_space -s ibdata1 -T t/zhang -p <span class="number">3</span> page-records</span><br></pre></td></tr></table></figure>
<p>Innodb行格式</p>
<p>Innodb数据页</p>
<p>Innodb表空间</p>
<p>两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍</p>
<p>对于左（外）连接和右（外）连接来说，必须使用 ON 子句来指出连接条件</p>
<p>join buffer</p>
<p>减少被驱动表从磁盘加载到内存的次数</p>
<p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。现实生活中<br>的表可不像 t1 、 t2 这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都<br>是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。我们前边又说过，采用 嵌<br>套循环连接 算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不<br>能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个 I/O 代价就非常大了，所以我们得想办法：<br>尽量减少访问被驱动表的次数</p>
<p>使用到多个索引来完成一次查询<br>的执行方法称之为： index merge</p>
<p>MySQL 在某些特定的情况下才可能会使用到 Intersection 索引合并</p>
<p>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能<br>出现只出现匹配部分列的情况</p>
<p>  测试using index</p>
<p>Using index condition</p>
<p>using where</p>
<p>SHOW VARIABLES LIKE ‘optimizer_trace’;</p>
<p>SET optimizer_trace=”enabled=on”;</p>
<p>输入我们想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到<br>information_schema 数据库下的 OPTIMIZER_TRACE 表中查看完整的优化过程。这个 OPTIMIZER_TRACE 表有4个<br>列，分别是：<br>QUERY ：表示我们的查询语句。<br>TRACE ：表示优化过程的JSON格式文本。<br>MISSING_BYTES_BEYOND_MAX_MEM_SIZE ：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本<br>将不会被显示，这个字段展示了被忽略的文本字节数。<br>INSUFFICIENT_PRIVILEGES ：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是<br>1 ，我们暂时不关心这个字段的值。</p>
<p>SELECT * FROM information_schema.OPTIMIZER_TRACE\G</p>
<p>优化过程大<br>致分为了三个阶段：<br>prepare 阶段<br>optimize 阶段<br>execute 阶段</p>
<p>Buffer Pool</p>
<p>通过前边的唠叨我们知道，对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚<br>簇索引和二级索引），还是各种系统数据，都是以 页 的形式存放在 表空间 中的，而所谓的 表空间 只不过是<br>InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位<br>也都知道，磁盘的速度慢的跟乌龟一样，怎么能配得上“快如风，疾如电”的 CPU 呢？所以 InnoDB 存储引擎在处<br>理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们<br>只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行<br>读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其 缓存 起来，这样将来有<br>请求再次访问该页面时，就可以省去磁盘 IO 的开销了</p>
<p>设计 InnoDB 的大叔为了缓存磁盘中的页，在 MySQL 服务器启动的时候就向操作系统申请了一片连续的内存，他<br>们给这片内存起了个名，叫做 Buffer Pool （中文名是 缓冲池 ）。那它有多大呢？这个其实看我们机器的配<br>置，如果你是土豪，你有 512G 内存，你分配个几百G作为 Buffer Pool 也可以啊，当然你要是没那么有钱，设<br>置小点也行呀～ 默认情况下 Buffer Pool 只有 128M 大小。当然如果你嫌弃这个 128M 太大或者太小，可以在启<br>动服务器的时候配置 innodb_buffer_pool_size 参数的值，它表示 Buffer Pool 的大小，就像这样：<br>[server]<br>innodb_buffer_pool_size = 268435456<br>其中， 268435456 的单位是字节，也就是我指定 Buffer Pool 的大小为 256M 。需要注意的是， Buffer Pool 也<br>不能太小，最小值为 5M (当小于该值时会自动设置成 5M )</p>
<p>Buffer Pool内部组成</p>
<p>每个缓存页对应的控制信息占用的内存大小是相同的，我们就把每个页对应的控制信息占用的一块内存称为一个<br>控制块 吧，控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool<br>的前边，缓存页被存放到 Buffer Pool 后边</p>
<p>free链表的管理</p>
<p>LRU 链表</p>
<p>flush链表</p>
<p>Buffer Pool 的缓存页除了用来缓存磁盘上的页面以外，还可以存储锁信息、自适应哈希索引等信息</p>
<p>为了快速定位某个页是否被加载到 Buffer Pool ，使用 表空间号 + 页号 作为 key ，缓存页作为 value ，<br>建立哈希表</p>
<p>SAVEPOINT s1; </p>
<p>ROLLBACK TO s1</p>
<p>ReadView</p>
<p>如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己<br>修改过的记录，所以该版本可以被当前事务访问。如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生<br>成 ReadView 前已经提交，所以该版本可以被当前事务访问。<br>如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生<br>成 ReadView 后才开启，所以该版本不可以被当前事务访问。<br>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下<br>trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该<br>版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问</p>
<p>READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成ReadView的<br>时机不同</p>
<p>READ COMMITTED —— 每次读取数据前都生成一个ReadView</p>
<p>REPEATABLE READ. 在第一次读取数据时生成一个ReadView</p>
<p>总结</p>
<p>所谓的 MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就<br>是在使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版<br>本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。 READ COMMITTD 、<br>REPEATABLE READ 这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一<br>次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作<br>前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了</p>
<p>锁</p>
<p>如果有领导要参观教学楼，也就是想在教学楼门口前放 S锁 （表锁）时，首先要看一下教学楼门口有没有<br>IX锁 ，如果有，意味着有教室在维修，需要等到维修结束把 IX锁 撤掉后才可以在整栋教学楼上加 S锁 。<br>如果有考试要占用教学楼，也就是想在教学楼门口前放 X锁 （表锁）时，首先要看一下教学楼门口有没有<br>IS锁 或 IX锁 ，如果有，意味着有教室在上自习或者维修，需要等到学生们上完自习以及维修结束把 IS锁<br>和 IX锁 撤掉后才可以在整栋教学楼上加 X锁</p>
<p>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否<br>被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是<br>兼容的</p>
<p>兼容性 X IX S IS<br>X 不兼容 不兼容 不兼容 不兼容<br>IX 不兼容 兼容 不兼容 兼容<br>S 不兼容 不兼容 兼容 兼容<br>IS 不兼容 兼容 兼容 兼容</p>
<p>通过在 server层 使用一种称之为 元数据锁。DDL</p>
<p>手动获取一下的，比方说在系统变量 autocommit=0，innodb_table_locks =<br>1 时，手动获取 InnoDB 存储引擎提供的表 t 的 S锁 或者 X锁 可以这么写：<br>LOCK TABLES t READ ： InnoDB 存储引擎会对表 t 加表级别的 S锁 。<br>LOCK TABLES t WRITE ： InnoDB 存储引擎会对表 t 加表级别的 X锁 </p>
<p>表级别的 AUTO-INC锁</p>
<p>如果我们的插入语句在执行前不可以确定具体要插入多少条记录（无法预计即将插入记录的数量），比<br>方说使用 INSERT … SELECT 、 REPLACE … SELECT 或者 LOAD DATA 这种插入语句，一般是使用<br>AUTO-INC 锁为 AUTO_INCREMENT 修饰的列生成对应的值</p>
<p>采用一个轻量级的锁，在为插入语句生成 AUTO_INCREMENT 修饰的列的值时获取一下这个轻量级锁，然<br>后生成本次插入语句需要用到的 AUTO_INCREMENT 列的值之后，就把该轻量级锁释放掉，并不需要等到<br>整个插入语句执行完才释放锁。<br>如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说我们上边举的关于表 t 的例子<br>中，在语句执行前就可以确定要插入2条记录，那么一般采用轻量级锁的方式对 AUTO_INCREMENT 修饰的<br>列进行赋值。这种方式可以避免锁定表，可以提升插入性能</p>
<p>设计InnoDB的大叔提供了一个称之为innodb_autoinc_lock_mode的系统变量来控制到底使用上<br>述两种方式中的哪种来为AUTO_INCREMENT修饰的列进行赋值，当innodb_autoinc_lock_mode值<br>为0时，一律采用AUTO-INC锁；当innodb_autoinc_lock_mode值为2时，一律采用轻量级锁；当<br>innodb_autoinc_lock_mode值为1时，两种方式混着来（也就是在插入记录数量确定时采用轻<br>量级锁，不确定时使用AUTO-INC锁）。不过当innodb_autoinc_lock_mode值为2时，可能会造<br>成不同事务中的插入语句为AUTO_INCREMENT修饰的列生成的值是交叉的，在有主从复制的场景<br>中是不安全的</p>
<p>插入意向锁</p>
<p>LOCK_REC_NOT_GAP. 记录锁</p>
<p>有 S锁 和 X锁 之分</p>
<p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方<br>案解决，也可以采用 加锁 方案解决</p>
<p>LOCK_GAP</p>
<p>为 number 值为 8 的记录加了 gap锁 ，意味着不允许别的事务在 number 值为 8 的记录前边的 间隙<br>插入新记录，其实就是 number 列的值 (3, 8) 这个区间的新记录是不允许立即插入的</p>
<p>gap锁 的提出仅仅是为了防止插入幻影记录而提出的</p>
<p>并不会限制其他事务对这条记录加 正经记录锁 或者继续加 gap锁 ，再强调一遍， gap锁 的作用仅<br>仅是为了防止插入幻影记录的而已</p>
<p>number 值为 20 的那条记录所在页面的 Supremum 记录加上一个 gap锁</p>
<p>Infimum 记录，表示该页面中最小的记录</p>
<p>Supremum 记录，表示该页面中最大的记录</p>
<p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的 gap锁 （ next-key<br>锁 也包含 gap锁 ，后边就不强调了），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提<br>交。但是设计 InnoDB 的大叔规定事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某<br>个 间隙 中插入新记录，但是现在在等待。设计 InnoDB 的大叔就把这种类型的锁命名为 Insert Intention<br>Locks ，官方的类型名称为： LOCK_INSERT_INTENTION ，我们也可以称为 插入意向锁</p>
<p>插入意向锁并不会阻止别的事务继<br>续获取该记录上任何类型的锁.  没什么用</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis基本概念]]></title>
      <url>/p/8vugi/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构</p>
<p>pipeline</p>
<p>编码</p>
<p>type</p>
<p>object encoding</p>
<p>redis基本命令</p>
<p>redis大key</p>
<p>redis网络设计</p>
<p>6.0之前单线程,命令和网络都一个线程,</p>
<p>6.0之后网络用多线程,命令还是单线程,redis瓶颈在内存而不是cpu,网络reactor线程模型,NIO</p>
<p>单线程简单,不用考虑多线程上下文切换</p>
<p>java中多线程是因为线程会阻塞在io,锁之类的资源而发生上下文切换来提高效率,但redis需要的是内存资源</p>
<p>redis源码分析</p>
<p>server.c 启动</p>
<p>参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/697522352" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/697522352</a></p>
<p>缓存穿透</p>
<p>缓存雪崩</p>
<p>缓存击穿</p>
<p>缓存一致性</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kafka源码梳理]]></title>
      <url>/p/8vugh/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基础知识</p>
<h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p>主机节点规划</p>
<p>zookeeper:node4,node5,node6</p>
<p>kafka:node4,node5,node6</p>
<h2 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#node4</span><br><span class="line">cd /opt/software/apache-zookeeper-<span class="number">3.7</span>.0-bin/bin</span><br><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>查看zk状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#node4</span><br><span class="line">[root@node4 bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by <span class="keyword">default</span></span><br><span class="line">Using config: /opt/software/apache-zookeeper-<span class="number">3.7</span>.0-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: <span class="number">2181</span>. Client address: localhost. Client SSL: <span class="keyword">false</span>.</span><br><span class="line">Mode: follower</span><br><span class="line">  </span><br><span class="line">#node5</span><br><span class="line">[root@node5 bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by <span class="keyword">default</span></span><br><span class="line">Using config: /opt/software/apache-zookeeper-<span class="number">3.7</span>.0-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: <span class="number">2181</span>. Client address: localhost. Client SSL: <span class="keyword">false</span>.</span><br><span class="line">Mode: leader</span><br><span class="line">  </span><br><span class="line">#node6</span><br><span class="line">[root@node6 bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by <span class="keyword">default</span></span><br><span class="line">Using config: /opt/software/apache-zookeeper-<span class="number">3.7</span>.0-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: <span class="number">2181</span>. Client address: localhost. Client SSL: <span class="keyword">false</span>.</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure>
<h2 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#node4</span><br><span class="line">cd /opt/software/kafka_2.13-<span class="number">2.7</span>.0</span><br><span class="line">nohup ./bin/kafka-server-start.sh config/server.properties &amp;</span><br><span class="line">  </span><br><span class="line">#node5</span><br><span class="line">cd /opt/software/kafka_2.13-<span class="number">2.7</span>.0</span><br><span class="line">nohup ./bin/kafka-server-start.sh config/server.properties &amp;</span><br><span class="line">  </span><br><span class="line">#node6</span><br><span class="line">cd /opt/software/kafka_2.13-<span class="number">2.7</span>.0</span><br><span class="line">nohup ./bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure>
<p>offset explorer查看</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409021853696.png" alt="image-20240902185326520"></p>
<p>Kafka怎么保证消息不丢失</p>
<p>Kafka怎么保证消息消费顺序</p>
<p>Kafka怎么保证消息不重复</p>
<p>kafka源码解析</p>
<p>生产者发送消息</p>
<p>网络设计</p>
<p>存储</p>
<p>Filechannel</p>
<p>写回缓存模式</p>
<p>零拷贝</p>
<p>提交</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat源码梳理]]></title>
      <url>/p/8vugg/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SimpleTomcat</p>
<p>Tomcat是Servlet容器</p>
<p>tomcat架构解析是8.5.6,自己运行的是9</p>
<p>启动添加参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home=/Users/zhangxuefeng/Downloads/tomcat/home </span><br><span class="line">-Dcatalina.base=/Users/zhangxuefeng/Downloads/tomcat/home </span><br><span class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager </span><br><span class="line">-Djava.util.logging.config.file=</span><br><span class="line">  /Users/zhangxuefeng/Downloads/tomcat/home/conf/logging.properties </span><br><span class="line">-Dfile.encoding=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011554956.png" alt="image-20240901155418822"></p>
<p>Tomcat目录结构</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011606434.png" alt="image-20240901160638336"></p>
<p>主要看Server.xml。 根据这个配置创建服务器实例</p>
<p>tomcat-users.xml是用户和角色相关。安全认证</p>
<h1 id="Tomcat总体架构"><a href="#Tomcat总体架构" class="headerlink" title="Tomcat总体架构"></a>Tomcat总体架构</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011706225.png" alt="image-20240901170628117"></p>
<p>一个 Server可以包含多个Service,每个Service有Connector和Engine</p>
<p>Engine,Host,Context,Wrapper都是Container. 实现是StandardEngine,StandardHost,StandardContext,StandardContext,它们都有Pipeline实例,pipeline可以设置valve,(valve是链表,tomcat内部有默认的valve,我们添加的在它前面)</p>
<p>连接器和协议处理器</p>
<p>Connector</p>
<p>ProtocolHandler。(Endpoint. Processor)</p>
<p>Endpoint. Socket  IO</p>
<p>Processor. 协议。然后交给容器处理</p>
<p>地址映射到具体容器进行处理</p>
<p>Mapper.  MapperListener维护容器映射信息</p>
<p>已创建的容器注册到Mapper</p>
<p>Executor.  同一个Service的组件共享线程池</p>
<p>不定义线程池就不共享</p>
<p>Bootstrap和Catalina</p>
<p>Bootstrap是启动入口,创建Catalina实例</p>
<p>Tomcat各组件</p>
<p>Tomcat启动及请求处理过程</p>
<h1 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011710013.png" alt="image-20240901171019903"></p>
<p>层级设计。类加载过程</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011712234.png" alt="image-20240901171253140"></p>
<p>Catalina   web应用不可见</p>
<p>Shared. web应用共享</p>
<p>BootStrap由SystemClassLoader加载</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011716592.png" alt="image-20240901171645471"></p>
<p>delegate默认false 打破双亲委派</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011719416.png" alt="image-20240901171942311"></p>
<p>生命周期管理</p>
<h1 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011726474.png" alt="image-20240901172608353"></p>
<h2 id="Digester"><a href="#Digester" class="headerlink" title="Digester"></a>Digester</h2><p>Catalina#createStartDigester()</p>
<p>Digester 事件驱动 SAX. Xml-&gt;对象</p>
<p>对象栈</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011733984.png" alt="image-20240901173332893"></p>
<p>Server默认监听器Server.xml默认没添加</p>
<p>HostRuleSet</p>
<p>ContextRuleSet</p>
<p>Catalina默认添加监听器</p>
<p>StandardHost. 加载Web应用两个入口。Server.xml. 和HostConfig扫描目录 创建Context实例</p>
<p>HostConfig.   是Host的LifeCycleListener</p>
<p>ConextConfig.   配置Context.  解析web.xml</p>
<p>Context命名规则 (ContextName)</p>
<p>Context name path version</p>
<p>web应用多版本管理</p>
<p>Realm. 安全配置</p>
<h2 id="DefaultServlet和JspServlet"><a href="#DefaultServlet和JspServlet" class="headerlink" title="DefaultServlet和JspServlet"></a>DefaultServlet和JspServlet</h2><p>这两个Servlet默认存在所有Web应用容器中</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409011830129.png" alt="image-20240901183011015"></p>
<p>Coyote</p>
<p>Jasper</p>
<p>Tomcat后台线程定期检测JSP页面是否更新,如果发生更新,重新编译jsp页面并加载,不必重启服务器,也不必重新加载整个应用</p>
<p>Ant(Java). Jdt两种编译器.(默认) 需要jre即可</p>
<p>编译方式</p>
<p>预编译,运行时编译(第一次请求编译而不是启动web应用时编译)</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012021912.png" alt="image-20240901202112748"></p>
<p>LifeCycle</p>
<p>Server</p>
<p>Calalina</p>
<p>Service</p>
<p>coyote</p>
<p>连接器 connector (Acceptor.   Handler). Endpoint</p>
<p>Processor</p>
<p>coyoteAdapter. 适配器模式</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012007837.png" alt="image-20240901200742665"></p>
<p>Container</p>
<p> Engine    valve   责任链模式</p>
<p>Host</p>
<p>Context</p>
<p>Wrapper (在Wrapper创建过滤器)</p>
<p>执行过滤器</p>
<p>Service方法</p>
<p>Servlet doGet或doPost</p>
<p>(如果是SpringMvc 是dispatcher Servlet 里面先执行拦截器 再调controller方法)</p>
<h1 id="Tomcat配置管理"><a href="#Tomcat配置管理" class="headerlink" title="Tomcat配置管理"></a>Tomcat配置管理</h1><p>JVM配置</p>
<p>服务器配置</p>
<p>catalina.properties</p>
<p>common.loader</p>
<p>Server.loader</p>
<p>Shared.loader</p>
<p>Server.xml</p>
<p>Server下默认5个listener</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012049911.png" alt="image-20240901204920775"></p>
<p>Engine配置</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012100821.png" alt="image-20240901210047646"></p>
<p>Host配置</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012101315.png" alt="image-20240901210127193"></p>
<p>Context配置</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012104817.png" alt="image-20240901210410677"></p>
<p>context.xml</p>
<p>Web应用配置</p>
<p>Web.xml</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012107705.png" alt="image-20240901210749587"></p>
<p>Filter和Servlet以及监听器在web.xml配置</p>
<p>错误页面。欢迎文件列表</p>
<p>Filter和Servlet可配置成异步</p>
<p>Web应用过滤器</p>
<p>常见web应用需求(跨域资源共享,访问控制,设置请求编码等)Tomcat提供了Filter实现</p>
<p>CorsFilter</p>
<p>ExpiresFilter</p>
<p>SetCharacterEncodingFilter</p>
<h1 id="Tomcat管理"><a href="#Tomcat管理" class="headerlink" title="Tomcat管理"></a>Tomcat管理</h1><h2 id="host-manager"><a href="#host-manager" class="headerlink" title="host-manager"></a>host-manager</h2><p>管理Host的host-manager.  (页面访问,简单文本访问)  可以在页面动态添加虚拟主机,还可以启动,停止,删除虚拟主机</p>
<h2 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h2><p>管理web应用的manager (控制JMX访问,控制服务器状态查看)。 </p>
<p>查看一些状态信息,启动,停止,重新加载,卸载指定的web应用</p>
<h2 id="tomcat和nginx集成"><a href="#tomcat和nginx集成" class="headerlink" title="tomcat和nginx集成"></a>tomcat和nginx集成</h2><h1 id="Tomcat集群"><a href="#Tomcat集群" class="headerlink" title="Tomcat集群"></a>Tomcat集群</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012205681.png" alt="image-20240901220540579"></p>
<h2 id="通信框架Tribes"><a href="#通信框架Tribes" class="headerlink" title="通信框架Tribes"></a>通信框架Tribes</h2><h2 id="会话同步"><a href="#会话同步" class="headerlink" title="会话同步"></a>会话同步</h2><h1 id="Tomcat安全"><a href="#Tomcat安全" class="headerlink" title="Tomcat安全"></a>Tomcat安全</h1><p>配置安全</p>
<p>应用安全</p>
<p>传输安全</p>
<p>Java安全策略</p>
<p>catalina.policy. idk,tomcat,web应用</p>
<h1 id="Tomcat性能调优"><a href="#Tomcat性能调优" class="headerlink" title="Tomcat性能调优"></a>Tomcat性能调优</h1><h2 id="性能测试及诊断"><a href="#性能测试及诊断" class="headerlink" title="性能测试及诊断"></a>性能测试及诊断</h2><p>常见测试方式</p>
<ul>
<li>负载测试</li>
<li>压力测试</li>
<li>持续运行时间测试</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012228441.png" alt="image-20240901222801279"></p>
<p>ApacheBench</p>
<p>Jmeter</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012232698.png" alt="image-20240901223203593"></p>
<h2 id="Tomcat性能优化"><a href="#Tomcat性能优化" class="headerlink" title="Tomcat性能优化"></a>Tomcat性能优化</h2><p>Jvm</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012300091.png" alt="image-20240901230055994"></p>
<p>tomcat配置</p>
<p>缓存</p>
<p>Tcp_no_delay.    不用Nagle算法</p>
<p>接收请求最大数目</p>
<p>静态文件gzio压缩</p>
<p>高性能连接器</p>
<p>关闭自动部署。影响性能</p>
<h2 id="应用性能优化建议"><a href="#应用性能优化建议" class="headerlink" title="应用性能优化建议"></a>应用性能优化建议</h2><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012312926.png" alt="image-20240901231200749"></p>
<h1 id="Tomcat附加功能"><a href="#Tomcat附加功能" class="headerlink" title="Tomcat附加功能"></a>Tomcat附加功能</h1><p>Servlet3.0后可以不用web.xml 通过编程在tomcat中加入servlet,filter,listener</p>
<h2 id="Tomcat的嵌入式启动"><a href="#Tomcat的嵌入式启动" class="headerlink" title="Tomcat的嵌入式启动"></a>Tomcat的嵌入式启动</h2>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis源码梳理]]></title>
      <url>/p/8vuge/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>传统 JDBC 编程中 的查询操作为例进行说明，其主要步骤如下：<br>(1 ）注册数据库驱动类 ，明确指定数据库 URL 地址、数据库用户名、密码等连接信息 。<br>(2 ）通过 DriverManager 打开数据库连接 。</p>
<p>(3 ）通过数据库连接创建 Statement 对象 。<br>( 4 ）通过 Statement 对象执行 SQL 语句，得到 ResultS et 对象 。<br>( 5 ）通过 ResultSet 读取数据，并将数据转换成 JavaBean 对象 。<br>(6 ）关闭 ResultSet 、 Statement 对象以及数据库连接，释放相关资源。</p>
<p>上述步骤 l～步骤 4 以及步骤 6 在每次查询操作中都会出现，在保存、更新、删除等其他<br>数据库操作中也有类似的重复性代码。在实践中，为了提高代码的可维护性，可以将上述重复<br>性代码封装到一个类似 DBUtils 的工具类中 。 步骤 5 中完成了关系模型到对象模型的转换，要<br>使用比较通用的方式封装这种复杂的转换是比较困难的 </p>
<p>为了解决该问题， ORM ( Object Relational Mapping，对象－关系映射）框架应运而生</p>
<p>ORM 框架的主要功能就是根据映射配置文件，完成数据在对象模型与关系模型之<br>间的映射，同时也屏蔽了上述重复的代码，只暴露简单的 API 供开发人员使用</p>
<p>Hibernate 通过 hbm . xml 映射文件维护 Java 类与数据库表的映射关系。 通过 Hibernate 的映<br>射， Java 开发人员可以用看待 Java 对象的角度去看待数据库表中的数据行。数据库中所有的表<br>通过 hbm皿nl 配置文件映射之后 ，都对应一个 Java 类 ， 表中 的每一行数据在运行过程中会被映<br>射成相应的 Java 对象。在 Java 对象之间存在一对多 、 一对一、多对多等复杂的层次关系， Hibernate<br>的 hbm.xml 映射文件也可以维护这种层次关系 ， 并将这种关系与数据库中 的外键、 关联表等进<br>行映射，这也就是所谓的“关联映射”</p>
<p>但是，我们很难修改 Hibernate 生成的 SQL 语句，当数据量比较大、数据库结构比<br>较复杂时， Hibernate 生成 SQL 语句会非常复杂，而且要让生成的 SQL 语句使用正确的索引也<br>比较困难，这就会导致出现大量慢查询的情况。在有些大数据量、高并发、低延迟的场景下，<br>Hibernate 并不是特别适合。最后， Hibernate 对批处理的支持并不是很友好，这也会影响部分性<br>能。后来出现了 iBatis ( Mybatis 的前身）这种半自动化的映射方式来解决性能问题</p>
<p>MyBatis 前身是 Apache 基金会的开源项目<br>iBatis </p>
<p>MyBatis 通过映射配置文件或相应注解将 ResultSet 映射为 Java 对象，其映射规则可以嵌<br>套其他映射规则以及子查询，从而实现复杂的映射逻辑，也可以实现一对一 、 一对多、多对多<br>映射以及双向映射。</p>
<p>相较于 Hibernate, MyBatis 更加轻量级，可控性也更高，在使用 MyBatis 时我们直接在映<br>射配置文件中编写待执行的原生 SQL 语句，这就给了我们直接优化 SQL 语句的机会，让 SQL<br>语句选择合适的索引，能更好地提高系统的性能，比较适合大数据量、高并发等场景</p>
<p>MyBatis 就可以根据执行时传入的实<br>际参数值拼凑出完整的、可执行的 SQL 语句</p>
<p>嵌套映射</p>
<p>集合映射</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408161814974.png" alt="image-20240816181430619"></p>
<h2 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h2><p>反射模块<br>Java 中的反射虽然功能强大，但对大多数开发人员来说，写出高质量的反射代码还是<br>有一定难度的 。 MyBatis 中专门提供了反射模块，该模块对 Java 原生的反射进行了良<br>好的封装，提供了更加简洁易用的 API，方便上层使调用，并且对反射操作进行了一<br>系列优化，例如缓存了类的元数据，提高了反射操作的性能</p>
<p>类型转换模块</p>
<p>MyBatis 为简化配置文件提供了别名机制 ， 该机制是类型转换模<br>块的主要功能之一 。 类型转换模块的另一个功能是实现 JDBC 类型与 Java 类型之间的<br>转换，该功能在为 SQL 语句绑定实参以及映射查询结果集时都会涉及。在为 SQL 语<br>句绑定实参时， 会将数据由 Java 类型转换成 JDBC 类型；而在映射结果集时，会将数<br>据由 JDBC 类型转换成 Java 类型</p>
<p>日志模块</p>
<p>MyBatis 作为一个设计优良的框架，除了提供详细的日<br>志输出信息，还要能够集成多种日志框架，其日志模块的一个主要功能就是集成第三<br>方日志框架。</p>
<p>解析器模块的主要提供了两个功能 ： 一个功能是对 XPath 进行封装，为 MyBatis 初始<br>化时解析 mybatis-config.xml 配置文件以及映射配置文件提供支持；另一个功能是为处<br>理动态 SQL 语句中的占位符提供支持。</p>
<p>MyBatis 自身提供了相应的数据源实现，当<br>然 MyBatis 也提供了与第三方数据源集成的接口，这些功能都位于数据源模块之中</p>
<p>MyBatis 对数据库中的事务进行了抽象，其自身提供了相应的事务接口和简单实现。<br>在很多场景中， MyBatis 会与 Spring 框架集成，并由 Spring 框架管理事务，</p>
<p>MyBatis 中提供了一级缓存和二级缓存，而这两级缓存都是依赖于基础支持层中的缓<br>存模块实现的。这里需要读者注意的是， MyBatis 中自带的这两级缓存与 MyBatis 以<br>及整个应用是运行在同一个 川币4 中的，共享同一块堆内存。如果这两级缓存中的数据<br>量较大， 则可能影响系统中其他功能的运行，所以当需要缓存大量数据时 ，优先考虑<br>使用 Redis 、 Memcache 等缓存产品</p>
<p>MyBatis 通过 Binding 模块将用户自定义的 Mapper 接<br>口与映射配置文件关联起来，系统可以通过调用自定义 Mapper 接口中的方法执行相应<br>的 SQL 语句完成数据库操作</p>
<p>值得读者注意的是，开发人员无须编写自定义 Mapper 接口的实现， MyBatis 会自动为<br>其创建动态代理对象 </p>
<h2 id="核心处理层"><a href="#核心处理层" class="headerlink" title="核心处理层"></a>核心处理层</h2><p>在核心处理层中<br>实现了 MyBatis 的核心处理流程，其中包括 MyBatis 的初始化以及完成一次数据库操作的涉及<br>的全部流程 </p>
<p>配置解析</p>
<p>在 MyBatis 初始化过程中，会加载 mybatis-config.xml 配置文件、映射配置文件以及<br>Mapper 接口中的注解信息，解析后的配置信息会形成相应的对象并保存到<br>Configuration 对象</p>
<p>示例中定义的＜resultMap＞节点（即 ResultSet 的映射规则）<br>会被解析成 ResultMap 对象：示例中定义的＜result&gt;节点（即属性映射）会被解析成<br>ResultMapping 对象 。 之后，利用该 Configuration 对象创建 Sq!SessionFactory 对象</p>
<p>待 MyBatis 初始化之后，开发人员可以通过初始化得到 Sq!SessionFactory 创建<br>Sq!Session 对象并完成数据库操作。</p>
<p>SQL 语句的执行涉及多个组件 ，其中比较重要的是 Executor 、 StatementHandler 、<br>ParameterHandler 和 R巳sultSetHandler 。 Executor 主要负责维护一级缓存和二级缓存，<br>并提供事务管理的相关操作 ，它会将数据库相关操作委托给 StatementHandler 完成。<br>StatementHandler 首先通过 ParameterHandler 完成 SQL 语句的实参绑定，然后通过<br>java.sql.Statement 对象执行 SQL 语句并得到结果集，最后通过 ResultSetHandler 完成结<br>果集的映射，得到结果对象并返回</p>
<p>Mybatis 自身的功能虽然强大，但是并不能完美切合所有 的应用场景，因此 MyBatis<br>提供了插件接口，我们可以通过添加用户自定义插件的方式对 MyBati s 进行扩展。用<br>户自定义插件也可以改变 Mybatis 的默认行为，例如，我们可以拦截 SQL 语句并对其<br>进行重写。由于用户自定义插件会影响 MyBatis 的核心行为，在使用自定义插件之前，<br>开发人员需要了解 MyBatis 内部的原理，这样才能编写出安全、高效的插件。</p>
<p>XML解析常见的方式有三种 ， 分别是： DOM ( Document Object Model ）解析方式和 SAX ( Simple API<br>for XML ）解析方式，以及从 JDK6.0 版本开始， JDK 开始支持的 StAX( Streaming API for XML)<br>解析方式</p>
<p>DOM 解析方式最主要的好处是易于编程 但是因为要将整个 XML 文档加载到内<br>存中井构造树形结构，当 XML 文档的数据量较大时，会造成较大的资源消耗</p>
<p>SAX 是基于事件模型的 XML 解析方式，它并不需要将整个 XML 文档加载到内存中，而<br>只需将 XML 文档的一部分加载到内存中，即可开始解析，在处理过程中井不会在内存中记录<br>XML 中的数据，所以占用的资源比较小。当程序处理过程中满足条件时，也可以立即停止解析<br>过程，这样就不必解析剩余的 XML 内容</p>
<p>MyBatis 在初始化过程中处理 mybatis-config.xml 配置文件以及映射文件时，使用的是 DOM<br>解析方式，井结合使用 XPath 解析 XML 配置文件</p>
<p>XPath 是一种为查询 XML 文档而设计的语言，它可以<br>与 DOM 解析方式配合使用，实现对 XML 文档的解析 。 XPath 之于 XML 就好比 SQL 语言之于<br>数据库</p>
<p>MyBatis 提供的 XPathParser 类封装 了前面涉及的 XPath 、 Document 和 EntityResolver</p>
<p>对 XML 文档进行验证时，会根据 XML 文档开始位置指定的网址加载对应的<br>DTD 文 件或 XSD 文件 。 如果解析 mybatis-config .xm l 配置文件，默认联网加载<br><a href="http://mybatis.org/dtd/mybatis-3-config.dtd" target="_blank" rel="noopener">http://mybatis.org/dtd/mybatis-3-config.dtd</a> 这个 DTD 文档，当网络比较慢时会导致验证过程缓慢。<br>在实践中往往会提前设置 EntityResolver 接口对象加载本地的 DTD 文件，从而避免联网加载<br>DTD 文件。 XMLMapperEntityResolver 是 MyBatis 提供的 EntityResoIver 接口的实现类</p>
<p>XNode</p>
<p>Reflector 是 MyBatis 中反射模块的基础，每个 Reflector 对象都对应一个类，在 Reflector 中<br>缓存了反射操作需要使用的类的元信息。</p>
<p>add<em>Method（）方法和 add</em>Field（）方法在向上述集合添加元素时，<br>会将 getter/setter 方法对应的 Method 对象以及字段对应的 Field 对象统一封装成 Invoker 对象。</p>
<p>ReflectorFactory 接口主要实现了对 Reflector 对象的创建和缓存</p>
<p>DefaultReflectorFactory 提供的 findForClass （）方法实现会为指定的 C lass 创建 Reflector 对象，<br>并将 Reflector 对象缓存到 reflectorMap 中</p>
<p>除了使用 MyBatis 提供的 DefaultReflectorFactory 实现，我们还可以在 mybatis-config.xml<br>中配置自定义的 ReflectorFactory 实现类</p>
<p>TypeParameterResolver.resolveType（)</p>
<p>ParameterizedType 表示的是参数化类型，例如 List&lt;String＞ 、 Map&lt;Integer,String＞、<br>Service&lt;User＞这种带有泛型的类型。</p>
<p>Type getRawType（）一一返回参数化类型中的原始类型，例如 List<string＞的原始类 型为 list。 。 type[] getactualtypearguments（）一一获取参数化类型的类型变量或是实际类型列 表，例如 map<integer, string＞的实际泛型列表 integer 和 string。需要注意的是， 该列表的元素类型都是 type，也就是说，可能存在多层嵌套的情况。 type getownertype（）一一返回是类型所属的类型，例如存在 a<t>类，其中定义了<br>内部类 lnnerA<l＞，则 innera<l＞所属的类型为 a<t＞，如果是顶层类型则返回 null 。 这种关系比较常见的示例是 map<k,v＞接口与 map.en盯＜k,v＞接口 ， map<k,v><br>接口是 Map.En町＜K,V＞接口的所有者</l＞，则></string＞的原始类></p>
<p>WildcardType 表示的是通配符泛型</p>
<p>MyBatis 中有很多模块会使用到 ObjectFactory 接口，该接口提供了多个 create（）方法的重载，<br>通过这些 create（）方法可以创建指定类型的对象</p>
<p>DefaultObjectFactory 是 MyBati s 提供的 ObjectFactory 接口的唯一实现，它是一个反射工厂，<br>其 create（）方法通过调用 instantiateClass（）方法实现。 DefaultObjectFactory.instantiateClass（）方法会<br>根据传入的参数列表选择合适的构造函数实例化对象，</p>
<p>除了使用 MyBatis 提供的 DefaultObjectFactory 实现，我们还可以在 mybatis-config.xml 配置<br>文件中指定自定义的 ObjectFactory 接口实现类</p>
<p>PropertyTokenizer 解析复杂的属性表达式</p>
<p>MetaC!ass 通过 Reflector 和 PropertyTokenizer 组合使用， 实现了对复杂的属性表达式的解<br>析，并实现了获取指定属性描述信息的功能。</p>
<p>MetaClass 中 findPropertyO 、 hasGetterO 、 hasSetterO等方<br>法的实现原理</p>
<p>MetaClass 是 MyBatis 对类级别的元信息的封装和处理，下面来看 MyBatis 对对象级别的元<br>信息的处理 。 ObjectWrapper 接口是对对象的包装，抽象了对象的属性信息 ，它定义了一系列查<br>询对象属性信息的方法</p>
<p>BaseWrapper 是一个实现了 ObjectWrapper 接口的抽象类， 其中封装了 MetaObject 对象，并<br>提供了三个常用的方法供其子类使用</p>
<p>BeanWrapper 继承了 BaseWrapper 抽象类，其中封装了一个 JavaBean 对象以及该 JavaBean<br>类相应的 MetaClass 对象，当然，还有从 BaseWrapper 继承下来的、该 JavaBean 对象相应的<br>MetaObject 对象</p>
<p>MapWrapper 是 BaseWrapper 的另一个实现类，其中封装的是 Map<string, object>类型对象，</string,></p>
<p>MetaObject 是如何完成属性表达式的解析的</p>
<p>MetaObject 的构造方法会根据传入的原始对象的类型以及 ObjectFactory 工厂的实现，创建<br>相应的 ObjectWrapper 对象</p>
<p>MyBatis 中所有的类型转换器都继承了 TypeHandler 接 口 ，在 TypeHandler 接口中定义了如<br>下四个方法 ， 这四个方法分为两类 ： setParameter（）方法负责将数据 由 JdbcType 类型转换成 Java<br>类型： getResult（）方法及其重载负责将数据由 Java 类型转换成 JdbcType 类型</p>
<p>在 MyBatis 初始化过程中，会为所有己知的 TypeHandler 创建对象，并实现注册到<br>TypeHandlerRegistry 中，由 TypeHandlerRegis盯F 负责管理这些 TypeHandler 对象</p>
<p>MyBatis 定义了 一套统一<br>的日志接口供上层使用 ， 并为上述常用的日志框架提供了相应的适配器。</p>
<p>ORM框架  对象关系映射</p>
<p>Executor</p>
<p>Statementhandler</p>
<p>parameterhandler</p>
<p>resultSethandler</p>
<p>对jdbc封装</p>
<p>一级缓存</p>
<p>二级缓存 cacheEnabled</p>
<p>MapperProxy</p>
<p>设计模式</p>
<p>SqlSessionFactoryBuilder 建造者模式</p>
<p>SqlSession把请求封装成sqlCommand给Executor执行 命令模式</p>
<p>动态sql解析成sqlNode 组合模式</p>
<p>插件。jdk动态代理  责任链.  Plugin是InvocationHandler</p>
<p>选择Executor 策略</p>
<p>日志模块。适配器模式</p>
<p>ProxyClassCache</p>
<p>ProxyClassFactory</p>
<p>添加VM参数 -Dsun.misc.ProxyGenerator.saveGeneratedFiles=true 可保存生成的动态代理类文件</p>
<p>资源加载</p>
<p>类加载器</p>
<p>Bootstrap ClassLoader 负责加载 JDK 自带的比jar 包中的类文件，它是所有类<br>加载器的父加载器， Bootstrap ClassLoader 没有任何父类加载器 。 Extension ClassLoader 负责加<br>载 Java 的扩展类库，也就是从 jre/lib/ext 目录下或者 java.ext.dirs 系统属性指定的目录下加载类</p>
<p>System ClassLoader 负责从 classpath 环境变量中加载类文件， classpath 环境变量通常由飞classpath ”<br>或“ －cp ＂命令行选项来定义，或是由 JAR 中 Manifest 文件的 classpath 属性指定 。 System<br>ClassLoader 是 Extension ClassLoader 的子加载器</p>
<p>静态内部类的单例模式写法，这种写法也可以实现<br>延迟加载的相关，且通过类加载机制保证只创建一个单例对象  缺点不能传参</p>
<p>VFS 表示虚拟文件系统 （ Virtual File System ） ， 它用来查找指定路径下的资源。 VF S 是一个<br>抽象类 ， MyBatis 中提供了 JBoss6VFS 和 DefaultVFS 两个 VFS 的实现</p>
<p>MyBatis 提供了两个 javax.sql.DataSource 接口实现，分别是 PooledDataSource 和<br>UnpooledDataSource</p>
<p>数据源 动态代理connection。连接池 享元模式</p>
<p>Mybatis 使用不同的 DataSourceFactory 接口实现创建不同类型的<br>DataSource ，这是<strong>工厂方法模式</strong>的一个典型应用。</p>
<p>在实践开发 中， 控制数据库事务是一件非常重要的工作， MyBatis 使用 Transaction 接 口对<br>数据库事务进行了 抽象</p>
<p>Transaction 接口有 JdbcTransaction 、 ManagedTransaction 两个实现，其对象分别 由<br>JdbcTransactionFactory 和 ManagedTransactionFactory 负 责创建 。这里也使用了<br>工厂方法模式</p>
<p>JdbcTransaction 依赖于 JDBC Connection 控制事务的提交和回滚</p>
<p>MyBatis 通常会与 Spring 集成使用， 数据库的事务是交给 Spring 进行管理的  Transaction 接口 的另一个实现一－SpringManagedTransaction</p>
<p>MapperRegistry Mapper 接口及其对应的代理对象工厂的注册中心。</p>
<p>Configuration.mapperRegistry字段</p>
<p>在 MyBatis 初始化过程中会读取映射配置文件以及 Mapper 接 口中 的注解信息 ，并调用<br>MapperRegistry.addMapperO方法填充 MapperRegistry.knownMappers 集合 ， 该集合的 key 是<br>Mapper 接口对应的 Class 对象， value 为 MapperProxyFactory 工厂对象，可以为 Mapper 接口创<br>建代理对象</p>
<p>MapperProxyFactory 主要负责创建代理对象.  MapperProxy是Invocationhandler</p>
<p>MapperMethod 中封装了 Mapper 接口中对应方法的信息，以及对应 SQL 语句的信息。读者<br>可以将 MapperMethod 看作连接 Mapper 接口以及映射配置文件中定义的 SQL 语句的桥梁。</p>
<p>SqlCommand 是 MapperMethod 中 定义的内部类，它使用 name 字段记录了 SQL 语句的名称，<br>使用 type 宇段（ SqlCommandType 类型）记录了 SQL 语句的类型</p>
<p>ParamNameResolver 使用 name 宇段（ SortedMap&lt;Integer, String＞类型）记录了参数在参<br>数列表中 的位置索 引与参数名称之间的对应关系</p>
<p>MethodSignature 也<br>是 MapperMethod 中 定义的内部类 ，其中封装了 Mapper 接口中定义的方法的相关信息</p>
<p>回到 MapperMethod 继续分析。 MapperMethod 中<br>最核心的方法是 execute（）方法，它会根据 SQL 语句的类型调用 SqISession 对应的方法完成数据<br>库操作。</p>
<p>通过对 XMLConfigBuilder.mapperElement（）方法的介绍我们知道 ， XMLMapperBuilder 负责<br>解析映射配置文件，它继承了 BaseBuilder 抽 象类，也是具体建造者 的角色</p>
<p>每个＜resultMap＞节点都会被解析成一个 ResultMap 对<br>象，其中每个节点所定义的映射关系 ，则使用 ResultMapping 对象表示</p>
<p>MyBatis 在处理动态 SQL 节点时，应用到了组合设计模式。 MyBatis 会将动态 SQL 节点解<br>析成对应的 SqINode 实现，并形成树形结构</p>
<p>DynamicContext 主要用于记录解析动态 SQL 语句之后产生的 SQL 语句片段，可以认为它<br>是一个用于记录动态 SQL 语句解析结果的容器</p>
<p>SqlNode 接口 有多个实现类，每个实现类对应一个动态 SQL 节点 ， 如图 3-16 所示。按照组<br>合模式的角色来划分， SqINode 扮演了抽象组件的角色， MixedSqlNode 扮演了树枝节点的角色，</p>
<p>TextSqlNode 节点扮演了树叶节点的角色，其他 SqlNode 实现的角色</p>
<p>DynamicSq!Source</p>
<p>如果不是动态的 SQL 节点 ，则创<br>建相应的 RawSqlSource 对象</p>
<p>DefaultResultSetHandler 是 MyBatis 提供的 ResultSetHandler 接口的唯 一 实现</p>
<p> 延迟加载。MyBatis 中提供了另外两种可<br>以为普通 JavaBean 动态生成代理对象的方式，分别是 CGLIB 方式和 JAVASSIST 方式</p>
<p>Javassist 也是通过创建目标类 的子类方式实现动态代理功能的</p>
<p>MyBatis 中与延迟加载相关的类有 ResultLoader、 ResultLoaderMap 、 ProxyFacto叩接口及实<br>现类</p>
<p>MyBatis 中 定义了 ProxyFactory 接口以及两个实现类，其中<br>Cgl ibProxyFactory 使用 cglib 方式创建代理对象， JavassitProxyFactory 使用 Javassit 方式创建代<br>理 。</p>
<p>通过前面对动态 SQL 的介绍可知，在 BoundSql 中记录的 SQL 语句中可能包含“？”占位<br>符，而每个 “？”占位符都对应了 BoundSql .parameterMappings 集合中的 一个元素，在该<br>ParameterMapping 对象 中记录了对应 的参数名称以及该参数的相关属性。</p>
<p>在 DefaultParameterHandler.setParameters（）方法中会遍历 BoundSql.parameterMappings 集合<br>中记录的 ParameterMapping 对象，井根据其中记录的参数名称查找相应实参 ， 然后与 SQL 语句<br>绑定</p>
<p>SimpleStatementHandler 继承了 BaseStatementHandler 抽象类。它底层使用 java. sql. Statement<br>对象来完成数据库的相关操作 ， 所以 SQL 语句中不能存在占位符 ， 相应的，<br>SimpleStatementHandler. parameterize（）方法是空实现</p>
<p>PreparedStatementHandler 底层依赖于 java.sq1.PreparedStatement 对象来完成数据库的相关操<br>作</p>
<p>CacheKey 对象</p>
<p>BaseExecutor 模版方法模式</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408162356761.png" alt="image-20240816235639344"></p>
<p>CacheKey 对象由 MappedStatement 的 id、对应的 offset 和 limit、 SQL<br>语句（包含“？”占位符）、用户传递的实参以及 Environment 的 id 这五部分构成</p>
<p>Executor 使用了模板方法模式， 一级缓存等固定不变的操作都封装到了 BaseExecutor 中 ，<br>在 SimpleExecutor 中就不必再关心一级缓存等操作，只需要专注实现 4 个基本方法的实现即可。</p>
<p>ReuseExecutor</p>
<p>重用 Statement 对象是常用的一种优化手段，该优化手段可以减少<br>SQL 预编译的开销以及创建和销毁 Statement 对象的开销，从而提高性能。</p>
<p>ReuseExecutor 提供了 Statement 重用的功能， ReuseExecutor 中通过 statementMap 字段<br>( Has灿fap<string, statement>类型） 缓存使用过的 Statement 对象， key 是 SQL 语句， value 是<br>SQL 对应的 Statement 对象</string,></p>
<p>熟悉 JDBC 编程的读者知道，<br>每个 Statement 对象只能对应一个结果集</p>
<p>BatchExecutor 批处理</p>
<p>JDBC 中的批处理只支持 inse挝、 update 、 delete 等类型的 SQL 语句，不支持 se lect 类型的<br>SQL 语句</p>
<p>熟悉 JDBC 批处理功能的读者知道， Statement 中可以添加不同模式的 SQL，但是每添加一<br>个新模式的 SQL 语句都会触发一次编译操作 。 PreparedStatement 中只能添加同一模式的 SQL<br>语句，只会触发一次编译操作，但是可以通过绑定多组不同的实参实现批处理</p>
<p>DefaultSq!Session 中使用到了策略模式，DefaultSq!Session 扮演了 Context 的角色，而将<br>所有数据库相关的操作全部封装到 Executor 接口实现中，并通过 executor 字段选择不同的<br>Executor 实现。</p>
<p>二级缓存。cacheEnabled</p>
<p>还会分析另 一 个 SqISession 接口的实现 一SqlSessionTemplate ， 它主要用于 MyBatis 与 Spring 的集成开发场景中</p>
<h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><p>拦截Executor RowBounds -&gt;limit sql语句</p>
<p>MyBatis RowBounds是用resultSet absolute() next() 实现的</p>
<p>将相关 limit 语句实现的分页功能修改成上述使用子查询和索引<br>的方式实现</p>
<h2 id="分表插件"><a href="#分表插件" class="headerlink" title="分表插件"></a>分表插件</h2><p>additionalParameters是什么?</p>
<h2 id="Mybatis与Spring集成"><a href="#Mybatis与Spring集成" class="headerlink" title="Mybatis与Spring集成"></a>Mybatis与Spring集成</h2><p>DriverManagerDataSource 数据源</p>
<p>MapperScannerConfigurer   扫描Mapper接口</p>
<p>DataSourceTransactionManager 事务管理器</p>
<p>SqlSessionFactoryBean</p>
<p>我们将 MyBatis 与 Spring 进行了集成，其中使用了 mybatis叩ringX.X.X.jar 这个 Jar 包 。该 JAR 的主要功能就是负责将 MyBatis 与 Spring 进行无缝集成， 该 jar<br>包可以将 MyBatis 的事务交给 Spring 来管理，还可以将 SqlSession 等对象交给 Spring 管理并由<br>Spring IoC 容器将 SqlSession 对象注入到其他 Spring Bean 中</p>
<p>MyBatis 中的 SqlSessionFactory 对象则 是由<br>SqlSessionFactoryBean 创建的</p>
<p> 如果在 applicationContext.xml 配置文件中没有明确为<br>Sq!SessionFactoryBean 指定 transactionF actory 属性 ，则在 buildSq!SessionFactory（）方法中默认使<br>用 SpringManagedTransactionFactory ， 该类实 现 了 TransactionFactory 接口，并实现了<br>newTransaction（）方法 ， 其 中返 回 的 Transaction 接口实现为 SpringManagedTransaction</p>
<p>SpringManagedTransaction.connection 字段维护 的 JDBC 连接来自 Spring 事务管理器</p>
<p>在 SpringManagedTransaction .commit（）方法和 rollback（）方法中，会根据连接是否由 Spring<br>管理以及事务是否要自动提交（即 isConnectionTransactional 和 autoCommit 两个字段的值），决<br>定是否真正提交／回漆事务</p>
<p>SqlSessionTemplate 是 MyB atis-Spring 的核心，它实现了 Sq!Session 接口，在 MyBati s 与<br>Spring 集 成开发时，用来代替 MyB atis 中的 DefaultSq!Session 的功能，所以可以 通过<br>Sq!SessionTemplate 对象完成指定的数据库操作。 Sq!SessionTemplate 是线程安全 的，可以在 DAO<br>( Data Access Object，数据访问对象）之间共享使用，其底层封装了 Spring 管理的 Sq!Session<br>对象</p>
<p>从 Spring 事务管理器中获取 SqISession<br>对象，如果获取成功则直接返回，否则通过 SqlSessionFactory 新建 Sq!Session 对象井将其交由<br>Spring 事务管理器管理</p>
<p>MapperFactoryBean初始化时把mapper接口注册到MapperRegistry  创建对应的 MapperProxyFactory 对象 ,</p>
<p>MapperProxyFactory就是代理对象 </p>
<p>MapperScannerConfigurer 实现了 BeanDefinitionRegistryPostProcessor 接口 ， 该接口中的<br>postProcessBeanDefinitionRegistry（） 方法会在系统初始化的过程中被调用，该方法是<br>MapperScannerConfigurer 实现扫描的关键</p>
<p>MyBatis-Generator 逆向工程</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring源码梳理]]></title>
      <url>/p/8vuge/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="下载源码-download-sources"><a href="#下载源码-download-sources" class="headerlink" title="下载源码(download sources)"></a>下载源码(download sources)</h1><p>mvn dependency:resolve -Dclassifier=sources</p>
<h1 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h1><h1 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h1><p>ImportBeanDefinitionRegistrar 和@Import配合。在最后 在DefferedImportSelector之前</p>
<p>DefferedImportSelector</p>
<p>BeanDefinitionRegistryPostProcessor 注册</p>
<p>BeanFactoryPostProcessor  修改</p>
<p>AbstractAutowireCapableBeanFactory#invokeAwareMethods</p>
<p>ApplicationContextAwareProcessor</p>
<p>ImportAwareBeanPostProcessor</p>
<p>ConfigurationClassPostProcessor</p>
<p>AOP设置。 </p>
<p>@EnableAspectJAutoProxy</p>
<p>//(proxyTargetClass = true) //强制CGLIB<br>//(exposeProxy = true) 在线程中暴露代理对象@EnableAspectJAutoProxy</p>
<p>AbstractAutoProxyCreator</p>
<p>Bean实例化</p>
<p>反射</p>
<p>factory-method 静态工厂.   AbstractBeanDefinition#factoryMethodName</p>
<p>factory-bean + factory-method 实例工厂.  AbstractBeanDefinition#factoryBeanName. @Bean</p>
<p>AnnotatedBeanDefinitionReader. 读取配置</p>
<p>ClassPathBeanDefinitionScanner</p>
<p>在 Spring 框架中，<code>@Qualifier</code> 注解用于在依赖注入时指定要注入的具体 bean。当有多个同类型的 bean 可供选择时，<code>@Qualifier</code> 可以帮助 Spring 确定要注入哪个 bean</p>
<p>IOC</p>
<p>工厂模式</p>
<p>动态代理</p>
<p>AOP    切点表达式 通知  </p>
<p>Aspect 有很多Advisor。 Advisor粒度更细</p>
<p>在没有循环依赖时是在初始化后创建动态代理 看类的方法是否和切点表达式匹配,匹配则创建动态代理</p>
<p>有循环依赖时在属性赋值时创建动态代理</p>
<p>AspectJ</p>
<p>编译</p>
<p>类加载</p>
<p>Bean实例化方式</p>
<h1 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h1><p>目标类需要实现接口,下面是一个demo</p>
<p>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">ISender</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>+msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxySender</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxySender</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println (<span class="string">"jdk proxy before"</span>);</span><br><span class="line">        Object res=method.invoke (target,args);</span><br><span class="line">        System.out.println (<span class="string">"jdk proxy after"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsSender smsSender=<span class="keyword">new</span> SmsSender ();</span><br><span class="line">        ISender sender= (ISender) Proxy.newProxyInstance (smsSender.getClass ().getClassLoader (),</span><br><span class="line">                smsSender.getClass ().getInterfaces (),</span><br><span class="line">                <span class="keyword">new</span> JdkProxySender (smsSender));</span><br><span class="line">        System.out.println (<span class="string">"代理对象："</span>+sender.getClass ().getName ());</span><br><span class="line">        System.out.println (<span class="string">"输出结果："</span>+sender.send (<span class="string">"zhangsan"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408122319850.png" alt="image-20240812231914510"></p>
<h1 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibSender</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println (<span class="string">"before"</span>);</span><br><span class="line">        Object res = methodProxy.invokeSuper (o, args);</span><br><span class="line">        System.out.println (<span class="string">"after"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer ();</span><br><span class="line">        enhancer.setSuperclass (PhoneSender.class);</span><br><span class="line">        enhancer.setCallback (<span class="keyword">new</span> CglibSender ());</span><br><span class="line">        PhoneSender sender = (PhoneSender)enhancer.create ();</span><br><span class="line">        System.out.println (<span class="string">"代理对象："</span>+sender.getClass ().getName ());</span><br><span class="line">        System.out.println (<span class="string">"输出结果："</span>+sender.send (<span class="string">"zhangsan"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408122324345.png" alt="image-20240812232414256"></p>
<p>targetFastClass</p>
<p>ProxyFastClass</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能</p>
<p>除此以外，aspectj 提供了两种另外的 AOP 底层实现：</p>
<ul>
<li><p>第一种是通过 ajc 编译器在<strong>编译</strong> class 类文件时，就把通知的增强功能，织入到目标类的字节码中</p>
</li>
<li><p>第二种是通过 agent 在<strong>加载</strong>目标类时，修改目标类的字节码，织入增强功能</p>
</li>
<li>作为对比，之前学习的代理是<strong>运行</strong>时生成新的字节码</li>
</ul>
<p>简单比较的话：</p>
<ul>
<li>aspectj 在编译和加载时，修改目标字节码，性能较高</li>
<li>aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强</li>
<li>但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行</li>
</ul>
<ol>
<li><p>AnnotationAwareAspectJAutoProxyCreator 的作用</p>
<ul>
<li>将高级 @Aspect 切面统一为低级 Advisor 切面</li>
<li>在合适的时机创建代理</li>
</ul>
</li>
<li><p>findEligibleAdvisors 找到有【资格】的 Advisors</p>
<ul>
<li>有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3</li>
<li>有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得</li>
</ul>
</li>
<li><p>wrapIfNecessary</p>
<ul>
<li><p>它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理</p>
</li>
<li><p>它内部使用ProxyFactory创建动态代理</p>
</li>
<li><p>它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create proxy if we have advice. </span></span><br><span class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">			Object proxy = createProxy(</span><br><span class="line">					bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			<span class="keyword">return</span> proxy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean中调用findEligibleAdvisors</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="built_in">Object</span>[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">      Class&lt;?&gt; beanClass, <span class="built_in">String</span> beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">List</span>&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>createProxy 使用ProxyFactory创建动态代理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">		proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">			<span class="comment">// Explicit handling of JDK proxy targets (for introduction advice scenarios)</span></span><br><span class="line">			<span class="keyword">if</span> (Proxy.isProxyClass(beanClass)) &#123;</span><br><span class="line">				<span class="comment">// Must allow for introductions; can't just set interfaces to the proxy's interfaces only.</span></span><br><span class="line">				<span class="keyword">for</span> (Class&lt;?&gt; ifc : beanClass.getInterfaces()) &#123;</span><br><span class="line">					proxyFactory.addInterface(ifc);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// No proxyTargetClass flag enforced, let's apply our default checks...</span></span><br><span class="line">			<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">				proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">		proxyFactory.addAdvisors(advisors);</span><br><span class="line">		proxyFactory.setTargetSource(targetSource);</span><br><span class="line">		customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">		proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">		<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">			proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Use original ClassLoader if bean class not locally loaded in overriding class loader</span></span><br><span class="line">		ClassLoader classLoader = getProxyClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp; classLoader != beanClass.getClassLoader()) &#123;</span><br><span class="line">			classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> proxyFactory.getProxy(classLoader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>下面是ProxyFactory创建动态代理的demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyFactory proxyFactory=<span class="keyword">new</span> ProxyFactory ();</span><br><span class="line">        proxyFactory.setTarget (<span class="keyword">new</span> Target1 ());</span><br><span class="line"></span><br><span class="line">        AspectJExpressionPointcut pointcut=<span class="keyword">new</span> AspectJExpressionPointcut ();</span><br><span class="line">        pointcut.setExpression (<span class="string">"execution(* foo())"</span>);</span><br><span class="line">        proxyFactory.addAdvisor (<span class="keyword">new</span> DefaultPointcutAdvisor (pointcut,(MethodInterceptor) invocation -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println (<span class="string">"before"</span>);</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed ();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println (<span class="string">"after"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Target1 proxy = (Target1) proxyFactory.getProxy ();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        proxyFactory.addInterface (I1.class);</span></span><br><span class="line"><span class="comment">//        I1 proxy = (I1) proxyFactory.getProxy ();</span></span><br><span class="line"></span><br><span class="line">        proxyFactory.setProxyTargetClass (<span class="keyword">true</span>);</span><br><span class="line">        Target1 proxy = (Target1) proxyFactory.getProxy ();</span><br><span class="line"></span><br><span class="line">        System.out.println (proxy.getClass ());</span><br><span class="line">        proxy.foo ();</span><br><span class="line">        proxy.bar ();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>proxyTargetClass是false,且有接口是jdk</p>
<p>proxyTargetClass是false,且没有接口是cglib</p>
<p>proxyTargetClass是true cgllib</p>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="Spring事务失效场景"><a href="#Spring事务失效场景" class="headerlink" title="Spring事务失效场景"></a>Spring事务失效场景</h2><h2 id="Spring事务传播"><a href="#Spring事务传播" class="headerlink" title="Spring事务传播"></a>Spring事务传播</h2><p>7种</p>
<p>jdbc保存点</p>
<p>banner打印</p>
<h1 id="Spring-Refresh"><a href="#Spring-Refresh" class="headerlink" title="Spring Refresh"></a>Spring Refresh</h1><p>CommandLineRunner. ApplicationRunner</p>
<p>springbean生命周期</p>
<p>BeanDefinition</p>
<p>实例化。(创建对象,反射调用构造函数)</p>
<p>属性赋值(@Autowired @Resource)</p>
<p>初始化</p>
<p>@PostConstrruct</p>
<p>initializingBean接口</p>
<p>init方法</p>
<p>销毁</p>
<p>@BeforeDestroy</p>
<p>disposable接口</p>
<p>Destroy</p>
<p>@Autowired.  Spring</p>
<p> @Resource.  Idk</p>
<p>Springmvc</p>
<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><ol>
<li>不是Spring的bean对象循环依赖直接把地址引用设置为对方就可以了,但是Spring逻辑不同,是在singletonObjects找,没找到就创建新对象,会发生死循环</li>
<li>因为一级缓存需要存储完整走完bean生命周期,所以一级缓存不能解决循环依赖,用二级缓存可以解决循环依赖问题,但是如果既有循环依赖又需要创建代理,如果用二级缓存存储代理对象那如果没发生循环依赖的对象也会在依赖注入阶段生成代理对象,和bean生命周期不符合,还是希望在没有发生循环依赖时在初始化后创建代理对象,所以采用三级缓存</li>
</ol>
<h2 id="字段-setter循环依赖"><a href="#字段-setter循环依赖" class="headerlink" title="字段/setter循环依赖"></a>字段/setter循环依赖</h2><p>下面是通过setter方法注入产生的循环依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger (<span class="string">"A"</span>);</span><br><span class="line">        <span class="keyword">private</span> B b;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"A()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"setB(&#123;&#125;)"</span>,b.getClass ());</span><br><span class="line">            <span class="keyword">this</span>.b=b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"initA()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println (<span class="string">"foo()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger (<span class="string">"B"</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"B()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"setA(&#123;&#125;)"</span>,a.getClass ());</span><br><span class="line">            <span class="keyword">this</span>.a=a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"initB()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Aspect</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span></span>&#123;</span><br><span class="line">        <span class="meta">@Before</span> (<span class="string">"execution(* foo())"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println (<span class="string">"before..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context=<span class="keyword">new</span> GenericApplicationContext ();</span><br><span class="line">        context.registerBean (<span class="string">"a"</span>,A.class);</span><br><span class="line">        context.registerBean (<span class="string">"b"</span>,B.class);</span><br><span class="line">        context.registerBean (MyAspect.class);</span><br><span class="line">        context.registerBean (AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors (context.getDefaultListableBeanFactory ());</span><br><span class="line">        context.refresh ();</span><br><span class="line"></span><br><span class="line">        context.getBean (A.class).foo ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><u>控制台输出效果</u></center>

<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191648215.png" alt="image-20240819164759933"></p>
<h3 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h3><ol>
<li>在doGetBean 调用getSingleton创建条件断点 条件是beanName.equals(“a”),这会在实例化前先看一,二,三级缓存有没有实例</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191529394.png" alt="image-20240819152958507"></p>
<ol>
<li>在doCreateBean(). 创建条件断点,条件是beanName.equals(“a”),在初始化后调用getSingleton,取二级缓存</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191536665.png" alt="image-20240819153614538"></p>
<p>第一次停在断点1是在A要实例化前,没有获取到,A实例化调用doCreateBean ,早期暴露,放入一个Objectfactory到三级缓存</p>
<p>第二次停在断点1是A依赖注入B,B要实例化,B实例化后依赖注入A, 调用populateBean(),内部再次调用doGetBean</p>
<p>第三次停在断点2是B初始化完成后</p>
<p>第四次停在断点2是A初始化完成后</p>
<h3 id="关键步骤分析"><a href="#关键步骤分析" class="headerlink" title="关键步骤分析"></a>关键步骤分析</h3><blockquote>
<p>doCreateBean在实例化前会调用addSingletonFactory  将一个函数式接口加入三级缓存</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> getSingleton当有循环依赖时会从三级缓存取出并调用,再放入二级缓存,同时清除三级缓存</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">					<span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">					singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">						<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">							ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">							<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">								singletonObject = singletonFactory.getObject();</span><br><span class="line">								<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">								<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AbstractAutoProxyCreator创建动态代理的时机"><a href="#AbstractAutoProxyCreator创建动态代理的时机" class="headerlink" title="AbstractAutoProxyCreator创建动态代理的时机"></a>AbstractAutoProxyCreator创建动态代理的时机</h3><ol>
<li>AbstractAutoProxyCreator#getEarlyBeanReference.  循环依赖。三级缓存取出的ObjectFactory调用getEarlyBeanReference</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">		<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>AbstractAutoProxyCreator#postProcessAfterInitialization  初始化后</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">				<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>用earlyProxyReferences作为判断条件,如果存在bean则不需要在初始化后创建动态代理</p>
<h2 id="构造器和多例循环依赖"><a href="#构造器和多例循环依赖" class="headerlink" title="构造器和多例循环依赖"></a>构造器和多例循环依赖</h2><p>Spring三级缓存解决不了,可以人为写代码设计解决</p>
<ol>
<li><p><font color="green">@Lazy</font>.   代理。</p>
</li>
<li><p>ObjectFactory   ObjectProvider 推迟Bean的创建</p>
</li>
</ol>
<h3 id="Lazy解决demo"><a href="#Lazy解决demo" class="headerlink" title="@Lazy解决demo"></a>@Lazy解决demo</h3><p>可以看出是创建了cglib动态代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger (<span class="string">"A"</span>);</span><br><span class="line">        <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"A(&#123;&#125;)"</span>,b.getClass ());</span><br><span class="line">            <span class="keyword">this</span>.b=b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"initA()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println (<span class="string">"foo()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger (<span class="string">"B"</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(@Lazy A a)</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"B(&#123;&#125;)"</span>,a.getClass ());</span><br><span class="line">            <span class="keyword">this</span>.a=a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">            log.debug (<span class="string">"initB()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context=<span class="keyword">new</span> GenericApplicationContext ();</span><br><span class="line">        context.registerBean (<span class="string">"a"</span>, A.class);</span><br><span class="line">        context.registerBean (<span class="string">"b"</span>, B.class);</span><br><span class="line">        context.registerBean (SetDemo.MyAspect.class);</span><br><span class="line">        context.registerBean (AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors (context.getDefaultListableBeanFactory ());</span><br><span class="line">        context.refresh ();</span><br><span class="line"></span><br><span class="line">        A a1 = context.getBean (A.class);</span><br><span class="line">        System.out.println (a1.getClass ());</span><br><span class="line">        a1.foo ();</span><br><span class="line">        A a2 = context.getBean (B.class).a;</span><br><span class="line">        System.out.println (a2.getClass ());</span><br><span class="line">        a2.foo ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><u>控制台输出效果</u></center>

<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191646833.png" alt="image-20240819164618571"></p>
<font color="green">@Lazy</font>相关源码

1. DefaultListableBeanFactory#resolveDependency 对成员变量或方法参数进行解析

![image-20240819165649186](https://gitee.com/mosheng123456789/pics/raw/master/img/202408191656405.png)

2. 判断是否有<font color="green">@Lazy</font>

<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408191658943.png" alt="image-20240819165829773"></p>
<ol>
<li>有<font color="green">@Lazy</font>调用buildLazyResolutionProxy,用ProxyFactory创建动态代理,TargetSource.getTarget()的设计推迟了对目标对象的获取</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">buildLazyResolutionProxy</span><span class="params">(<span class="keyword">final</span> DependencyDescriptor descriptor, <span class="keyword">final</span> @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">		BeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		Assert.state(beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory,</span><br><span class="line">				<span class="string">"BeanFactory needs to be a DefaultListableBeanFactory"</span>);</span><br><span class="line">		<span class="keyword">final</span> DefaultListableBeanFactory dlbf = (DefaultListableBeanFactory) beanFactory;</span><br><span class="line"></span><br><span class="line">		TargetSource ts = <span class="keyword">new</span> TargetSource() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">				<span class="keyword">return</span> descriptor.getDependencyType();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				Set&lt;String&gt; autowiredBeanNames = (beanName != <span class="keyword">null</span> ? <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">1</span>) : <span class="keyword">null</span>);</span><br><span class="line">				Object target = dlbf.doResolveDependency(descriptor, beanName, autowiredBeanNames, <span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">					Class&lt;?&gt; type = getTargetClass();</span><br><span class="line">					<span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">						<span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (List.class == type) &#123;</span><br><span class="line">						<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (Set.class == type || Collection.class == type) &#123;</span><br><span class="line">						<span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(descriptor.getResolvableType(),</span><br><span class="line">							<span class="string">"Optional dependency not present for lazy injection point"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">						<span class="keyword">if</span> (dlbf.containsBean(autowiredBeanName)) &#123;</span><br><span class="line">							dlbf.registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> target;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		ProxyFactory pf = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">		pf.setTargetSource(ts);</span><br><span class="line">		Class&lt;?&gt; dependencyType = descriptor.getDependencyType();</span><br><span class="line">		<span class="keyword">if</span> (dependencyType.isInterface()) &#123;</span><br><span class="line">			pf.addInterface(dependencyType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pf.getProxy(dlbf.getBeanClassLoader());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><p>@SpringBootApplication</p>
<p>自动配置类</p>
<h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><h2 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h2><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>创建SpringApplication实例,调用run方法</p>
<p>准备ApplicationContext对象(里面有BeanFactory)</p>
<p>监听器</p>
<p>环境对象</p>
<p>banner打印</p>
<h1 id="spring设计模式"><a href="#spring设计模式" class="headerlink" title="spring设计模式"></a>spring设计模式</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>spring事件发布,事件监听</p>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>模板设计模式, refresh() 大流程已经固定好了, 通过接口回调(beanfactory 后处理器,bean 后处理器)扩展</p>
<p>xxxTempplate,AbstractXXX </p>
<p>JdbcTemplate,TransactionTemplate</p>
<p>AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>BeanFactory#getBean(). 简单工厂模式</p>
<p>FactoryBean#getObject() 工厂方法模式</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>AOP和事务</p>
<p>jdk动态代理和cglib动态代理</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>proxyTagetClass 默认是false</p>
<p>proxyTagetClass是false,代理的类实现接口时用jdk</p>
<p>proxyTagetClass是true,或者proxyTagetClass是false并且代理的类没有实现接口时用cglib</p>
<p>选择JDK代理或者CGLIB代理使用到了策略模式</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>HandlerAdapter</p>
<h2 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h2><p>拦截器HandlerInterceptor</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式</p>
<h1 id="自定义Spring框架"><a href="#自定义Spring框架" class="headerlink" title="自定义Spring框架"></a>自定义Spring框架</h1><p>要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：</p>
<ul>
<li>ClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。</li>
<li>FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。</li>
<li>AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。</li>
</ul>
<p>BeanDefinitionReader 包含一个BeanDefinitionRegistry ,   BeanDefinitionRegistry 内部beanDefinitionMap</p>
<p>DefaultListableBeanFactory 是BeanDefinitionReader,    singletonObjects</p>
<p>BeanFactory定义的工厂方法从singletonObjects取Bean</p>
<p>BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry</p>
<p>DefaultListableBeanFactory</p>
<p>DefaultSingletonBeanRegistry</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="keyword">HashMap</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>配置类、xml、组件扫描等方式都是生成 bean definition 对象注册到 beanFactory</p>
<ul>
<li><p>beanFactory 需要手动调用 beanFactory 后处理器对它做增强</p>
<ul>
<li>例如通过解析 @Bean、@ComponentScan 等注解，来补充一些 bean definition</li>
</ul>
</li>
<li><p>beanFactory 需要手动添加 bean 后处理器，以便对后续 bean 的创建过程提供增强</p>
<ul>
<li>例如 @Autowired，@Resource 等注解的解析都是 bean 后处理器完成的</li>
<li><p>bean 后处理的添加顺序会对解析结果有影响</p>
</li>
<li><p>beanFactory 需要手动调用方法来初始化单例</p>
</li>
<li>beanFactory 需要额外设置才能解析 ${} 与 #{}</li>
</ul>
</li>
</ul>
<ol>
<li>@Autowired 等注解的解析属于 bean 生命周期阶段（依赖注入, 初始化）的扩展功能，这些扩展功能由 bean 后处理器来完成</li>
<li>每个后处理器各自增强什么功能<ul>
<li>AutowiredAnnotationBeanPostProcessor 解析 @Autowired 与 @Value</li>
<li>CommonAnnotationBeanPostProcessor 解析 @Resource、@PostConstruct、@PreDestroy</li>
<li>ConfigurationPropertiesBindingPostProcessor 解析 @ConfigurationProperties</li>
</ul>
</li>
<li>另外 ContextAnnotationAutowireCandidateResolver 负责获取 @Value 的值，解析 @Qualifier、泛型、@Lazy 等</li>
</ol>
<p>Bean工厂后置处理器。补充了一些 bean 定义</p>
<ul>
<li>ConfigurationClassPostProcessor 可以解析<ul>
<li>@ComponentScan</li>
<li>@Bean</li>
<li>@Import</li>
<li>@ImportResource</li>
</ul>
</li>
<li>MapperScannerConfigurer 可以解析<ul>
<li>Mapper 接口</li>
</ul>
</li>
</ul>
<p>ComponentScanPostProcessor</p>
<p>Spring 操作元数据的工具类 CachingMetadataReaderFactory</p>
<p>注解元数据（AnnotationMetadata）获取方法上注解信息</p>
<p>通过类元数据（ClassMetadata）获取类名</p>
<p>解析元数据是基于 ASM 技术</p>
<p>Mapper 接口被 Spring 管理的本质：实际是被作为 MapperFactoryBean 注册到容器中</p>
<p>Aware 接口提供了一种【内置】 的注入手段</p>
<p>InitializingBean 接口提供了一种【内置】的初始化手段</p>
<ul>
<li>内置的注入和初始化不受扩展功能的影响，总会被执行</li>
<li>而扩展功能受某些情况影响可能会失效</li>
<li>因此 Spring 框架内部的类常用内置注入和初始化</li>
</ul>
<p>AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能</p>
<p>除此以外，aspectj 提供了两种另外的 AOP 底层实现：</p>
<ul>
<li><p>第一种是通过 ajc 编译器在<strong>编译</strong> class 类文件时，就把通知的增强功能，织入到目标类的字节码中</p>
</li>
<li><p>第二种是通过 agent 在<strong>加载</strong>目标类时，修改目标类的字节码，织入增强功能</p>
</li>
<li>作为对比，之前学习的代理是<strong>运行</strong>时生成新的字节码</li>
</ul>
<p>简单比较的话：</p>
<ul>
<li>aspectj 在编译和加载时，修改目标字节码，性能较高</li>
<li>aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强</li>
<li>但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行</li>
</ul>
<p>代理一点都不难，无非就是利用了多态、反射的知识</p>
<ol>
<li>方法重写可以增强逻辑，只不过这【增强逻辑】千变万化，不能写死在代理内部</li>
<li>通过接口回调将【增强逻辑】置于代理类之外</li>
<li>配合接口方法反射（是多态调用），就可以再联动调用目标方法</li>
<li>会用 arthas 的 jad 工具反编译代理类</li>
<li>限制⛔：代理增强是借助多态来实现，因此成员变量、静态方法、final 方法均不能通过代理实现</li>
</ol>
<p>和 jdk 动态代理原理查不多</p>
<ol>
<li>回调的接口换了一下，InvocationHandler 改成了 MethodInterceptor</li>
<li>调用目标时有所改进，见下面代码片段<ol>
<li>method.invoke 是反射调用，必须调用到足够次数才会进行优化</li>
<li>methodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）</li>
<li>methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象</li>
</ol>
</li>
</ol>
<ol>
<li>当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类<ul>
<li>ProxyFastClass 配合代理对象一起使用, 避免反射</li>
<li>TargetFastClass 配合目标对象一起使用, 避免反射 (Spring 用的这种)</li>
</ul>
</li>
<li>TargetFastClass 记录了 Target 中方法与编号的对应关系<ul>
<li>save(long) 编号 2</li>
<li>save(int) 编号 1</li>
<li>save() 编号 0</li>
<li>首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号</li>
<li>然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射</li>
</ul>
</li>
<li>ProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法<ul>
<li>saveSuper(long) 编号 2，不增强，仅是调用 super.save(long)</li>
<li>saveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)</li>
<li>saveSuper() 编号 0，不增强, 仅是调用 super.save()</li>
<li>查找方式与 TargetFastClass 类似</li>
</ul>
</li>
<li>为什么有这么麻烦的一套东西呢？<ul>
<li>避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法</li>
<li>用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死</li>
</ul>
</li>
</ol>
<ol>
<li>AnnotationAwareAspectJAutoProxyCreator 的作用<ul>
<li>将高级 @Aspect 切面统一为低级 Advisor 切面</li>
<li>在合适的时机创建代理</li>
</ul>
</li>
<li>findEligibleAdvisors 找到有【资格】的 Advisors<ul>
<li>有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3</li>
<li>有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得</li>
</ul>
</li>
<li>wrapIfNecessary<ul>
<li>它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理</li>
<li>它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</li>
</ul>
</li>
</ol>
<p>静态通知调用</p>
<p>ProxyFactory</p>
<p>MethodInvocation</p>
<p>动态通知调用</p>
<p>RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter 俩是一对，分别用来</p>
<ul>
<li>处理 @RequestMapping 映射</li>
<li>调用控制器方法、并处理方法参数与方法返回值</li>
</ul>
<p>SpringBoot启动过程</p>
<p>阶段一：SpringApplication 构造</p>
<ol>
<li>记录 BeanDefinition 源</li>
<li>推断应用类型</li>
<li>记录 ApplicationContext 初始化器</li>
<li>记录监听器</li>
<li>推断主启动类</li>
</ol>
<p>阶段二：执行 run 方法</p>
<ol>
<li><p>得到 SpringApplicationRunListeners，名字取得不好，实际是事件发布器</p>
<ul>
<li>发布 application starting 事件1️⃣</li>
</ul>
</li>
<li><p>封装启动 args</p>
</li>
<li><p>准备 Environment 添加命令行参数（*）</p>
</li>
<li><p>ConfigurationPropertySources 处理（*）</p>
<ul>
<li>发布 application environment 已准备事件2️⃣</li>
</ul>
</li>
<li><p>通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理（*）</p>
<ul>
<li>application.properties，由 StandardConfigDataLocationResolver 解析</li>
<li>spring.application.json</li>
</ul>
</li>
<li><p>绑定 spring.main 到 SpringApplication 对象（*）</p>
</li>
<li><p>打印 banner（*）</p>
</li>
<li><p>创建容器</p>
</li>
<li><p>准备容器</p>
<ul>
<li>发布 application context 已初始化事件3️⃣</li>
</ul>
</li>
<li><p>加载 bean 定义</p>
<ul>
<li>发布 application prepared 事件4️⃣</li>
</ul>
</li>
<li><p>refresh 容器</p>
<ul>
<li>发布 application started 事件5️⃣</li>
</ul>
</li>
<li><p>执行 runner</p>
<ul>
<li><p>发布 application ready 事件6️⃣</p>
</li>
<li><p>这其中有异常，发布 application failed 事件</p>
</li>
</ul>
</li>
</ol>
<p>@PropertySource </p>
<p>Spring Boot 实现热部署有哪几种方式</p>
<p>Spring Loaded、Spring-boot-devtools</p>
<p>先从缓存找 找不到再实例化 加入三级缓存</p>
<p>初始化完成后加入一级缓存删除二三级缓存</p>
<h1 id="Spring事务源码解析"><a href="#Spring事务源码解析" class="headerlink" title="Spring事务源码解析"></a>Spring事务源码解析</h1><p>编程式事务TransactionTemplate.  回滚设置transactionStatus.rollbackOnly()</p>
<p>相关类 ProxyTransactionManagementConfiguration</p>
<p>Spring的事务信息是存在ThreadLocal中的transactionInfo</p>
<p>这里分析声明式事务</p>
<h2 id="生成代理对象"><a href="#生成代理对象" class="headerlink" title="生成代理对象"></a>生成代理对象</h2><blockquote>
<p>配置事务 <font color="green">@EnableTransactionManagement</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 这里默认是 AdviceMode.PROXY 下面会用到</span></span><br><span class="line">   <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 优先级为最低</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color="green">@Import</font>会将TransactionManagementConfigurationSelector类的方法返回的类向Spring容器注入对应的Bean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManagementConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableTransactionManagement</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">      <span class="comment">// 通过上面的注解我们知道 adviceMode的默认值是 PROXY</span></span><br><span class="line">      <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">         <span class="keyword">case</span> PROXY:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">                  ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">         <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionManagementConfigurationSelector 重写了 <code>selectImports</code> 导入了两个Bean</p>
<ol>
<li>AutoProxyRegistrar     注册InfrastructureAdvisorAutoProxyCreator,这个Bean可以创建动态代理</li>
<li>ProxyTransactionManagementConfiguration   Advisor</li>
</ol>
<h3 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h3><blockquote>
<p>在refresh() 中调用invokeBeanFactoryPostProcessors(beanFactory) 中ConfigurationClassPostProcessor会调用ImportBeanDefinitionRegistrar<font color="red">(就是AutoProxyRegistrar)</font>的registerBeanDefinitions方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    	AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InfrastructureAdvisorAutoProxyCreator"><a href="#InfrastructureAdvisorAutoProxyCreator" class="headerlink" title="InfrastructureAdvisorAutoProxyCreator"></a>InfrastructureAdvisorAutoProxyCreator</h4><blockquote>
<p>AutoProxyRegistrar可以向spring容器注册BeanDefinition,即InfrastructureAdvisorAutoProxyCreator</p>
</blockquote>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408181135373.png" alt="image-20240818113548020"></p>
<p>可以看出InfrastructureAdvisorAutoProxyCreator是一个Bean后置处理器,在Bean初始化后会调用<code>postProcessAfterInitialization</code>,</p>
<p>模版方法模式  子类实现<code>getAdvicesAndAdvisorsForBean</code></p>
<p>AbstractAutoProxyCreator重写了<code>postProcessAfterInitialization</code> 和 <code>wrapIfNecessary</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">         <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">	 <span class="comment">//拿当前bean去匹配容器中的 Advisors，如果找到符合的就生成代理对象</span></span><br><span class="line">   <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">      Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">      <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">      Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">   List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h3><p>这个类注册了三个Bean</p>
<ol>
<li>TransactionInterceptor AOP的通知，也就是生成了对象所要执行的增强逻辑在这个类的invoke方法中。</li>
<li>AnnotationTransactionAttributeSource  事务注解属性。 </li>
<li>BeanFactoryTransactionAttributeSourceAdvisor  <strong>Advisor=切点（Pointcut）+ 通知（Advice），</strong>它里面包含了上面两个属性，将TransactionAttributeSource封装成切点,也就指定要对哪些bean需要生成代理，哪些方法执行时候的需要拦截。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line">   <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">      advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">      advisor.setAdvice(transactionInterceptor);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</span><br><span class="line">         advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> advisor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TransactionAttributeSource 是一个接口，具体注入的是 Annotationxxxx</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">      TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">      interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">         interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> interceptor;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>new AnnotationTransactionAttributeSource()的方法调用会设置SpringTransactionAnnotationParser</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经不再用JTA和EJB，所以最终的实现是 SpringTransactionAnnotationParser</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationTransactionAttributeSource</span><span class="params">(<span class="keyword">boolean</span> publicMethodsOnly)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringTransactionAnnotationParser 是用来解析@Transactional 的，这里生成的是<code>RuleBasedTransactionAttribute</code> ，并且把rollbackFor参数赋值到了rollbackRules 里面去。（后面异常回滚的时候会用到,作为判断条件）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">   RuleBasedTransactionAttribute rbta = <span class="keyword">new</span> RuleBasedTransactionAttribute();</span><br><span class="line"></span><br><span class="line">   Propagation propagation = attributes.getEnum(<span class="string">"propagation"</span>);</span><br><span class="line">   rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">   Isolation isolation = attributes.getEnum(<span class="string">"isolation"</span>);</span><br><span class="line">   rbta.setIsolationLevel(isolation.value());</span><br><span class="line"></span><br><span class="line">   rbta.setTimeout(attributes.getNumber(<span class="string">"timeout"</span>).intValue());</span><br><span class="line">   String timeoutString = attributes.getString(<span class="string">"timeoutString"</span>);</span><br><span class="line">   Assert.isTrue(!StringUtils.hasText(timeoutString) || rbta.getTimeout() &lt; <span class="number">0</span>,</span><br><span class="line">         <span class="string">"Specify 'timeout' or 'timeoutString', not both"</span>);</span><br><span class="line">   rbta.setTimeoutString(timeoutString);</span><br><span class="line"></span><br><span class="line">   rbta.setReadOnly(attributes.getBoolean(<span class="string">"readOnly"</span>));</span><br><span class="line">   rbta.setQualifier(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">   rbta.setLabels(Arrays.asList(attributes.getStringArray(<span class="string">"label"</span>)));</span><br><span class="line"></span><br><span class="line">   List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"rollbackFor"</span>)) &#123;</span><br><span class="line">      rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"rollbackForClassName"</span>)) &#123;</span><br><span class="line">      rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"noRollbackFor"</span>)) &#123;</span><br><span class="line">      rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"noRollbackForClassName"</span>)) &#123;</span><br><span class="line">      rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">   &#125;</span><br><span class="line">   rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理对象执行事务方法的逻辑"><a href="#代理对象执行事务方法的逻辑" class="headerlink" title="代理对象执行事务方法的逻辑"></a>代理对象执行事务方法的逻辑</h2><p>事务最基本的功能有三个<strong>开启、提交、回滚</strong>。所以Spring事务里面就用了事务管理器来管理这三个方法</p>
<p>但事务具体的实现因不同厂商而有所不同，但大体的框架是相同的（就像不同的汽车总是四个轮子一样）。所以Spring使用了模板模式来定义通用的模板，细节交由具体的子类实现</p>
<ol>
<li>TransactionInterceptor实现了MethodInterceptor，所以每个代理对象执行方法的时候都会被拦截，判断是否要执行加强的方法。</li>
<li>TransactionInterceptor不做过多的逻辑处理，事务的处理交给它的父类TransactionAspectSupport 处理，TransactionAspectSupport中持有TM（事务管理器）基于此来实现事务的开启、提交、回滚</li>
</ol>
<p>上面我们已经看到了使用 <font color="green">@Transactional</font>都会被AOP代理，而代理执行的增强逻辑由 <code>TransactionInterceptor</code></p>
<p>处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<h3 id="事务方法执行入口"><a href="#事务方法执行入口" class="headerlink" title="事务方法执行入口"></a>事务方法执行入口</h3><h4 id="TransactionAspectSupport"><a href="#TransactionAspectSupport" class="headerlink" title="TransactionAspectSupport"></a>TransactionAspectSupport</h4><p><mark>TransactionInterceptor</mark>就是一个方法级别的拦截器，实现 MethodInterceptor 接口，重写了invoke方法。并继承了<font color="yellow" style="background:red">TransactionAspectSupport</font>，这个类是事务的核心方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>虽然拦截器是TransactionInterceptor，但它里面只有一个<code>invoke</code>，真正干活的是TransactionAspectSupport。</p>
<p><mark>TransactionInterceptor</mark>#invoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">   Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Adapt to TransactionAspectSupport's invokeWithinTransaction...</span></span><br><span class="line">   <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> CoroutinesInvocationCallback() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="meta">@Nullable</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> invocation.getThis();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">         <span class="keyword">return</span> invocation.getArguments();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="yellow" style="background:red">TransactionAspectSupport</font>#invokeWithinTransaction</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取当前方法的事务注解</span></span><br><span class="line">   TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">   <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// 这个下面细说，获取的是 JdbcTransactionManager</span></span><br><span class="line">   <span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ... 这里删掉了一些不会走的代码</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 父类转换成子类，方面后面的模版方法使用。 下面解释</span></span><br><span class="line">   PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">   <span class="comment">// 获取我们当前被拦截的方法全限定名</span></span><br><span class="line">   <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line">   <span class="comment">// 开始执行事务逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">      <span class="comment">// 根据事务配置来执行对应的事务</span></span><br><span class="line">      TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">      Object retVal;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行原始方法</span></span><br><span class="line">         retVal = invocation.proceedWithInvocation();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="comment">// 异常回滚事务</span></span><br><span class="line">         completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 清除当前事务信息</span></span><br><span class="line">         cleanupTransactionInfo(txInfo);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 提交事务</span></span><br><span class="line">      commitTransactionAfterReturning(txInfo);</span><br><span class="line">      <span class="keyword">return</span> retVal;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><blockquote>
<p>事务管理器类图</p>
</blockquote>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408181244695.png" alt="image-20240818124442516"></p>
<blockquote>
<p>PlatformTransactionManager 继承了TransactionManager，它里面定义了一个事务的三个基本方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractPlatformTransactionManager"><a href="#AbstractPlatformTransactionManager" class="headerlink" title="AbstractPlatformTransactionManager"></a>AbstractPlatformTransactionManager</h4><p><font color="red">模版方法模式</font>，它重写了事务的三个方法，定义了每个方法的执行流程。  有三个抽象方法doGetTransaction(),doCommit(),doRollBack()交由子类实现，我们使用的实现类是<code>DataSourceTransactionManager</code></p>
<h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><p><font color="yellow" style="background:red">TransactionAspectSupport</font>#createTransactionIfNecessary</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// ..</span></span><br><span class="line">   <span class="comment">// 开启事务</span></span><br><span class="line">   status = tm.getTransaction(txAttr);</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 这里其实就是把当前事务的信息封装成一个【TransactionInfo】，并把它绑定到当前的Thread上（实现上基于 ThreadLocal）</span></span><br><span class="line">   <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务执行逻辑"><a href="#事务执行逻辑" class="headerlink" title="事务执行逻辑"></a>事务执行逻辑</h4><p>org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">   TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获取当前事务</span></span><br><span class="line">   Object transaction = doGetTransaction();</span><br><span class="line">   <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 判断当前是否有事务，如果有就执行 handleExistingTransaction</span></span><br><span class="line">   <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">      <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">      <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 下面就是没有当前事务的操作了</span></span><br><span class="line">   <span class="comment">// 如果当前没有事务，但传播行为是【MANDATORY】就异常，因为这个行为要求必须有当前事务</span></span><br><span class="line">   <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在没有事务的前提下【REQUIRED、REQUIRES_NEW、NESTED】所表现的都一样——创建新的事务</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">         def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">         def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">      SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Creating new transaction with name ["</span> + def.getName() + <span class="string">"]: "</span> + def);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">         resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个空的事务——也就是没有事务</span></span><br><span class="line">      <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">      <span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="当前存在事务的逻辑"><a href="#当前存在事务的逻辑" class="headerlink" title="当前存在事务的逻辑"></a>当前存在事务的逻辑</h5><p>AbstractPlatformTransactionManager#handleExistingTransaction</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码为了简洁去掉了打印日志的代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 传播行为是【NEVER】，就抛出异常</span></span><br><span class="line">   <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">"Existing transaction found for transaction marked with propagation 'never'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 传播行为是【NOT_SUPPORTED】，就suspend（暂停）当前事务</span></span><br><span class="line">   <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">   </span><br><span class="line">      Object suspendedResources = suspend(transaction);</span><br><span class="line">      <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">      <span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">            definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 传播行为是【REQUIRES_NEW】，就suspend（暂停）当前事务，并开启新事务</span></span><br><span class="line">   <span class="keyword">if</span> (definition.getPropagationBehavior() ==TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line"></span><br><span class="line">      SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() !=SYNCHRONIZATION_NEVER);</span><br><span class="line">				DefaultTransactionStatus status = newTransactionStatus(definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">				doBegin(transaction, definition);</span><br><span class="line">				prepareSynchronization(status, definition);</span><br><span class="line">				<span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">         <span class="comment">// 异常了话，就恢复之前的事务</span></span><br><span class="line">         resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">         <span class="keyword">throw</span> beginEx;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 传播行为是【NESTED】，开启嵌套事务</span></span><br><span class="line">   <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">      <span class="comment">// 不是所有的数据库都支持嵌套事务，先判断</span></span><br><span class="line">      <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(</span><br><span class="line">               <span class="string">"Transaction manager does not allow nested transactions by default - "</span> +</span><br><span class="line">               <span class="string">"specify 'nestedTransactionAllowed' property with value 'true'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回是否对嵌套事务使用保存点。 JTA不支持，但是我们也不用JTA</span></span><br><span class="line">      <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">         DefaultTransactionStatus status =</span><br><span class="line">               prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">         status.createAndHoldSavepoint();</span><br><span class="line">         <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 其它情况 开始新事务</span></span><br><span class="line">         <span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">   <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="开启新事务"><a href="#开启新事务" class="headerlink" title="开启新事务"></a>开启新事务</h5><blockquote>
<p><strong>doBegin()</strong> 开启新事务  是一个抽象方法，在这里我们的实现子类是<strong>DataSourceTransactionManager</strong>，这个方法主要是为当前线程绑定一个 <code>Connection</code>，并把我们事务要求的属性设置进去。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionManager.DataSourceTransactionObject txObject = (DataSourceTransactionManager.DataSourceTransactionObject)transaction;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">        Connection newCon = <span class="keyword">this</span>.obtainDataSource().getConnection();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Acquired Connection ["</span> + newCon + <span class="string">"] for JDBC transaction"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">    con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">    txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">    txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line">    <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">        txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.prepareTransactionalConnection(con, definition);</span><br><span class="line">    txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="keyword">this</span>.determineTimeout(definition);</span><br><span class="line">    <span class="keyword">if</span> (timeout != -<span class="number">1</span>) &#123;</span><br><span class="line">        txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">        TransactionSynchronizationManager.bindResource(<span class="keyword">this</span>.obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建当前事务状态信息"><a href="#创建当前事务状态信息" class="headerlink" title="创建当前事务状态信息"></a>创建当前事务状态信息</h5><p>AbstractPlatformTransactionManager#prepareTransactionStatus</p>
<p>创建事务状态管理器，其实就是把和新事务相关的信息存放起来，来看看它的属性信息。</p>
<ol>
<li>definition  当前新事务的属性信息</li>
<li>transaction 旧事务信息</li>
<li>newTransaction 是否要开启新事务</li>
<li>newSynchronization 新事物是否要同步</li>
<li>debug 日志打印器</li>
<li>suspendedResources 当前被暂停的事务资源信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> DefaultTransactionStatus <span class="title">prepareTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      TransactionDefinition definition, @Nullable Object transaction, <span class="keyword">boolean</span> newTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> newSynchronization, <span class="keyword">boolean</span> debug, @Nullable Object suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">         definition, transaction, newTransaction, newSynchronization, debug, suspendedResources);</span><br><span class="line">   prepareSynchronization(status, definition);</span><br><span class="line">   <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建当前事务信息、绑定到当前线程"><a href="#创建当前事务信息、绑定到当前线程" class="headerlink" title="创建当前事务信息、绑定到当前线程"></a>创建当前事务信息、绑定到当前线程</h4><p><font color="yellow" style="background:red">TransactionAspectSupport</font>#prepareTransactionInfo</p>
<p>基于上面创建的事务状态等信息，组装成一个全面的事务信息<code>TransactionInfo</code>，并把它绑定到当前Thread上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">prepareTransactionInfo</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable TransactionAttribute txAttr, String joinpointIdentification,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable TransactionStatus status)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 创建事务信息</span></span><br><span class="line">   TransactionInfo txInfo = <span class="keyword">new</span> TransactionInfo(tm, txAttr, joinpointIdentification);</span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置事务状态是不是新的</span></span><br><span class="line">      txInfo.newTransactionStatus(status);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No need to create transaction for ["</span> + joinpointIdentification +</span><br><span class="line">               <span class="string">"]: This method is not transactional."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 绑定事务到当前线程</span></span><br><span class="line">   txInfo.bindToThread();</span><br><span class="line">   <span class="keyword">return</span> txInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置事务管理器、事务属性、事务连接点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransactionInfo</span><span class="params">(@Nullable PlatformTransactionManager transactionManager,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable TransactionAttribute transactionAttribute, String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">   <span class="keyword">this</span>.transactionAttribute = transactionAttribute;</span><br><span class="line">   <span class="keyword">this</span>.joinpointIdentification = joinpointIdentification;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="yellow" style="background:red">TransactionAspectSupport</font> 中ThreadLocal类型字段<code>transactionInfoHolder</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder =</span><br><span class="line">      <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current aspect-driven transaction"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><font color="yellow" style="background:red">TransactionAspectSupport</font>#completeTransactionAfterThrowing</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(@Nullable TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 判断事务状态是不是正常的</span></span><br><span class="line">   <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断当前是否存在事务信息，并判断当前异常是不是要被回滚</span></span><br><span class="line">      <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">         <span class="comment">// 回滚了</span></span><br><span class="line">         txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果不是回滚，那当然就是提交事务咯</span></span><br><span class="line">         txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());  </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rollbackOn"><a href="#rollbackOn" class="headerlink" title="rollbackOn"></a>rollbackOn</h4><p>上一篇文章我们说了，如果我们在使用事务注解时不指定回滚异常的话，有些异常它是不会回滚的（受检查的异常），就是通过这里判断的。</p>
<p>TransactionAttribute 是个接口它的实现类有如下，在上面提到了最终被解析的是 RuleBasedTransactionAttribute</p>
<p>事务注解上的回滚异常都会被解析存入rollbackRules里面去，这里就可以判断哪些异常是会被回滚的了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rollbackOn</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">   RollbackRuleAttribute winner = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">int</span> deepest = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.rollbackRules != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (RollbackRuleAttribute rule : <span class="keyword">this</span>.rollbackRules) &#123;</span><br><span class="line">         <span class="keyword">int</span> depth = rule.getDepth(ex);</span><br><span class="line">         <span class="keyword">if</span> (depth &gt;= <span class="number">0</span> &amp;&amp; depth &lt; deepest) &#123;</span><br><span class="line">            deepest = depth;</span><br><span class="line">            winner = rule;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// User superclass behavior (rollback on unchecked) if no rule matches.</span></span><br><span class="line">   <span class="keyword">if</span> (winner == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.rollbackOn(ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> !(winner <span class="keyword">instanceof</span> NoRollbackRuleAttribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rollback"><a href="#rollback" class="headerlink" title="rollback"></a>rollback</h4><p>AbstractPlatformTransactionManager#rollback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">   <span class="comment">// 判断事务是否已经结束</span></span><br><span class="line">   <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">"Transaction is already completed - do not call commit or rollback more than once per transaction"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">   processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 【事务钩子】 事务结束之前执行某某方法</span></span><br><span class="line">     triggerBeforeCompletion(status);</span><br><span class="line">     <span class="comment">// 判断是不是有保存点（嵌套事务），如果有把嵌套事务也要设置成回滚</span></span><br><span class="line">     <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">        status.rollbackToHeldSavepoint();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断是不是新事务</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        doRollback(status);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是不是参与了别的事务，参看上一章的事务传播行为</span></span><br><span class="line">        <span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">           <span class="comment">// 设置事务为回滚  isGlobalRollbackOnParticipationFailure 默认为 true</span></span><br><span class="line">           <span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">              <span class="comment">// 设置会只回滚状态【这也是上一章中为什么 try catch 了B方法，结果还是都回滚了的原因】</span></span><br><span class="line">              doSetRollbackOnly(status);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Unexpected rollback only matters here if we're asked to fail early</span></span><br><span class="line">        <span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">           unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 【事务钩子】 事务结束之后执行某某方法</span></span><br><span class="line">      triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line">      <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">               <span class="string">"Transaction rolled back because it has been marked as rollback-only"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 事务完成后清除信息</span></span><br><span class="line">      cleanupAfterCompletion(status);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清除事务信息"><a href="#清除事务信息" class="headerlink" title="清除事务信息"></a>清除事务信息</h3><p><font color="yellow" style="background:red">TransactionAspectSupport</font>#cleanupTransactionInfo</p>
<p>事务也是逐步提交的，如果当前事务上面还有事务，就把线程持有的事务设置为父事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanupTransactionInfo</span><span class="params">(@Nullable TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (txInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">      txInfo.restoreThreadLocalStatus();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreThreadLocalStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Use stack to restore old transaction TransactionInfo.</span></span><br><span class="line">   <span class="comment">// Will be null if none was set.</span></span><br><span class="line">   transactionInfoHolder.set(<span class="keyword">this</span>.oldTransactionInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p><font color="yellow" style="background:red">TransactionAspectSupport</font>#commitTransactionAfterReturning</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(@Nullable TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 判断当前事务的状态</span></span><br><span class="line">   <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用模板方法来提交事务</span></span><br><span class="line">      txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>org.springframework.transaction.support.AbstractPlatformTransactionManager#commit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">   <span class="comment">// 判断事务是否已经结束</span></span><br><span class="line">   <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">"Transaction is already completed - do not call commit or rollback more than once per transaction"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">   <span class="comment">// 如果事务被设置要回滚，那就回滚</span></span><br><span class="line">   <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Transactional code has requested rollback"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 全局事务被设置成要回滚</span></span><br><span class="line">   <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Global transaction is marked as rollback-only but transactional code requested commit"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      processRollback(defStatus, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 事务提交</span></span><br><span class="line">   processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> beforeCompletionInvoked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">     <span class="keyword">boolean</span> unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 提交之前的准备，空实现，  如果你有什么步骤需要提交之前执行可以重写</span></span><br><span class="line">     prepareForCommit(status);</span><br><span class="line">     <span class="comment">// 事务提交之前和完成之前的钩子方法</span></span><br><span class="line">     triggerBeforeCommit(status);</span><br><span class="line">     triggerBeforeCompletion(status);</span><br><span class="line">     beforeCompletionInvoked = <span class="keyword">true</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 判断是不是有保存点（嵌套事务）</span></span><br><span class="line">     <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">           logger.debug(<span class="string">"Releasing transaction savepoint"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">        status.releaseHeldSavepoint();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断是不是新事务</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">           logger.debug(<span class="string">"Initiating transaction commit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">        <span class="comment">// 事务提交【由具体的实现类去实现】</span></span><br><span class="line">        doCommit(status);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">        unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Throw UnexpectedRollbackException if we have a global rollback-only</span></span><br><span class="line">     <span class="comment">// marker but still didn't get a corresponding exception from commit.</span></span><br><span class="line">     <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">              <span class="string">"Transaction silently rolled back because it has been marked as rollback-only"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 事务提交够的钩子</span></span><br><span class="line">         triggerAfterCommit(status);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 事务完成后的钩子</span></span><br><span class="line">         triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 事务完成后清除</span></span><br><span class="line">      cleanupAfterCompletion(status);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionManager.DataSourceTransactionObject txObject = (DataSourceTransactionManager.DataSourceTransactionObject)status.getTransaction();</span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Committing JDBC transaction on Connection ["</span> + con + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到 Connection 连接提交事务</span></span><br><span class="line">        con.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">this</span>.translateException(<span class="string">"JDBC commit"</span>, var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Elasticsearch基本概念]]></title>
      <url>/p/8vugc/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lucene"><a href="#lucene" class="headerlink" title="lucene"></a>lucene</h1><p><strong>一个字段三种性质</strong>:分词 索引 存储</p>
<h2 id="Lucene-demo"><a href="#Lucene-demo" class="headerlink" title="Lucene-demo"></a>Lucene-demo</h2><p>索引文档的基本数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangxuefeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Float price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个方法创建索引index;第二个方法,搜索索引,返回索引文档的前10条;第三个方法创建索引index2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.queryparser.classic.ParseException;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.queryparser.classic.QueryParser;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.Query;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.store.Directory;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> sun.jvm.hotspot.oops.FloatField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangxuefeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuceneIndexTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;Book&gt;bookList=<span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">        Book booka=<span class="keyword">new</span> Book ();</span><br><span class="line">        booka.setId (<span class="number">1</span>);</span><br><span class="line">        booka.setName (<span class="string">"Lucene"</span>);</span><br><span class="line">        booka.setDesc (<span class="string">"Lucene test"</span>);</span><br><span class="line">        booka.setPrice (<span class="number">100.45f</span>);</span><br><span class="line">        Book bookb=<span class="keyword">new</span> Book ();</span><br><span class="line">        bookb.setId (<span class="number">11</span>);</span><br><span class="line">        bookb.setName (<span class="string">"Redis"</span>);</span><br><span class="line">        bookb.setDesc (<span class="string">"Redis test"</span>);</span><br><span class="line">        bookb.setPrice (<span class="number">102.45f</span>);</span><br><span class="line">        Book bookc=<span class="keyword">new</span> Book ();</span><br><span class="line">        bookc.setId (<span class="number">21</span>);</span><br><span class="line">        bookc.setName (<span class="string">"Hadoop"</span>);</span><br><span class="line">        bookc.setDesc (<span class="string">"Hadoop test"</span>);</span><br><span class="line">        bookc.setPrice (<span class="number">602.45f</span>);</span><br><span class="line">        bookList.add (booka);</span><br><span class="line">        bookList.add (bookb);</span><br><span class="line">        bookList.add (bookc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文档对象</span></span><br><span class="line">        List&lt;Document&gt;documents=<span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">        <span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">            Document document=<span class="keyword">new</span> Document ();</span><br><span class="line">            document.add (<span class="keyword">new</span> TextField (<span class="string">"id"</span>,book.getId ().toString (), Field.Store.YES));</span><br><span class="line">            document.add (<span class="keyword">new</span> TextField (<span class="string">"name"</span>,book.getName (), Field.Store.YES));</span><br><span class="line">            document.add (<span class="keyword">new</span> TextField (<span class="string">"price"</span>,book.getPrice ().toString (), Field.Store.YES));</span><br><span class="line">            document.add (<span class="keyword">new</span> TextField (<span class="string">"desc"</span>,book.getDesc (), Field.Store.YES));</span><br><span class="line">            documents.add (document);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建Analyser 对文档分词</span></span><br><span class="line">        Analyzer analyzer=<span class="keyword">new</span> StandardAnalyzer ();</span><br><span class="line">        <span class="comment">//创建Directory和IndexWriterConfig</span></span><br><span class="line">        Directory directory= FSDirectory.open (Paths.get (<span class="string">"/Users/zhangxuefeng/Documents/lucene/index"</span>));</span><br><span class="line">        IndexWriterConfig indexWriterConfig=<span class="keyword">new</span> IndexWriterConfig (analyzer);</span><br><span class="line">        <span class="comment">//创建IndexWriter写入对象</span></span><br><span class="line">        IndexWriter indexWriter=<span class="keyword">new</span> IndexWriter (directory,indexWriterConfig);</span><br><span class="line">        <span class="comment">//添加文档对象</span></span><br><span class="line">        <span class="keyword">for</span> (Document doc : documents) &#123;</span><br><span class="line">            indexWriter.addDocument (doc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indexWriter.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建query搜索对象</span></span><br><span class="line">        <span class="comment">//创建分词器</span></span><br><span class="line">        Analyzer analyzer=<span class="keyword">new</span> StandardAnalyzer ();</span><br><span class="line">        <span class="comment">//创建搜索解析器</span></span><br><span class="line">        QueryParser queryParser=<span class="keyword">new</span> QueryParser (<span class="string">"id"</span>,analyzer);</span><br><span class="line">        <span class="comment">//创建搜索对象</span></span><br><span class="line">        Query query= queryParser.parse (<span class="string">"desc:Hadoop OR name:Redis"</span>);</span><br><span class="line">        <span class="comment">//2 创建Directory流对象 指定索引库位置</span></span><br><span class="line">        Directory directory= FSDirectory.open (Paths.get (<span class="string">"/Users/zhangxuefeng/Documents/lucene/index"</span>));</span><br><span class="line">        <span class="comment">//3 创建索引读取对象</span></span><br><span class="line">        IndexReader indexReader= DirectoryReader.open (directory);</span><br><span class="line">        <span class="comment">//4 创建索引搜索对象</span></span><br><span class="line">        IndexSearcher indexSearcher=<span class="keyword">new</span> IndexSearcher (indexReader);</span><br><span class="line">        <span class="comment">//打分排序</span></span><br><span class="line">        System.out.println (indexSearcher.getSimilarity (<span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">//5 执行搜索 返回结果集 TopDocs</span></span><br><span class="line">        TopDocs topDocs=indexSearcher.search (query,<span class="number">10</span>);<span class="comment">//前10个</span></span><br><span class="line">        System.out.println (<span class="string">"查询到数据总条数："</span>+topDocs.totalHits);</span><br><span class="line">        <span class="comment">//获取排序的文档</span></span><br><span class="line">        ScoreDoc[] docs=topDocs.scoreDocs;</span><br><span class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : docs) &#123;</span><br><span class="line">            <span class="comment">//获取文档id</span></span><br><span class="line">            <span class="keyword">int</span> docId=scoreDoc.doc;</span><br><span class="line">            Document doc =indexSearcher.doc (docId);</span><br><span class="line">            System.out.println (<span class="string">"score:"</span>+scoreDoc.score);</span><br><span class="line">            System.out.println (<span class="string">"docId:"</span>+docId);</span><br><span class="line">            System.out.println (<span class="string">"bookId:"</span>+doc.get (<span class="string">"id"</span>));</span><br><span class="line">            System.out.println (<span class="string">"name:"</span>+doc.get (<span class="string">"name"</span>));</span><br><span class="line">            System.out.println (<span class="string">"price:"</span>+doc.get (<span class="string">"price"</span>));</span><br><span class="line">            System.out.println (<span class="string">"desc:"</span>+doc.get (<span class="string">"desc"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        indexReader.close ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateIndex2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;Book&gt;bookList=<span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">        Book booka=<span class="keyword">new</span> Book ();</span><br><span class="line">        booka.setId (<span class="number">1</span>);</span><br><span class="line">        booka.setName (<span class="string">"Lucene"</span>);</span><br><span class="line">        booka.setDesc (<span class="string">"Lucene test"</span>);</span><br><span class="line">        booka.setPrice (<span class="number">100.45f</span>);</span><br><span class="line">        Book bookb=<span class="keyword">new</span> Book ();</span><br><span class="line">        bookb.setId (<span class="number">11</span>);</span><br><span class="line">        bookb.setName (<span class="string">"Redis"</span>);</span><br><span class="line">        bookb.setDesc (<span class="string">"Redis test"</span>);</span><br><span class="line">        bookb.setPrice (<span class="number">102.45f</span>);</span><br><span class="line">        Book bookc=<span class="keyword">new</span> Book ();</span><br><span class="line">        bookc.setId (<span class="number">21</span>);</span><br><span class="line">        bookc.setName (<span class="string">"Hadoop"</span>);</span><br><span class="line">        bookc.setDesc (<span class="string">"Hadoop test"</span>);</span><br><span class="line">        bookc.setPrice (<span class="number">602.45f</span>);</span><br><span class="line">        bookList.add (booka);</span><br><span class="line">        bookList.add (bookb);</span><br><span class="line">        bookList.add (bookc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文档对象</span></span><br><span class="line">        List&lt;Document&gt;documents=<span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">        <span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">            Document document=<span class="keyword">new</span> Document ();</span><br><span class="line">            <span class="comment">//IntPoint 分词 索引 不存储 存储结合 StoredField</span></span><br><span class="line">            Field id= <span class="keyword">new</span> IntPoint(<span class="string">"id"</span>,book.getId ());</span><br><span class="line">            System.out.println (id.fieldType ().stored ()+<span class="string">":"</span>+id.fieldType ().tokenized ());</span><br><span class="line">            Field id_v= <span class="keyword">new</span> StoredField (<span class="string">"id"</span>,book.getId ());</span><br><span class="line">            <span class="comment">//分词 索引 存储 TextField</span></span><br><span class="line">            Field name = <span class="keyword">new</span> TextField (<span class="string">"name"</span>, book.getName (), Field.Store.YES);</span><br><span class="line">            <span class="comment">//分词 索引 不存储</span></span><br><span class="line">            Field price = <span class="keyword">new</span> FloatPoint (<span class="string">"price"</span>, book.getPrice ());</span><br><span class="line">            <span class="comment">//分词 索引 不存储 TextField</span></span><br><span class="line">            Field desc = <span class="keyword">new</span> TextField (<span class="string">"desc"</span>, book.getDesc (), Field.Store.NO);</span><br><span class="line">            document.add (id);</span><br><span class="line"><span class="comment">//            document.add (id_v);  //id,id_v都加入会存储在文档</span></span><br><span class="line">            document.add (name);</span><br><span class="line">            document.add (name);</span><br><span class="line">            document.add (price);</span><br><span class="line">            document.add (desc);</span><br><span class="line">            documents.add (document);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建Analyser 对文档分词</span></span><br><span class="line">        Analyzer analyzer=<span class="keyword">new</span> StandardAnalyzer ();</span><br><span class="line">        <span class="comment">//创建Directory和IndexWriterConfig</span></span><br><span class="line">        Directory directory= FSDirectory.open (Paths.get (<span class="string">"/Users/zhangxuefeng/Documents/lucene/index2"</span>));</span><br><span class="line">        IndexWriterConfig indexWriterConfig=<span class="keyword">new</span> IndexWriterConfig (analyzer);</span><br><span class="line">        <span class="comment">//创建IndexWriter写入对象</span></span><br><span class="line">        IndexWriter indexWriter=<span class="keyword">new</span> IndexWriter (directory,indexWriterConfig);</span><br><span class="line">        <span class="comment">//添加文档对象</span></span><br><span class="line">        <span class="keyword">for</span> (Document doc : documents) &#123;</span><br><span class="line">            indexWriter.addDocument (doc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indexWriter.close ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index目录结构</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020807858.png" alt="image-20240902080748653"></p>
<p>第二个方法单元测试输出</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020814639.png" alt="image-20240902081450435"></p>
<h2 id="lucene工具"><a href="#lucene工具" class="headerlink" title="lucene工具"></a>lucene工具</h2><p>java写的swing图形化工具luke</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020831967.png" alt="image-20240902083142856"></p>
<h3 id="打开索引"><a href="#打开索引" class="headerlink" title="打开索引"></a>打开索引</h3><ol>
<li><p>File-&gt;Open index</p>
</li>
<li><p>选择索引所在目录</p>
</li>
</ol>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020834172.png" alt="image-20240902083419021"></p>
<h3 id="查看对应字段分词后建立的索引"><a href="#查看对应字段分词后建立的索引" class="headerlink" title="查看对应字段分词后建立的索引"></a>查看对应字段分词后建立的索引</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020849737.png" alt="image-20240902084929573"></p>
<h3 id="查看索引的文档"><a href="#查看索引的文档" class="headerlink" title="查看索引的文档"></a>查看索引的文档</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020851071.png" alt="image-20240902085059940"></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>AND OR NOT</p>
<p><code>*:*</code>所有文档</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020854908.png" alt="image-20240902085435659"></p>
<p>搜索文档中desc包含test并且price是602.45</p>
<p><code>desc:test AND price:602.45</code>  </p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020901253.png" alt="image-20240902090130094"></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409012336944.png" alt="image-20240901233652783"></p>
<p>每个索引由多个段(segment)组成，每个段只会被创建一次但会被查询多次。索引期间，段经创建就不会再被修改。例如，文档被删除以后，删除信息被单独保存在一个文件中，而段本身并没有修改。<br>多个段会在一个叫作段合并(segments merge)的阶段被合并在一起，而且要么强制执行，要么由 Lucene 的内在机制决定在某个时刻执行，合并后段的数量更少，但是更大。段合并非常耗I/O，且合并期间有些不再使用的信息也将被清理掉，例如，被删除的文档。对于容纳相同数据的索引，段的数量较少时，搜索速度更快。尽管如此，还是需要强调一下:因为段合并非常耗I/O，请不要强制进行段合并，你只需要仔细配置段合并策略，剩余的事情Lucene会自行搞定。</p>
<p>段合并策略</p>
<p>文本分析。分析器(分词器,过滤器,字符映射器)</p>
<h1 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h1><h2 id="ES基本概念"><a href="#ES基本概念" class="headerlink" title="ES基本概念"></a>ES基本概念</h2><p><strong>索引</strong><br>ElasticSearch 将它的数据存储在一个或多个索引(index)中。用 SQL 领域的术语来类比，索引就像数据库，可以向索引写人文档或者从索引中读取文档，并通过在 ElasticSearch内部使用 Lucene 将数据写入索引或从索引中检索数据。需要注意的是，ElasticSearch 中的索引可能由一个或多个 Lucene索引构成，具体细节由 ElasticSearch 的索引分片(shard)、复制(replica)机制及其配置决定。<br><strong>文档</strong><br>文档(document)是 ElasticSearch 世界中的主要实体(对 Lucene 来说也是如此)。对所有使用 ElasticSearch 的案例来说，它们最终都可以归结为对文档的搜索。文档由字段构成，每个字段有它的字段名以及一个或多个字段值(在这种情况下，该字段被称为是多值的，即文档中有多个同名字段)。文档之间可能有各自不同的字段集合，且文档并没有固定的模式或强制的结构。另外，这些规则也适用于 Lucene 文档。事实上，ElasticSearch 的文档最后都存储为 Lucene 文档了。从客户端的角度来看，文档是一个JSON 对象</p>
<p><strong>映射</strong><br>正如你在1.1节所了解的那样，所有文档在写入索引前都需要先进行分析。用户可以设置一些参数，来决定如何将输入文本分割为词条，哪些词条应该被过滤掉，或哪些附加处理是有必要被调用的(如移除 HTML 标签)。此外，ElasticSearch 也提供了各种特性，如排序时所需的字段内容信息。这就是映射(mapping)扮演的角色，存储所有这种元信息。虽然ElasticSearch 能根据字段值自动检测字段的类型，但有时候(事实上，几乎是所有时候)用户还是想自行配置映射，以避免出现一些令人不愉快的意外。<br><strong>类型</strong><br>ElasticSearch 中每个文档都有与之对应的类型(type)定义。这允许用户在一个索引中存储多种文档类型，并为不同文档类型提供不同的映射。<br><strong>节点</strong><br>单个的 ElasticSearch 服务实例称为节点(node)。很多时候部署一个ElasticSearch节点就足以应付大多数简单的应用，但是考虑到容错性或在数据膨胀到单机无法应付这些状况时，你也许会更倾向于使用多节点的 ElasticSearch 集群。</p>
<p><strong>集群</strong><br>当数据量或查询压力超过单机负载时，需要多个节点来协同处理，所有这些节点组成的系统称为集群(cluster)。集群同时也是无间断提供服务的一种解决方案，即便在某些节点因为宕机或执行管理任务(如升级)不可用时。ElasticSearch几乎无缝集成了集群功能。在我们看来，这是它胜过竞争对手的最主要的优点之一。而且，在 ElasticSearch 中配置一个集群是再容易不过的事了。<br><strong>分片</strong><br>正如我们之前提到的那样，集群允许系统存储的数据总量超过单机容量。为了满足这个需求，ElasticSearch 将数据散布到多个物理 Lucene 索引上。这些 Lucene 索引称为分片(shard)，而散布这些分片的过程叫作分片处理(sharding)。ElasticSearch 会自动完成分片处理，并且让这些分片呈现出一个大索引的样子。请记住，除了ElasticSearch 本身自动进行分片处理外，用户为具体的应用进行参数调优也是至关重要的，因为分片的数量在索引创建时就已经配置好，而且之后无法改变，至少对目前的版本是这样的。</p>
<p><strong>副本</strong><br>分片处理允许用户向 ElasticSearch 集群推送超过单机容量的数据。副本(replica)则解决了访问压力过大时单机无法处理所有请求的问题。思路很简单，即为每个分片创建冗余的副本，处理查询时可以把这些副本用作最初的主分片(primary shard)。请记住，我们并未付出额外的代价。即使某个分片所在的节点宕机，ElasticSearch 也可以使用其副本，从而不会造成数据丢失，而且支持在任意时间点添加或移除副本，所以一旦有需要可随时调整副本的数量。<br><strong>网关</strong><br>在ElasticSearch 的工作过程中，关于集群状态，索引设置的各种信息都会被收集起来，并在网关(gateway)中被持久化。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Es中索引可能由lucene一个或多个索引构成</p>
<p>有一件事情需要记住，建索引操作只会发生在主分片上，而不是副本上。当把一个索引请求发送至某节点时，如果该节点没有对应的主分片或者只有副本，那么这个请求会被转发到拥有正确的主分片的节点(如下图所示)。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020915791.png" alt="image-20240902091522637"></p>
<h2 id="ES集群状态"><a href="#ES集群状态" class="headerlink" title="ES集群状态"></a>ES集群状态</h2><p>红 主分片和副本都有</p>
<p>黄 主分片有和副本没有</p>
<p>绿  主分片缺失</p>
<h1 id="查询DSL进阶"><a href="#查询DSL进阶" class="headerlink" title="查询DSL进阶"></a>查询DSL进阶</h1><h2 id="评分公式"><a href="#评分公式" class="headerlink" title="评分公式"></a>评分公式</h2><p>为了计算文档得分，需要考虑以下这些因子:<br>文档权重(document boost):索引期赋予某个文档的权重值。<br>字段权重(field boost):查询期赋予某个字段的权重值。<br>协调因子(coord):基于文档中词项命中个数的协调因子，一个文档命中了查询中的词项越多，得分越高。<br>逆文档频率(inverse document frequency):一个基于词项的因子，用来告诉评分公式该词项有多么罕见。逆文档频率越低，词项越罕见。评分公式利用该因子为包含罕见词项的文档加权。<br>长度范数(length norm):每个字段的基于词项个数的归一化因子(在索引期计算出来并存储在索引中)。一个字段包含的词项数越多，该因子的权重越低，这意味着Apache Lucene 评分公式更“喜欢”包含更少词项的字段。<br>词频(term frequency):一个基于词项的因子，用来表示一个词项在某个文档中出现了多少次。词频越高，文档得分越高。<br>查询范数(query norm):一个基于查询的归一化因子，它等于查询中词项的权重平方和。查询范数使不同查询的得分能相互比较，尽管这种比较通常是困难且不可行的。</p>
<h3 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF/IDF"></a>TF/IDF</h3><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202409020931717.png" alt="image-20240902093154573"></p>
<h2 id="二次评分"><a href="#二次评分" class="headerlink" title="二次评分"></a>二次评分</h2><p>rescore</p>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><h3 id="批量取"><a href="#批量取" class="headerlink" title="批量取"></a>批量取</h3><p>_mget</p>
<h3 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h3><p>_msearch</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="多值字段排序"><a href="#多值字段排序" class="headerlink" title="多值字段排序"></a>多值字段排序</h3><h3 id="基于嵌套对象排序"><a href="#基于嵌套对象排序" class="headerlink" title="基于嵌套对象排序"></a>基于嵌套对象排序</h3><h2 id="数据更新API"><a href="#数据更新API" class="headerlink" title="数据更新API"></a>数据更新API</h2><p>post   _update</p>
<p><a href="http://blog.mikemccandless.com/2010/12/using-finite-state-transducers-in.html" target="_blank" rel="noopener">http://blog.mikemccandless.com/2010/12/using-finite-state-transducers-in.html</a></p>
<p>refresh</p>
<p>Refresh_interval</p>
<p>Translog</p>
<h1 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h1><p>在ElasticSearch中每个索引都会创建一到多个分片以及零到多个副本，也知道这些分片或副本本质上都是 Lucene 索引，而 Lucene 索引又基于多个索引段构建（至少一个索引段）。索引文件中绝大部分数据都是只写一次，读多次，而只有用于保存文档删除信息的文件才会被多次更改。在某些时刻，当某种条件满足时，多个索引段会被拷贝合并到一个更大的索引段，而那些旧的索引段会被抛弃并从磁盘中删除，这个操作称为段合并（segment merging)。</p>
<p>es索引-&gt;各个索引分片和副本-&gt;每个分片是lucene索引-&gt;lucene索引中有至少一个段-&gt;段中是文档</p>
<p>段不可变,删除只是增加文档删除信息,段合并时结合删除信息合并新的不含删除文档的新段并把被合并的段删除,提高搜索性能和节省内存,但这个过程涉及比较多的IO操作</p>
<h2 id="段合并策略"><a href="#段合并策略" class="headerlink" title="段合并策略"></a>段合并策略</h2><p> index.merge.policy.type: tiered</p>
<p>正排索引。text默认不建立。fielddata</p>
<p>doc_value</p>
<p>分片扩充容量。 副本高可用和查询吞吐量</p>
<p>路由</p>
<p>别名</p>
<p>分片分配器</p>
<p>过滤器缓存</p>
<p>字段缓存</p>
<p>清除缓存</p>
<p>segments API</p>
<p>预热器API</p>
<p>热点线程</p>
<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>参考;</p>
<p><a href="https://cloud.tencent.com/developer/article/2398535" target="_blank" rel="noopener">深入解析Elasticsearch的内部数据结构和机制</a></p>
<p>倒排索引结构时，我们主要涉及到三个部分：倒排表（Posting List）、词项字典（Term Dictionary）和词项索引（Term Index）</p>
<h5 id="倒排表（Posting-List）"><a href="#倒排表（Posting-List）" class="headerlink" title="倒排表（Posting List）"></a>倒排表（Posting List）</h5><p>包括文档ID和单词在该文档中出现的位置、频率等附加信息</p>
<p>词项字典是一个包含文档集合中所有唯一单词的列表。每个单词在词项字典中都有一个唯一的条目，这个条目指向倒排表中与该单词对应的条目</p>
<p>每个单词都按照某种顺序（例如字典序）排列，并且每个单词都有一个指针或引用，指向倒排表中相应的条目</p>
<p><strong>词典查找的挑战</strong></p>
<ul>
<li>全文检索系统通常需要处理大量的文本数据，这意味着词典（Term Dictionary）也会非常大。虽然可以使用各种高效的数据结构（如哈希表、B树等）来加速查找，但这些数据结构通常都需要将数据加载到内存中才能实现最优的查找性能。然而，将整个词典加载到内存中可能会导致巨大的内存消耗，甚至耗尽可用内存。</li>
<li>此外，即使词典被加载到内存中，由于内存访问速度仍然远低于CPU的处理速度，因此查找性能仍然可能受到限制。特别是在需要进行大量的随机内存访问时，性能影响会更加显著。</li>
</ul>
<p>Suggest API</p>
<p>completion suggester</p>
<p>_all字段</p>
<p>全文搜索</p>
<p>基本数据类型</p>
<p>查询方式</p>
<p>写流程</p>
<p>读流程</p>
<p>doc_values 排序,聚合  为true增加正排索引,增加磁盘占用,也会导致索引速度慢一些   可压缩  默认所有字段启用,除了text </p>
<p>text不能设置doc_value为true 影响性能.  可以用fielddata设置</p>
<p>深分页</p>
<p>index.max_result_window默认10000</p>
<p>From size</p>
<p>scroll</p>
<p>search after</p>
<h1 id="es集群搭建"><a href="#es集群搭建" class="headerlink" title="es集群搭建"></a>es集群搭建</h1><p>Docker 创建了单节点的es和kibanam但因为es存储空间问题,kibana总是会有问题</p>
<p>在centos虚拟机node4,node5,node6搭建es集群,在本机Mac m1用kibana和cerebro管理es集群</p>
<h2 id="es集群启动"><a href="#es集群启动" class="headerlink" title="es集群启动"></a>es集群启动</h2><p>es启动不能用root用户启动es,要新建一个用户,我新建了elsearch</p>
<p>在三个节点都执行下面操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/software/elasticsearch-<span class="number">7.16</span>.2</span><br><span class="line">su elsearch</span><br><span class="line">nohup bin/elasticsearch &amp;</span><br></pre></td></tr></table></figure>
<h2 id="Mac-m1启动cerebro"><a href="#Mac-m1启动cerebro" class="headerlink" title="Mac m1启动cerebro"></a>Mac m1启动cerebro</h2><p>输入下面命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/zhangxuefeng/Downloads/cerebro-<span class="number">0.9</span>.4/bin</span><br><span class="line">nohup ./cerebro &amp;</span><br></pre></td></tr></table></figure>
<p>打开浏览器输入<code>http://localhost:9000/</code></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408292205259.png" alt="image-20240829220519122"></p>
<p>输入<code>http://node4:9200</code>进入</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408292206308.png" alt="image-20240829220621189"></p>
<h2 id="Mac-m1启动kibana"><a href="#Mac-m1启动kibana" class="headerlink" title="Mac m1启动kibana"></a>Mac m1启动kibana</h2><p>输入下面命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/zhangxuefeng/Downloads/kibana-<span class="number">7.16</span>.2-darwin-aarch64/</span><br><span class="line">nohup bin/kibana &amp;</span><br></pre></td></tr></table></figure>
<p>浏览器输入<code>http://localhost:5601/</code>进入kibana</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408292212396.png" alt="image-20240829221239210"></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JDBC相关理论]]></title>
      <url>/p/8vt5v/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="jdbc理论概述"><a href="#jdbc理论概述" class="headerlink" title="jdbc理论概述"></a>jdbc理论概述</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408092026213.png" alt="image-20240809202655783">       </p>
<p>  JDBC是API,Driver是实现</p>
<h1 id="jdbc简单示例程序"><a href="#jdbc简单示例程序" class="headerlink" title="jdbc简单示例程序"></a>jdbc简单示例程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册驱动</span></span><br><span class="line">      DriverManager.registerDriver (<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line">      <span class="comment">//建立连接</span></span><br><span class="line">      Connection connection=DriverManager.getConnection (</span><br><span class="line">              <span class="string">"jdbc:mysql://localhost:3306/jdbc"</span>,<span class="string">""</span>,<span class="string">""</span></span><br><span class="line">      );</span><br><span class="line">      <span class="comment">//创建语句</span></span><br><span class="line">      Statement statement= connection.createStatement ();</span><br><span class="line">      <span class="comment">//执行语句</span></span><br><span class="line">      ResultSet resultSet = statement.executeQuery (<span class="string">"select * from user"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//处理结果</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next ())&#123;</span><br><span class="line">          System.out.println (resultSet.getObject (<span class="number">1</span>) +<span class="string">"\t"</span></span><br><span class="line">          +resultSet.getObject (<span class="number">2</span>) +<span class="string">"\t"</span></span><br><span class="line">          +resultSet.getObject (<span class="number">3</span>) +<span class="string">"\t"</span></span><br><span class="line">          +resultSet.getObject (<span class="number">4</span>) +<span class="string">"\t"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      resultSet.close();</span><br><span class="line">      statement.close ();</span><br><span class="line">      connection.close ();</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408092109671.png" alt="image-20240809210939358"></p>
<p>DriverManager里面有个Driver列表,建立连接时拿url询问驱动是否能建立连接</p>
<h2 id="注册驱动方式"><a href="#注册驱动方式" class="headerlink" title="注册驱动方式"></a>注册驱动方式</h2><ul>
<li>DriverManager.registerDriver (new com.mysql.jdbc.Driver());</li>
<li>System.setProperty(“jdbc.drivers”,”com.mysql.jdbc.Driver”);</li>
<li>Class.forName(“com.mysql.jdbc.Driver”);</li>
</ul>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408100944491.png" alt="image-20240810094435810"></p>
<p> <strong>原理:</strong>  Driver类加载时会调静态代码块,加入DriverManager,而在执行registerDriver方法之前也会先执行DriverManager静态代码块获取jdbc.drivers对应的Driver进行注册</p>
<p>推荐第3种,减少依赖,第1种没有驱动jar包编译会不通过</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408092215913.png" alt="image-20240809221552248"></p>
<h1 id="JdbcUtil封装"><a href="#JdbcUtil封装" class="headerlink" title="JdbcUtil封装"></a>JdbcUtil封装</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangxuefeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url=<span class="string">"jdbc:mysql://localhost:3306/jdbc?useSSL=false"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String username=<span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String password=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JdbcUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName (<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection (url,username,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement st,  Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                rs.close ();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(st!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                st.close ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                e.printStackTrace ();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        connection.close ();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Statement的sql注入问题"><a href="#Statement的sql注入问题" class="headerlink" title="Statement的sql注入问题"></a>Statement的sql注入问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statementProblem</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        Statement statement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            statement= connection.createStatement ();</span><br><span class="line">            String sql=<span class="string">"select id,`name`,money,birthday from `user` where name='"</span>+name+<span class="string">"'"</span>;</span><br><span class="line">            System.out.println (sql);</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            resultSet = statement.executeQuery (sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理结果</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next ())&#123;</span><br><span class="line">                System.out.println (resultSet.getObject (<span class="string">"id"</span>) +<span class="string">"\t"</span></span><br><span class="line">                        +resultSet.getObject (<span class="string">"name"</span>) +<span class="string">"\t"</span></span><br><span class="line">                        +resultSet.getObject (<span class="string">"money"</span>) +<span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,statement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        statementProblem (<span class="string">"' or 1=1 or '"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101005889.png" alt="image-20240810100539362"></p>
<center><u>控制台输出</u></center>

<h2 id="PreparedStatement应用"><a href="#PreparedStatement应用" class="headerlink" title="PreparedStatement应用"></a>PreparedStatement应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preparedStatementDemo</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            String sql=<span class="string">"select id,`name`,money,birthday from `user` where `name`=?"</span>;</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            preparedStatement.setString (<span class="number">1</span>,name);</span><br><span class="line">            System.out.println (sql);</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery ();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理结果</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next ())&#123;</span><br><span class="line">                System.out.println (resultSet.getObject (<span class="string">"id"</span>) +<span class="string">"\t"</span></span><br><span class="line">                        +resultSet.getObject (<span class="string">"name"</span>) +<span class="string">"\t"</span></span><br><span class="line">                        +resultSet.getObject (<span class="string">"money"</span>) +<span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        preparedStatementDemo (<span class="string">"' or 1=1 or '"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Statement和PreparedStatement速度对比</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        JdbcUtil.getConnection ();</span><br><span class="line">  			<span class="keyword">long</span> start = System.currentTimeMillis ();</span><br><span class="line">        statementProblem (<span class="string">"lisi"</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis ();</span><br><span class="line">        System.out.println (<span class="string">"statemnet:"</span>+(end-start));</span><br><span class="line">        start = System.currentTimeMillis ();</span><br><span class="line">        preparedStatementDemo (<span class="string">"lisi"</span>);</span><br><span class="line">        end = System.currentTimeMillis ();</span><br><span class="line">        System.out.println (<span class="string">"statemnet:"</span>+(end-start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101022253.png" alt="image-20240810102256934"></p>
<center><u>控制台输出</u></center>

<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101028312.png" alt="image-20240810102832968"></p>
<h1 id="jdbc处理日期"><a href="#jdbc处理日期" class="headerlink" title="jdbc处理日期"></a>jdbc处理日期</h1><p>传入参数是java.util.Date,将此类型转化为java.sql.Date</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name,java.util.Date birthday,<span class="keyword">float</span> money)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            String sql=<span class="string">"insert into `user`(`name`,birthday,money) values(?,?,?)"</span>;</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            preparedStatement.setString (<span class="number">1</span>,name);</span><br><span class="line">            preparedStatement.setDate (<span class="number">2</span>,<span class="keyword">new</span> java.sql.Date (birthday.getTime ()));</span><br><span class="line">            preparedStatement.setFloat (<span class="number">3</span>,money);</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            <span class="keyword">int</span> i = preparedStatement.executeUpdate ();</span><br><span class="line"></span><br><span class="line">            System.out.println (<span class="string">"i="</span>+i);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        create (<span class="string">"name1"</span>,<span class="keyword">new</span> java.util.Date (),<span class="number">400.0f</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从数据库读取java.sql.Date转化为java.util.Date</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Date <span class="title">read</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            String sql=<span class="string">"select birthday from `user` where id=?"</span>;</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            preparedStatement.setInt (<span class="number">1</span>,id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery ();</span><br><span class="line">            Date birthday=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(resultSet.next ())&#123;</span><br><span class="line">                birthday=<span class="keyword">new</span> Date (resultSet.getDate(<span class="string">"birthday"</span>).getTime ());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> birthday;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println (read (<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101309971.png" alt="image-20240810130929285"></p>
<center><u>控制台输出</u></center>

<h1 id="jdbc访问大段文本数据"><a href="#jdbc访问大段文本数据" class="headerlink" title="jdbc访问大段文本数据"></a>jdbc访问大段文本数据</h1><p>创建clob_test数据库,定义text类型的big_text字段</p>
<blockquote>
<p>插入数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</span><br><span class="line">      Connection connection=<span class="keyword">null</span>;</span><br><span class="line">      PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">      ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          connection=JdbcUtil.getConnection ();</span><br><span class="line">          String sql=<span class="string">"insert into `clob_test`(`big_text`) values(?)"</span>;</span><br><span class="line">          <span class="comment">//创建语句</span></span><br><span class="line">          preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">          File file =<span class="keyword">new</span> File(<span class="string">"/Users/zhangxuefeng/Documents/grpc-springboot-demo/jdbc-demo/src/main/java/com/test/JdbcUtil.java"</span>);</span><br><span class="line">          Reader reader=<span class="keyword">new</span> BufferedReader (<span class="keyword">new</span> FileReader (file));</span><br><span class="line">          preparedStatement.setCharacterStream (<span class="number">1</span>,reader,file.length ());</span><br><span class="line">          <span class="comment">//执行语句</span></span><br><span class="line">          <span class="keyword">int</span> i = preparedStatement.executeUpdate ();</span><br><span class="line">          System.out.println (<span class="string">"i="</span>+i);</span><br><span class="line">          reader.close ();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</span><br><span class="line">     create ();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查询数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        Statement statement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            statement= connection.createStatement ();</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            resultSet = statement.executeQuery (<span class="string">"select big_text from `clob_test`"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理结果</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next ())&#123;</span><br><span class="line">                Clob clob = resultSet.getClob (<span class="string">"big_text"</span>);</span><br><span class="line">                Reader reader = clob.getCharacterStream ();</span><br><span class="line"><span class="comment">//                reader=resultSet.getCharacterStream (1);</span></span><br><span class="line">                File file =<span class="keyword">new</span> File(<span class="string">"/Users/zhangxuefeng/Documents/grpc-springboot-demo/jdbc-demo/JdbcUtil_bak.java"</span>);</span><br><span class="line">                Writer writer=<span class="keyword">new</span> BufferedWriter (<span class="keyword">new</span> FileWriter (file));</span><br><span class="line">                <span class="keyword">char</span>[]buf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;(i=reader.read (buf))&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">                    writer.write (buf,<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">                writer.close ();</span><br><span class="line">                reader.close ();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,statement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101214514.png" alt="image-20240810121411195"></p>
<center><u>数据库text类型字段写入文件</u></center>

<p>也可以用String来处理text,</p>
<ul>
<li><p>插入数据时将字符数组转化为String.<strong>String str=new String(buf);    ps.setString(1,str);</strong></p>
</li>
<li><p>查询数据时<strong>resultSet.getString(“big_text”);</strong></p>
</li>
</ul>
<h1 id="jdbc访问二进制数据"><a href="#jdbc访问二进制数据" class="headerlink" title="jdbc访问二进制数据"></a>jdbc访问二进制数据</h1><p>创建blob_test数据库,定义blob类型的big_bit字段,这个不能用String来处理</p>
<blockquote>
<p>将图片存入big_bit,注意blob类型限制64k大小以内</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            String sql=<span class="string">"insert into `blob_test`(`big_bit`) values(?)"</span>;</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            File file =<span class="keyword">new</span> File(<span class="string">"/Users/zhangxuefeng/Desktop/img2/Snipaste_2023-11-18_02-04-11.png"</span>);</span><br><span class="line">            InputStream in=<span class="keyword">new</span> BufferedInputStream (<span class="keyword">new</span> FileInputStream (file));</span><br><span class="line">            preparedStatement.setBinaryStream (<span class="number">1</span>,in,file.length ());</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            <span class="keyword">int</span> i = preparedStatement.executeUpdate ();</span><br><span class="line">            System.out.println (<span class="string">"i="</span>+i);</span><br><span class="line">            in.close ();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</span><br><span class="line">        create ();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>取出blob类型字段写入文件test_blob.jpg</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        Statement statement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            statement= connection.createStatement ();</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            resultSet = statement.executeQuery (<span class="string">"select big_bit from `blob_test`"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理结果</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next ())&#123;</span><br><span class="line"><span class="comment">//                Blob blob = resultSet.getBlob ("big_text");</span></span><br><span class="line"><span class="comment">//                InputStream in = blob.getBinaryStream ();</span></span><br><span class="line">                InputStream in=resultSet.getBinaryStream (<span class="number">1</span>);</span><br><span class="line">                File file =<span class="keyword">new</span> File(<span class="string">"/Users/zhangxuefeng/Documents/grpc-springboot-demo/jdbc-demo/test_blob.jpg"</span>);</span><br><span class="line">                OutputStream out=<span class="keyword">new</span> BufferedOutputStream (<span class="keyword">new</span> FileOutputStream (file));</span><br><span class="line">                <span class="keyword">byte</span>[]buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;(i=in.read (buf))&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">                    out.write (buf,<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">                out.close ();</span><br><span class="line">                in.close ();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,statement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101255491.png" alt="image-20240810125533736"></p>
<center><u>数据库blob类型字段写入文件</u></center>

<h1 id="jdbc访问其他数据类型"><a href="#jdbc访问其他数据类型" class="headerlink" title="jdbc访问其他数据类型"></a>jdbc访问其他数据类型</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101316495.png" alt="image-20240810131647037"></p>
<h1 id="使用DAO工厂模式"><a href="#使用DAO工厂模式" class="headerlink" title="使用DAO工厂模式"></a>使用DAO工厂模式</h1><ol>
<li>配置文件<strong>daoconfig.properties</strong>中写入键值对:<strong>userDaoClass=com.test.dao.impl.UserDaoImpl</strong></li>
<li><strong>DaoFactory</strong>设计成单例工厂,生产<strong>UserDao</strong></li>
<li>代码测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UserDao userDao=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DaoFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties=<span class="keyword">new</span> Properties ();</span><br><span class="line">            InputStream in=</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream (<span class="keyword">new</span> File (<span class="string">"./jdbc-demo/src/main/resources/daoconfig.properties"</span>));</span><br><span class="line">            properties.load (in);</span><br><span class="line">            String userDaoClass = properties.getProperty (<span class="string">"userDaoClass"</span>);</span><br><span class="line">            userDao= (UserDao) Class.forName (userDaoClass).newInstance ();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DaoFactory instance=<span class="keyword">new</span> DaoFactory ();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DaoFactory <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title">getUserDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DaoFactory采用饿汉单例模式,调用static方法时,触发类加载,类加载在<clinit>方法中初始化instance变量时执行new DaoFactory(),调用私有的DaoFactory方法,而这个构造函数中加载daoconfig.properties,读取键值对,再通过反射调用UserDao构造函数生成对象.</clinit></p>
<center><u>代码测试</u></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserDao userDao = DaoFactory.getUserDao ();</span><br><span class="line">        User user=userDao.getUser (<span class="number">1</span>);</span><br><span class="line">        System.out.println (user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果:<strong>User{id=1, name=’zhangsan’, birthday=2024-08-10, money=100.0}</strong></p>
<blockquote>
<p> <strong>代码优化:</strong> </p>
<p>InputStream in=new FileInputStream (new File (“./jdbc-demo/src/main/resources/daoconfig.properties”));</p>
<p>写死了文件路径,用下面代码替换,可实现在classpath中加载daoconfig.properties文件</p>
<p>InputStream in=DaoFactory.class.getClassLoader ().getResourceAsStream (“daoconfig.properties”);</p>
</blockquote>
<h1 id="事务的概念和jdbc事务处理"><a href="#事务的概念和jdbc事务处理" class="headerlink" title="事务的概念和jdbc事务处理"></a>事务的概念和jdbc事务处理</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101713917.png" alt="image-20240810171356441"></p>
<h2 id="测试不在一个事务情况"><a href="#测试不在一个事务情况" class="headerlink" title="测试不在一个事务情况"></a>测试不在一个事务情况</h2><center><u>user表初始内容</u></center>

<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>birthday</th>
<th>money</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>zhangsan</td>
<td>2024-08-10</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>2024-08-22</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>2024-08-21</td>
<td>300</td>
</tr>
<tr>
<td>4</td>
<td>name1</td>
<td>2024-08-09</td>
<td>400</td>
</tr>
</tbody>
</table>
</div>
<center><u>测试代码</u></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        Statement statement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            statement= connection.createStatement ();</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            statement.executeUpdate (<span class="string">"update `user` set money=money-10 where id=1"</span>);</span><br><span class="line"></span><br><span class="line">            resultSet=statement.executeQuery (<span class="string">"select money from `user` where id=2"</span>);</span><br><span class="line">            <span class="keyword">float</span> money=<span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">if</span>(resultSet.next ())&#123;</span><br><span class="line">                money=resultSet.getFloat (<span class="string">"money"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(money&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"测试发生异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,statement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>数据库中id=2数据money&gt;100发生异常</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.RuntimeException: 测试发生异常</span><br><span class="line">	at com.test.TxTest.test(TxTest.java:29)</span><br><span class="line">	at com.test.TxTest.main(TxTest.java:36)</span><br></pre></td></tr></table></figure>
<p>但第一个操作执行成功了,数据库记录如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>birthday</th>
<th>money</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>zhangsan</td>
<td>2024-08-10</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>2024-08-22</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>2024-08-21</td>
<td>300</td>
</tr>
<tr>
<td>4</td>
<td>name1</td>
<td>2024-08-09</td>
<td>400</td>
</tr>
</tbody>
</table>
</div>
<h2 id="测试在一个事务情况"><a href="#测试在一个事务情况" class="headerlink" title="测试在一个事务情况"></a>测试在一个事务情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        Statement statement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            connection.setAutoCommit (<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            statement= connection.createStatement ();</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            statement.executeUpdate (<span class="string">"update `user` set money=money-10 where id=1"</span>);</span><br><span class="line"></span><br><span class="line">            resultSet=statement.executeQuery (<span class="string">"select money from `user` where id=2"</span>);</span><br><span class="line">            <span class="keyword">float</span> money=<span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">if</span>(resultSet.next ())&#123;</span><br><span class="line">                money=resultSet.getFloat (<span class="string">"money"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(money&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"测试发生异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            statement.executeUpdate (<span class="string">"update `user` set money=money+10 where id=2"</span>);</span><br><span class="line">            connection.commit ();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                connection.rollback ();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,statement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>条件设置money&gt;100时回滚,money&gt;400时成功提交</p>
<h1 id="事务的保存点处理"><a href="#事务的保存点处理" class="headerlink" title="事务的保存点处理"></a>事务的保存点处理</h1><p>只回滚一部分操作,在spring事务传播中有一个难理解的就是用这种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        Statement statement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        Savepoint savePoint=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            connection.setAutoCommit (<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            statement= connection.createStatement ();</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            statement.executeUpdate (<span class="string">"update `user` set money=money-10 where id=1"</span>);</span><br><span class="line">            savePoint=connection.setSavepoint ();</span><br><span class="line">            statement.executeUpdate (<span class="string">"update `user` set money=money-10 where id=3"</span>);</span><br><span class="line"></span><br><span class="line">            resultSet=statement.executeQuery (<span class="string">"select money from `user` where id=2"</span>);</span><br><span class="line">            <span class="keyword">float</span> money=<span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">if</span>(resultSet.next ())&#123;</span><br><span class="line">                money=resultSet.getFloat (<span class="string">"money"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(money&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"测试发生异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            statement.executeUpdate (<span class="string">"update `user` set money=money+10 where id=2"</span>);</span><br><span class="line">            connection.commit ();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(connection!=<span class="keyword">null</span>&amp;&amp;savePoint!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                connection.rollback (savePoint);</span><br><span class="line">                connection.commit ();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                connection.rollback ();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,statement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>id=1转账操作执行后设置保存点,在id=3操作执行再执行查询操作遇到了异常,此时进入<strong>catch(RuntimeException e){}</strong>代码块回滚到保存点,提交事务,可实现只有id=1操作执行成功.</p>
<h1 id="JTA分布式事务"><a href="#JTA分布式事务" class="headerlink" title="JTA分布式事务"></a>JTA分布式事务</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408101827426.png" alt="image-20240810182715391"></p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>set autocommit=0  设置事务不自动提交</p>
<p>set session transaction isolation level read uncommitted;</p>
<p>set session transaction isolation level read committed;</p>
<p>set session transaction isolation level repeatable read;</p>
<p>set session transaction isolation level serializable;</p>
<p>show status like ‘%isolation%’;</p>
<h1 id="jdbc调用存储过程"><a href="#jdbc调用存储过程" class="headerlink" title="jdbc调用存储过程"></a>jdbc调用存储过程</h1><p>CallableStatement,实际基本不会使用,跳过</p>
<h1 id="jdbc批处理功能"><a href="#jdbc批处理功能" class="headerlink" title="jdbc批处理功能"></a>jdbc批处理功能</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBatch</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            String sql=<span class="string">"insert into `user`(`name`,birthday,money) values(?,?,?)"</span>;</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                preparedStatement.setString (<span class="number">1</span>,<span class="string">"batch name"</span>+i);</span><br><span class="line">                preparedStatement.setDate (<span class="number">2</span>,<span class="keyword">new</span> Date (System.currentTimeMillis ()));</span><br><span class="line">                preparedStatement.setFloat (<span class="number">3</span>,<span class="number">300.0f</span>+i);</span><br><span class="line">                preparedStatement.addBatch ();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[]is=preparedStatement.executeBatch ();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : is) &#123;</span><br><span class="line">                System.out.println (<span class="string">"插入"</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println (<span class="string">"====="</span>);</span><br><span class="line"></span><br><span class="line">            ResultSet generatedKeys = preparedStatement.getGeneratedKeys ();</span><br><span class="line">            <span class="keyword">while</span>(generatedKeys.next ())&#123;</span><br><span class="line">                System.out.println (<span class="string">"id="</span>+generatedKeys.getInt (<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        createBatch();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>前面打印每个sql插入数目,后面打印插入id</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">插入1</span><br><span class="line">插入1</span><br><span class="line">插入1</span><br><span class="line">=====</span><br><span class="line">id=6</span><br><span class="line">id=7</span><br><span class="line">id=8</span><br></pre></td></tr></table></figure>
<center><u>控制台输出</u></center>

<h1 id="可滚动结果集"><a href="#可滚动结果集" class="headerlink" title="可滚动结果集"></a>可滚动结果集</h1><p>resultSet.absolute();</p>
<p>resultSet.previous();</p>
<h1 id="数据库元数据信息"><a href="#数据库元数据信息" class="headerlink" title="数据库元数据信息"></a>数据库元数据信息</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection = JdbcUtil.getConnection ();</span><br><span class="line">        java.sql.DatabaseMetaData metaData = connection.getMetaData ();</span><br><span class="line">        System.out.println (<span class="string">"db name:"</span>+metaData.getDatabaseProductName ());</span><br><span class="line">        System.out.println (<span class="string">"tx:"</span>+metaData.supportsTransactions ());</span><br><span class="line">        connection.close ();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>hibernate可以用这个判断数据库对方言支不支持</p>
<h1 id="参数元数据信息"><a href="#参数元数据信息" class="headerlink" title="参数元数据信息"></a>参数元数据信息</h1><p>用参数元数据信息给参数逐个赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object[]params)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            <span class="comment">//创建语句</span></span><br><span class="line">            String sql=<span class="string">"select id,`name`,money,birthday from `user` where `name`=? and money&gt;?"</span>;</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            java.sql.ParameterMetaData parameterMetaData = preparedStatement.getParameterMetaData ();</span><br><span class="line">            <span class="keyword">int</span> count = parameterMetaData.getParameterCount ();</span><br><span class="line">            System.out.println (count);</span><br><span class="line">            <span class="keyword">if</span>(params.length!=count)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"参数个数不匹配"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                preparedStatement.setObject (i+<span class="number">1</span>,params[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println (sql);</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery ();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理结果</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next ())&#123;</span><br><span class="line">                System.out.println (resultSet.getObject (<span class="string">"id"</span>) +<span class="string">"\t"</span></span><br><span class="line">                        +resultSet.getObject (<span class="string">"name"</span>) +<span class="string">"\t"</span></span><br><span class="line">                        +resultSet.getObject (<span class="string">"money"</span>) +<span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        test (<span class="keyword">new</span> Object[]&#123;<span class="string">"zhangsan"</span>,<span class="number">10</span>&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果集元数据信息"><a href="#结果集元数据信息" class="headerlink" title="结果集元数据信息"></a>结果集元数据信息</h1><p>用结果集元数据信息将查询结果封装为map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Map&lt;String,Object&gt;&gt; test(String sql) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery ();</span><br><span class="line">            java.sql.ResultSetMetaData metaData = resultSet.getMetaData ();</span><br><span class="line">            <span class="keyword">int</span> count = metaData.getColumnCount ();</span><br><span class="line">            String[] colNames=<span class="keyword">new</span> String[count];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                System.out.print (metaData.getColumnClassName (i + <span class="number">1</span>)+<span class="string">"\t"</span>);</span><br><span class="line">                System.out.print (metaData.getColumnName (i + <span class="number">1</span>)+<span class="string">"\t"</span>);</span><br><span class="line">                System.out.println (metaData.getColumnLabel (i + <span class="number">1</span>));</span><br><span class="line">                colNames[i]=metaData.getColumnLabel (i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Map&lt;String,Object&gt;&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">            <span class="keyword">while</span>(resultSet.next ())&#123;</span><br><span class="line">                Map&lt;String,Object&gt;map=<span class="keyword">new</span> HashMap&lt;&gt; ();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                    map.put(colNames[i],resultSet.getObject (colNames[i]));</span><br><span class="line">                &#125;</span><br><span class="line">                list.add (map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql=<span class="string">"select id,`name` as n,birthday from `user` where `id`&lt;3"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = test (sql);</span><br><span class="line">        System.out.println (<span class="string">"------"</span>);</span><br><span class="line">        System.out.println (maps);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<center><u>控制台输出</u></center>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Integer	id	id</span><br><span class="line">java.lang.String	name	n</span><br><span class="line">java.sql.Date	birthday	birthday</span><br><span class="line">------</span><br><span class="line">[&#123;birthday=2024-08-10, id=1, n=zhangsan&#125;, &#123;birthday=2024-08-22, id=2, n=lisi&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="利用反射将查询结果封装成对象"><a href="#利用反射将查询结果封装成对象" class="headerlink" title="利用反射将查询结果封装成对象"></a>利用反射将查询结果封装成对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">getObject</span><span class="params">(String sql,Class clazz)</span> <span class="keyword">throws</span> SQLException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery ();</span><br><span class="line">            java.sql.ResultSetMetaData metaData = resultSet.getMetaData ();</span><br><span class="line">            <span class="keyword">int</span> count = metaData.getColumnCount ();</span><br><span class="line">            String[] colNames=<span class="keyword">new</span> String[count];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                colNames[i]=metaData.getColumnLabel (i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Method[] methods = clazz.getMethods ();</span><br><span class="line">            HashMap&lt;String,Integer&gt;indexMap=<span class="keyword">new</span> HashMap&lt;&gt; ();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;methods.length;i++)&#123;</span><br><span class="line">                indexMap.put (methods[i].getName (),i);</span><br><span class="line">            &#125;</span><br><span class="line">            Object object=clazz.newInstance ();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(resultSet.next ())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                    String methodName=<span class="string">"set"</span>+colNames[i];</span><br><span class="line">                    <span class="keyword">if</span>(indexMap.get (methodName)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        methods[indexMap.get (methodName)].invoke (object,resultSet.getObject (colNames[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        String sql=<span class="string">"select id as Id,`name` as Name,birthday as Birthday,money as Money from `user` where `id`=3"</span>;</span><br><span class="line">        User user = (User) getObject (sql, User.class);</span><br><span class="line">        System.out.println (user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<center><u>控制台输出</u></center>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=3, name='wangwu', birthday=2024-08-21, money=300.0&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编写连接池"><a href="#编写连接池" class="headerlink" title="编写连接池"></a>编写连接池</h1><h2 id="初始代码"><a href="#初始代码" class="headerlink" title="初始代码"></a>初始代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url=<span class="string">"jdbc:mysql://localhost:3306/jdbc?useSSL=false"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String username=<span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String password=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt;connectionPool=<span class="keyword">new</span> LinkedList&lt;&gt; ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                connectionPool.addLast (createConnection ());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError (e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">createConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection (url,username,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connectionPool.removeFirst ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeConnection</span><span class="params">(Connection connection)</span></span>&#123;</span><br><span class="line">        connectionPool.addLast (connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><u>JdbcUtil加入MySource优化</u></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyDataSource myDataSource=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JdbcUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName (<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            myDataSource=<span class="keyword">new</span> MyDataSource ();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//return DriverManager.getConnection (url,username,password);</span></span><br><span class="line">        <span class="keyword">return</span> myDataSource.getConnection ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement st,  Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                rs.close ();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(st!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                st.close ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                e.printStackTrace ();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="comment">//connection.close ();</span></span><br><span class="line">                        myDataSource.freeConnection (connection);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><u>连接池测试</u></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Connection connection=JdbcUtil.getConnection ();</span><br><span class="line">            System.out.println (connection);</span><br><span class="line">            JdbcUtil.close (<span class="keyword">null</span>,<span class="keyword">null</span>,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408102236168.png" alt="image-20240810223647484"></p>
<p>可以看出后5个连接达到了复用的目的</p>
<h2 id="考虑多线程并发"><a href="#考虑多线程并发" class="headerlink" title="考虑多线程并发"></a>考虑多线程并发</h2><p>代理模式增强Connection#connection.close() ,不是关闭连接而是放回连接池,</p>
<p>动态代理增强Connection#connection.close()</p>
<h1 id="DataSource接口及数据源"><a href="#DataSource接口及数据源" class="headerlink" title="DataSource接口及数据源"></a>DataSource接口及数据源</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408102331079.png" alt="image-20240810233105770"></p>
<p>数据源内部通过连接池获取数据库连接,这里的数据库连接是动态代理增强过的连接,比如close方法</p>
<h2 id="使用DBCP数据源"><a href="#使用DBCP数据源" class="headerlink" title="使用DBCP数据源"></a>使用DBCP数据源</h2><ol>
<li>写配置文件  </li>
<li>导入maven依赖</li>
<li>JdbcUtil使用dbcp数据源</li>
</ol>
<p>dbcpconfig.properties</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">连接设置（driverClassName是DBCP数据源中定义好的固定名字）</span></span><br><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span><br><span class="line">username=root</span><br><span class="line">password=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;!-- 初始化连接 --&gt;</span></span><br><span class="line">initialSize=10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">最大连接数量</span></span><br><span class="line">maxActive=50</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;!-- 最大空闲连接 --&gt;</span></span><br><span class="line">maxIdle=20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;!-- 最小空闲连接 --&gt;</span></span><br><span class="line">minIdle=5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;</span></span><br><span class="line">maxWait=60000</span><br><span class="line"><span class="meta">#</span><span class="bash">JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：【属性名=property;】</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意：<span class="string">"user"</span> 与 <span class="string">"password"</span> 两个属性会被明确地传递，因此这里不需要包含他们。</span></span><br><span class="line">connectionProperties=useUnicode=true;characterEncoding=UTF8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定由连接池所创建的连接的自动提交（auto-commit）状态。</span></span><br><span class="line">defaultAutoCommit=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">driver default 指定由连接池所创建的连接的只读（<span class="built_in">read</span>-only）状态。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix）</span></span><br><span class="line">defaultReadOnly=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">可用值为下列之一：（详情可见javadoc）NONE, READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE</span></span><br><span class="line">defaultTransactionIsolation=READ_UNCOMMITTED</span><br></pre></td></tr></table></figure>
<p>Maven依赖</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--前提：先导入数据库驱动依赖--&gt;</span><br><span class="line">        &lt;!--dbcp数据库连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>JdbcUtil代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource myDataSource=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JdbcUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName (<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            InputStream in = JdbcUtil.class.getClassLoader().getResourceAsStream(<span class="string">"dbcpconfig.properties"</span>); <span class="comment">//获取输入流</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();  <span class="comment">//创建空属性列表</span></span><br><span class="line">            properties.load(in);  <span class="comment">//加载流资源</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建数据源 工厂模式---&gt;创建对象</span></span><br><span class="line">            <span class="comment">//在java中，编写数据库连接池需实现java.sql.DataSource接口，每一种数据库连接池都是DataSource接口的实现，而DBCP连接池就是java.sql.DataSource接口的一个具体实现</span></span><br><span class="line">            myDataSource= BasicDataSourceFactory.createDataSource (properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError (e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//return DriverManager.getConnection (url,username,password);</span></span><br><span class="line">        <span class="keyword">return</span> myDataSource.getConnection ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement st,  Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                rs.close ();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(st!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                st.close ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                e.printStackTrace ();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        connection.close ();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="DAO代码优化"><a href="#DAO代码优化" class="headerlink" title="DAO代码优化"></a>DAO代码优化</h1><h2 id="模版方法设计模式"><a href="#模版方法设计模式" class="headerlink" title="模版方法设计模式"></a>模版方法设计模式</h2><p>Dao增删改抽取父类,Dao查询优化用模版方法设计模式,但理论上可以直接在抽象类用结果集元数据+反射处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">find</span><span class="params">(String sql,Object[]args)</span></span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">                preparedStatement.setObject (i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            resultSet = preparedStatement.executeQuery ();</span><br><span class="line">            Object obj=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(resultSet.next ())&#123;</span><br><span class="line">                obj=rowMapper(resultSet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">rowMapper</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql,Object[]args)</span></span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">                preparedStatement.setObject (i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> preparedStatement.executeUpdate ();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String sql,Object[]args)</span></span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">                preparedStatement.setObject (i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            preparedStatement.executeUpdate ();</span><br><span class="line">            resultSet=preparedStatement.getGeneratedKeys ();</span><br><span class="line">            <span class="keyword">if</span>(resultSet.next ())&#123;</span><br><span class="line">                <span class="keyword">return</span> resultSet.getInt (<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find是查询方法,rowMapper由子类DaoImpl实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl</span> <span class="keyword">extends</span> <span class="title">AbstractDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(String loginName,String password)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">"select id,name,money,birthday from user where name=?"</span>;</span><br><span class="line">        Object[] args=&#123;loginName&#125;;</span><br><span class="line">        <span class="keyword">return</span> (User) find (sql,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">rowMapper</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId (resultSet.getInt (<span class="string">"id"</span>));</span><br><span class="line">        user.setName (resultSet.getString (<span class="string">"name"</span>));</span><br><span class="line">        user.setMoney (resultSet.getFloat (<span class="string">"money"</span>));</span><br><span class="line">        user.setBirthday (resultSet.getDate (<span class="string">"birthday"</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">"update user set name=?,birthday=?,money=? where id=?"</span>;</span><br><span class="line">        Object[]args=<span class="keyword">new</span> Object[]&#123;user.getName (),user.getBirthday (),user.getMoney (),user.getId ()&#125;;</span><br><span class="line">        update (sql,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">"delete from user where id=?"</span>;</span><br><span class="line">        Object[]args=<span class="keyword">new</span> Object[]&#123;user.getId ()&#125;;</span><br><span class="line">        update (sql,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">"insert into user(name,birthday,money) values(?,?,?)"</span>;</span><br><span class="line">        Object[]args=<span class="keyword">new</span> Object[]&#123;user.getId ()&#125;;</span><br><span class="line">        <span class="keyword">int</span> id=insert (sql,args);</span><br><span class="line">        <span class="keyword">if</span>(id!=-<span class="number">1</span>)&#123;</span><br><span class="line">            user.setId (id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"插入失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h2><p>上述设计如果要查询多种方式需要在子类写多个rowMapper方法,改成策略模式.MyDaoTemplate定义主要逻辑,在方法参数中传RowMapper接口实现类,方法中调用它的映射方式.DaoImpl2通过组合方式和MyDaoTemplate协作完成查询功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RowMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">mapRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDaoTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">find</span><span class="params">(String sql, Object[] args, RowMapper rowMapper)</span> </span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=JdbcUtil.getConnection ();</span><br><span class="line">            preparedStatement= connection.prepareStatement (sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">                preparedStatement.setObject (i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            resultSet = preparedStatement.executeQuery ();</span><br><span class="line">            Object obj=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(resultSet.next ())&#123;</span><br><span class="line">                obj=rowMapper.mapRow (resultSet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl2</span> </span>&#123;</span><br><span class="line">    MyDaoTemplate myDaoTemplate=<span class="keyword">new</span> MyDaoTemplate ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserName</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">"select name from user where id=?"</span>;</span><br><span class="line">        Object[]args=<span class="keyword">new</span> Object[]&#123;id&#125;;</span><br><span class="line">        Object name=myDaoTemplate.find(sql,args,<span class="keyword">new</span> RowMapper()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">mapRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> rs.getString (<span class="string">"name"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (String) name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUsers</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">"select id,name,money,birthday from user where id=?"</span>;</span><br><span class="line">        Object[]args=<span class="keyword">new</span> Object[]&#123;id&#125;;</span><br><span class="line">        Object user=myDaoTemplate.find(sql,args,<span class="keyword">new</span> RowMapper()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">mapRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                User user=<span class="keyword">new</span> User();</span><br><span class="line">                user.setId (rs.getInt (<span class="string">"id"</span>));</span><br><span class="line">                user.setName (rs.getString (<span class="string">"name"</span>));</span><br><span class="line">                user.setMoney (rs.getFloat (<span class="string">"money"</span>));</span><br><span class="line">                user.setBirthday (rs.getDate (<span class="string">"birthday"</span>));</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (User) user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println (<span class="keyword">new</span> DaoImpl2 ().findUsers (<span class="number">1</span>));</span><br><span class="line">        System.out.println (<span class="keyword">new</span> DaoImpl2 ().findUserName (<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h1><p>spring对jdbc api的封装-&gt;JdbcTemplate</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202408111137453.png" alt="image-20240811113713842"></p>
<p>JdbcTemplate的增强,NamedParameterJdbcTemplate(参数名字),SimpleJdbcTemplate(泛型和可变长参数)</p>
]]></content>
      
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stash用法]]></title>
      <url>/p/87sk0/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用场景：<br>当我们正在修改某个文件的时候，突然当前这个文件有另外一个bug需要马上修复并上线，而当前的修改的功能还没有完善不能直接提交，此时有两种办法可以解决<br>一、新建分支，将当前的修改功能转移到新的分支上，等待后续完善再合并回来<br>二、使用临时保存，git stash 将当前修改的功能临时存储在本地，等到后期恢复再继续完善</p>
<p>基本使用方法：</p>
<p>1、git stash save “ stash remark “  存储的时候增加一个备注<br>2、当要恢复继续完善的时候 git stash pop / git stash apply 就可以恢复到当前的工作目录</p>
<p>其他命令：</p>
<p>（1）git stash save “save message”  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p>
<p>（2）git stash list  ：查看stash了哪些存储</p>
<p>（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</p>
<p>（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@{$num}  -p ，比如第二个：git stash show  stash@{1}  -p</p>
<p>（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} </p>
<p>（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p>
<p>（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储</p>
<p>（8）git stash clear ：删除所有缓存的stash</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/p/87dcg/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="测试博客"><a href="#测试博客" class="headerlink" title="测试博客"></a>测试博客</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></table></figure>
<p>测试博客<br>获得变量</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最大递增子序列]]></title>
      <url>/p/84ma7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="字节一面算法题-求最大递增子序列的结果"><a href="#字节一面算法题-求最大递增子序列的结果" class="headerlink" title="字节一面算法题 求最大递增子序列的结果"></a>字节一面算法题 求最大递增子序列的结果</h2><blockquote>
<p>数组 [94,81,4,6,7,32,11,7,5,17]</p>
</blockquote>
<p>在求数组最大递增子序列长度基础上(dp[i]定义为以下标i结尾的最大递增子序列的长度)，加入哈希表 表示以某一下标结尾的最大递增子序列情况（双端队列），在计算最大递增子序列长度的过程中，通过这个数据结构记录中间结果，同时更新最大递增子序列的下标，最后输出即可，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[]nums=<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">94</span>,<span class="number">81</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">32</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">17</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> len=nums.length;</span><br><span class="line">	<span class="keyword">int</span>[]dp=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">	HashMap&lt;Integer, Deque&lt;Integer&gt;&gt;map=<span class="keyword">new</span> HashMap&lt;Integer, Deque&lt;Integer&gt;&gt;();</span><br><span class="line">	Deque&lt;Integer&gt;list=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	list.offerFirst(nums[<span class="number">0</span>]);</span><br><span class="line">	map.put(<span class="number">0</span>, list);</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i-<span class="number">1</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i]&gt;nums[j]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[i]&lt;dp[j]+<span class="number">1</span>) &#123;</span><br><span class="line">					dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">					index=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Deque&lt;Integer&gt;temp;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(index!=-<span class="number">1</span>) &#123;</span><br><span class="line">			Deque&lt;Integer&gt;list1=map.getOrDefault(index, <span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">			temp=<span class="keyword">new</span> LinkedList&lt;Integer&gt;(list1);</span><br><span class="line">			temp.offerLast(nums[i]);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			temp=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">			temp.offerLast(nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		map.put(i, temp);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(dp[i]&gt;ans) &#123;</span><br><span class="line">			ans=dp[i];</span><br><span class="line">			g=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Deque&lt;Integer&gt;res=map.get(g);</span><br><span class="line">	<span class="keyword">int</span> size=res.size();</span><br><span class="line">	<span class="comment">//System.out.println("ans"+ans);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">		System.out.print(res.pollFirst()+<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树插入和删除]]></title>
      <url>/p/83a24/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式锁学习]]></title>
      <url>/p/82uu9/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>发布订阅，阻塞队列<br>锁上加UUID标识<br>redis </p>
<p>setnx 过期 原子<br>删除自己<br>有效期延迟   看门狗watchdog(业务执行不完要续期) 监控线程 复杂度上升<br>主从的问题</p>
<p>延迟启动<br>RedLock</p>
<p>zookeeper<br>临时节点（会话结束节点消失） watch机制监听<br>同步  序列化</p>
<p>同一物理的数据中心完成</p>
<p>云主机 受网络影响</p>
<p>redis单机挂了<br>redlock多机<br>不是redis实现 是client实现的算法</p>
<p>cas 自己询问<br>事件通知</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手写rpc框架]]></title>
      <url>/p/82rio/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/qq_41373246/article/details/100009385" target="_blank" rel="noopener">https://blog.csdn.net/qq_41373246/article/details/100009385</a></p>
<p><a href="https://dalin.blog.csdn.net/article/details/107805105?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;utm_relevant_index=2" target="_blank" rel="noopener">https://dalin.blog.csdn.net/article/details/107805105?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;utm_relevant_index=2</a></p>
<p>点赞功能<br><a href="https://blog.csdn.net/weixin_45862170/article/details/116139362" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45862170/article/details/116139362</a></p>
<p>tcp_keepalive_time默认是2个小时，也就是TCP空闲连接可以存活2个小时，在close_wait状态下，可以把这个时间调小，减少处于close_wait连接的数量</p>
<p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。<br>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</p>
<p>负载均衡</p>
<p>一致性hash</p>
<p>限流</p>
<p>分布式id<br>uuid 通用唯一标识符（16个字符 空间占用多）<br>数据库主键自增 （数据泄露）<br>redis自增（使用内存，并发性能高  数据丢失 数据泄露）<br>雪花算法（缺点 时钟回拨）<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113125324010.jpg" alt></p>
<p>分布式锁<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113125552953.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113130304988.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113130426864.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113130828119.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113131153868.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113134747315.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113134949450.jpg" alt><br>分布式事务<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113135200606.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113135449787.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113140055297.jpg" alt></p>
<p>can commit<br>pre commit<br>do commit<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113140311740.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113140528783.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113141033971.jpg" alt><br>TCC<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113141139416.jpg" alt></p>
<p>TCC空回滚<br>幂等<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113153500701.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113155301763.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113160017090.jpg" alt></p>
<p>悬挂<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113153854100.jpg" alt><br>可靠消息服务<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113154637453.jpg" alt><br>最大努力通知<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113155136943.jpg" alt><br>zab协议</p>
<p>自动装配  starter</p>
<p>springmvc 9大内置组件</p>
<p>消息队列</p>
<p>submit和execute区别<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113152226073.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113153203975.jpg" alt></p>
<p>client(动态代理类)先动态生成一个对象，表示一个client对象。然后这个client对象调用接口的方法A，方法A一般就是我们需要的服务，然后通过某种机制，方法A的真正调用会发生在server端，server将调用完方法A后，会得到相应的结果，将结果返回给client。那么client和server的一次交互就完成了。整个过程下来，client端申请调用，而server端真正执行调用，最后server端将调用产生的结果返回给client。这样有什么好处呢？客户端一般就是申请服务，如计算服务，而真正的计算的过程会交由服务端进行（理论上服务端的计算资源可以无限大——如集群模式）。典型的hadoop的底层通信框架RPC原理就是如此。</p>
<p>服务端反射调用服务实现者</p>
<p>客户端动态代理（InvocationHandler中向服务端发送函数名和参数列表）<br>其中涉及序列化和反序列化 网络通信</p>
<p>zookeeper做注册中心  负载均衡</p>
<p>Nacos服务分级存储模型<br>NacosRule负载均衡<br>命名空间隔离环境<br>临时实例宕机时，会从nacos的服务列表中剔除，而非临时实例则不会</p>
<p>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</p>
<p>建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置</p>
<p>流控效果</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[rocketmq学习]]></title>
      <url>/p/826mh/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>nameserver</p>
<p>broker<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211223233820385.jpg" alt><br>RocketMQ集群特点</p>
<p>集群模式介绍</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx学习]]></title>
      <url>/p/824vv/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[elasticsearch学习]]></title>
      <url>/p/824vf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>倒排索引<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222092253165.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222092544966.jpg" alt><br>搜索结果处理 排序 分页 高亮</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务学习]]></title>
      <url>/p/822zf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pan.baidu.com/s/169SFtYEvel44hRJhmFTRTQ" target="_blank" rel="noopener">https://pan.baidu.com/s/169SFtYEvel44hRJhmFTRTQ</a><br>提取码：1234</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220163405585.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220163547426.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220164159150.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220165138171.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220182322357.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220182513880.jpg" alt></p>
<p>服务拆分   单一职责<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220182855252.jpg" alt></p>
<p>服务远程调用   发送http请求   RestTemplate<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220191253363.jpg" alt></p>
<p>注册中心  配置中心<br>提供者  消费者<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220192919938.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220193128030.jpg" alt><br>Eureka注册中心</p>
<p>eureka原理分析<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220194532688.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220194656019.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220194723033.jpg" alt></p>
<p>服务注册<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220194928392.jpg" alt></p>
<p>eureka集群   所以要将eureka自己也注册<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220200003298.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220200529095.jpg" alt><br>服务发现<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220200806071.jpg" alt></p>
<p>ribbon负载均衡     轮询 随机等  权重<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220202833189.jpg" alt></p>
<p>负载均衡拦截器<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220203830828.jpg" alt><br>饿</p>
<p>负载策略<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220203924177.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220204136894.jpg" alt></p>
<p>第1种配置全局    第2种针对某个微服务<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220204400210.jpg" alt></p>
<p>饥饿加载<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220205559496.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220205726275.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220205850486.jpg" alt><br>nacos注册中心<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220211128867.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220211210671.jpg" alt><br>nacos和eureka区别   nacos功能更丰富</p>
<p>服务分级存储<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220212024011.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220212327704.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220212414295.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220212634275.jpg" alt></p>
<p>NacosRule负载均衡   修改负载均衡规则   优先选择本地集群  本地集群内随机负载均衡<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220213618430.jpg" alt></p>
<p>nacos服务实例的权重设置   权重越高访问频率越高<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220215910010.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220215934025.jpg" alt></p>
<p>设置为0   版本更新 灰度测试<br>nacos环境隔离  namespace<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220220702485.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220220937073.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220221256395.jpg" alt></p>
<p>临时实例（心跳）    非临时实例（nacos主动询问）<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220222009444.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220222031440.jpg" alt><br>Nacos配置管理    有变化的配置<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220223605326.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220223809589.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220224224679.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220224246401.jpg" alt><br>微服务配置拉取</p>
<p>配置热更新<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220224516750.jpg" alt>   属性注入</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220224826703.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220225146887.jpg" alt><br>多环境配置共享<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220225445319.jpg" alt><br>nacos集群搭建</p>
<p>Feign远程调用    集成了ribbon做负载均衡<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220225955605.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220230244097.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220230411478.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220230444019.jpg" alt>路径占位符</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220231359317.jpg" alt><br>自定义配置<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220231455179.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220231906447.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220232009683.jpg" alt></p>
<p>性能优化<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220232308234.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220232349932.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220232801853.jpg" alt></p>
<p>Feign最佳实践   两种<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220233629186.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220233745549.jpg" alt><br>Gateway网关<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220233830483.jpg" alt></p>
<p>身份认证 权限校验<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220234258449.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220234411485.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220234458724.jpg" alt><br>网关也是一个微服务</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220235126172.jpg" alt></p>
<p>断言 布尔表达式</p>
<p>路由断言工厂</p>
<p>路由的过滤器配置</p>
<p>全局过滤器</p>
<p>过滤器链执行顺序</p>
<p>跨域配置</p>
<p>服务网关  路由请求 负载均衡</p>
<p>微服务保护<br>Sentinel<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220235711897.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221000029206.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221090720485.jpg" alt><br>预防高并发<br>避免如网络问题，full gc的假死（stop the world）<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221090933553.jpg" alt></p>
<p>sentinel和Hystrix<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221091010187.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221091710769.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221091834789.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221092356791.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221092900353.jpg" alt></p>
<p>超时 服务降级  隔离</p>
<p>流量控制<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221093556826.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221093946594.jpg" alt></p>
<p>jmeter测试计划<br>流控模式<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221095439348.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221100516390.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221100819957.jpg" alt>    链路 请求来源<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221100933723.jpg" alt><br>流控效果<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221101047863.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221101401886.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221101824015.jpg" alt><br>隔离和降级<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221101934238.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221102513324.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221102750224.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221102920090.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221103019303.jpg" alt></p>
<p>线程隔离<br>线程池  信号量<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221103252952.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221103818701.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221103916977.jpg" alt></p>
<p>熔断降级   断路器   状态机   熔断持续时间   阈值   熔断策略<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221104420097.jpg" alt><br>熔断策略  慢调用 异常比例  异常数<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221104538762.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221104918340.jpg" alt><br>授权规则和规则持久化    请求者身份判断<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221110331675.jpg" alt><br>授权规则<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221110544728.jpg" alt><br>自定义异常结果<br>实现BlockExceptionHandler</p>
<h1 id="规则持久化-默认内存"><a href="#规则持久化-默认内存" class="headerlink" title="规则持久化  默认内存"></a>规则持久化  默认内存</h1><p>规则管理模式<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221111738235.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221111956662.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221112054964.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221112126563.jpg" alt><br>实现push模式</p>
<p>与Hystrix区别</p>
<p>分布式事务理论<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221115322702.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221115439645.jpg" alt><br>CAP定理<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221115634326.jpg" alt></p>
<p>数据同步<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221115813799.jpg" alt><br>响应<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221115900939.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221120044769.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221120315753.jpg" alt><br>BASE理论<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221121115533.jpg" alt><br>事务协调者<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221121335487.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221121454391.jpg" alt><br>Seata架构<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221121936368.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221122041906.jpg" alt><br>TC服务</p>
<p>微服务集成seata<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221124556958.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211221124808858.jpg" alt><br>XA<br>TCC<br>AT<br>SAGA<br>熔断机制</p>
<p>分布式锁</p>
<p>分布式搜索</p>
<p>持续集成</p>
<p>多级缓存</p>
<p>缓存同步</p>
<p>lua语法</p>
<p>消息堆积  惰性队列</p>
<p>截图工具 snipaste</p>
<p>translate</p>
<p>服务链路监控 Zipkin  Sleuth</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springmvc学习]]></title>
      <url>/p/822r0/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>DispatcherServlet<br>Servlet<br>@Controller<br>@RequestMapping<br>@Scope<br>@RequestParam(name=””)   defaultValue  required</p>
<p>重定向  改变浏览器url<br>转发   不改变浏览器url<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220120428533.jpg" alt><br>HttpServletRequest<br>HttpServletResponse<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220120756004.jpg" alt></p>
<p>redirct 重定向<br>forward 转发    默认转发<br>视图解析器与中文乱码问题<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220122325451.jpg" alt><br>视图解析器对重定向无效 只对转发有效<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220122624117.jpg" alt></p>
<p>过滤器<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220123045633.jpg" alt><br>配置过滤器      字符编码过滤器  CharsetEncoderFilter<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220123257827.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220123554021.jpg" alt><br>带数据与统一异常处理问题</p>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>request.setAttribute(“user”,user);<br>通过request域来保存数据   ${requestScope.user}</p>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>model.addAttribute(“user”,user);    实际封装了request<br>通过request域来保存数据   ${requestScope.user}</p>
<h1 id="3-通过map集合带数据-Mapmap-map集合存在于request"><a href="#3-通过map集合带数据-Mapmap-map集合存在于request" class="headerlink" title="3 通过map集合带数据 Mapmap     map集合存在于request"></a>3 通过map集合带数据 Map<string,object>map     map集合存在于request</string,object></h1><p>map.put(“aaa”,”ssss”);<br>${requestScope.aaa}</p>
<p>只能处理当前Controller异常<br>@ExceptionHandler(Exception.class)   ArithmeticException   精确匹配</p>
<p>统一异常处理 用@ControllerAdvice注解</p>
<p>json   @ResponseBody<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220133124912.jpg" alt></p>
<p>实体类转化为json</p>
<p>Map集合转化为json</p>
<p>List集合转化为json</p>
<p>返回boolean int</p>
<p>单文件上传<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220134126406.jpg" alt><br>导入jar包<br>fileupload和io包<br>springmvc.xml配置<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220134259916.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220134643241.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220135007001.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220135513667.jpg" alt></p>
<p>pageContext request  session  application<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220135953013.jpg" alt><br>ServletContext</p>
<p>UUID   网卡号 时间戳<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220140636734.jpg" alt><br>多文件上传</p>
<p>数据校验  @Valid BindingResult<br>@Pattern(regexp=””,message=””)</p>
<p>正则表达式 可读性差</p>
<p>导入校验jar包</p>
<p>配置<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220141624128.jpg" alt><br>@Valid         BindingResult  (校验错误信息封装)<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220142223896.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220142514234.jpg" alt><br>任务定时器<br>task</p>
<p>配置定时器   Cron表达式    秒 分 时 天  月 周 年<br>@Scheduled(Cron=””)<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220143011954.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220143309123.jpg" alt></p>
<p>SimpleDateFormat</p>
<p>HttpClient</p>
<p>数据回显 错误处理页面   404 500处理页面</p>
<p>拦截器  implements HandlerIntercepter<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220150935209.jpg" alt></p>
<p>springmvc配置拦截器<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220152549497.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220153238373.jpg" alt></p>
<p>数据交互   json<br>RequestBody<br>ResponseBody</p>
<p>onsubmit事件<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220155949624.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211220160738534.jpg" alt></p>
<p>ajaxs</p>
<p>HandlerMapping   映射器<br>HandlerAdapter   适配器</p>
<p>过滤器和拦截器区别</p>
<p><a href="https://blog.csdn.net/aoxiangzhe/article/details/90399909" target="_blank" rel="noopener">https://blog.csdn.net/aoxiangzhe/article/details/90399909</a></p>
<p>springmvc  9个内置对象 4个作用域<br><a href="https://blog.csdn.net/Miracle_Gaaral/article/details/99863769" target="_blank" rel="noopener">https://blog.csdn.net/Miracle_Gaaral/article/details/99863769</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义springIOC]]></title>
      <url>/p/81vgq/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springmvc流程]]></title>
      <url>/p/81t81/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[秒杀项目开发]]></title>
      <url>/p/81s1c/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[博客项目开发]]></title>
      <url>/p/81rob/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IDEA设置热加载"><a href="#IDEA设置热加载" class="headerlink" title="IDEA设置热加载"></a>IDEA设置热加载</h1><p>加入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="使用springMVC开发-RESTFUL-API"><a href="#使用springMVC开发-RESTFUL-API" class="headerlink" title="使用springMVC开发 RESTFUL API"></a>使用springMVC开发 RESTFUL API</h1><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210121750746.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210122028094.jpg" alt><br>编写针对RESTfulAPI测试用例<br>MockMvc</p>
<p>使用REST服务处理文件<br>多线程提高性能</p>
<h2 id="使用Filter和interceptor拦截REST服务"><a href="#使用Filter和interceptor拦截REST服务" class="headerlink" title="使用Filter和interceptor拦截REST服务"></a>使用Filter和interceptor拦截REST服务</h2><h2 id="使用swagger自动生成文档"><a href="#使用swagger自动生成文档" class="headerlink" title="使用swagger自动生成文档"></a>使用swagger自动生成文档</h2><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210123716279.jpg" alt></p>
<p>扫描程序生成文档</p>
<p>参考<a href="https://blog.csdn.net/zhanggonglalala/article/details/98070986" target="_blank" rel="noopener">https://blog.csdn.net/zhanggonglalala/article/details/98070986</a></p>
<ul>
<li><p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构建swagger配置类  SwaggerConfig</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@EnableSwagger2</span></span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建API</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        <span class="comment">// 指定扫描包路径</span></span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Docket</span>(DocumentationType.SWAGGER_2) <span class="comment">// 指定生成的文档的类型是Swagger2</span></span><br><span class="line"><span class="comment">//                .pathMapping("/swagger")</span></span><br><span class="line">                <span class="comment">// 用来创建该API的基本信息，展示在文档的页面中（自定义展示的信息）,配置文档页面的基本信息内容</span></span><br><span class="line">                <span class="comment">// 设置哪些接口暴露给Swagger展示</span></span><br><span class="line">                <span class="selector-class">.select</span>()</span><br><span class="line">                <span class="comment">// 扫描所有有注解的api，用这种方式更灵活</span></span><br><span class="line">                <span class="comment">//.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span></span><br><span class="line">                <span class="selector-class">.apis</span>(RequestHandlerSelectors.basePackage(<span class="string">"com.oycbest.springbootswagger.controller"</span>))</span><br><span class="line">                <span class="comment">// 扫描所有 .apis(RequestHandlerSelectors.any())</span></span><br><span class="line">                <span class="selector-class">.paths</span>(PathSelectors.any())<span class="selector-class">.build</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加摘要信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">ApiInfo</span> <span class="selector-tag">apiInfo</span>() &#123;</span><br><span class="line">        <span class="comment">// 用ApiInfoBuilder进行定制</span></span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">// 设置标题</span></span><br><span class="line">                <span class="selector-class">.title</span>(<span class="string">"描述：Spring Boot中使用Swagger2构建RESTful APIs"</span>)</span><br><span class="line">                <span class="comment">// 描述</span></span><br><span class="line">                <span class="selector-class">.description</span>(<span class="string">"swagger 测试demo"</span>)</span><br><span class="line">                <span class="comment">// 版本</span></span><br><span class="line">                <span class="selector-class">.version</span>(<span class="string">"版本号: 1.0.1"</span>)</span><br><span class="line">                <span class="selector-class">.build</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在controller中添加swagger接口注解</p>
</li>
</ul>
<blockquote>
<p>@Api 修饰整个类，描述Controller的作用。<br>@ApiOperation 修饰一个类的一个方法，或者说一个接口 ，可以描述这个方法的功能和注意事项。若不使用则用函数名作为方法功能。<br>       参数：value=”说明方法的用途、作用”<br>notes=”方法的备注说明”<br>@apiResponses：用在请求的方法上，表示一组响应<br>@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息<br>        code：数字，例如400<br>        message：信息，例如”请求参数没填好”<br>        response：抛出异常的类<br>@ApiImplicitParams 修饰方法，可以描述这个方法的参数的作用。若不使用则用参数名作为参数的作用。<br>@ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面<br>        name：参数名<br>        value：参数的汉字说明、解释<br>        required：参数是否必须传<br>        paramType：参数放在哪个地方<br>            · header —&gt; 请求参数的获取：@RequestHeader<br>            · query —&gt; 请求参数的获取：@RequestParam<br>            · path（用于restful接口）—&gt; 请求参数的获取：@PathVariable<br>            · body（不常用）<br>            · form（不常用）<br>        dataType：参数类型，默认String，其它值dataType=”Integer”<br>        defaultValue：参数的默认值<br>@ApiModel 修饰实体类，可以描述这个类的功能。<br>@ApiModelProperty 修饰实体类的属性，可以描述这个属性的作用。<br>@ApiIgnore修饰参数、方法和类，可以在自动生成文档时对修饰的对象进行忽略。<br>@ApiError ：发生错误返回的信息 </p>
<ul>
<li>查看&amp;测试接口<br>发现报错<br>这是因为Springfox使用的路径匹配是基于AntPathMatcher的，而Spring Boot 2.6.X使用的是PathPatternMatcher。 解决： 修改application.yaml spring: mvc: pathmatch: matching-strategy: ANT_PATH_MATCHER</li>
</ul>
</blockquote>
<p>如果没有引入安全框架或设置路径拦截机制，可以直接访问 <a href="http://127.0.0.1:8080/[项目名称]/swagger-ui.html查看接口。" target="_blank" rel="noopener">http://127.0.0.1:8080/[项目名称]/swagger-ui.html查看接口。</a><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210133755919.jpg" alt></p>
<h2 id="使用WireMock伪造REST服务"><a href="#使用WireMock伪造REST服务" class="headerlink" title="使用WireMock伪造REST服务"></a>使用WireMock伪造REST服务</h2><h2 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h2><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210134218497.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210134300233.jpg" alt><br>BufferedImage</p>
<p>ImageIO.write<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210135523720.jpg" alt></p>
<h2 id="记住我功能"><a href="#记住我功能" class="headerlink" title="记住我功能"></a>记住我功能</h2><p>手机短信登录，qq登录</p>
<p>UserDetailsService自定义登录认证逻辑<br>loadUserByUsername方法</p>
<p>自定义认证流程<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210141743140.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210135907142.jpg" alt></p>
<p>自定义登录成功处理器<br>实现AuthenticationSuccessHandler接口中的方法</p>
<p>自定义登录失败处理器<br>实现AuthenticationFailureHandler接口中的方法</p>
<p>@Secured   @PreAuthorize  注解</p>
<p>基于权限判断   像会员   hasAuthority(“admin”)  hasAnyAuthority<br>基于角色判断    hasRole()   hasAnyRole(“abc”)<br>实现的UserDetailsService类中角色为 ROLE_abc<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210150905189.jpg" alt></p>
<p>403页面</p>
<p>remember-me<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210152225363.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210153658402.jpg" alt></p>
<p>退出登录</p>
<p>csrf<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210155026934.jpg" alt></p>
<p>访问请求参数要有_csrf 值为token 否则不通过<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210160128995.jpg" alt></p>
<p>redis存储token<br>引入redis依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>application.yml 中加入redis相关配置</p>
<p>编写redis配置类   参考<a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html" target="_blank" rel="noopener">redis与springboot集成</a></p>
<p>认证机制<br>Basic 用户名和密码<br>Cookie  认证<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210161820332.jpg" alt></p>
<p>Oauth<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210162057223.jpg" alt><br>Token Auth   签发token  节约系统资源  token是字符串  session是对象<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210162222180.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210163502525.jpg" alt></p>
<p>jwt   一个标准   头部和载荷不要放敏感信息<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210164052687.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210170102148.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210170257415.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210170352082.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210170637676.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210170837625.jpg" alt></p>
<p>jjwt<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210171043850.jpg" alt><br>springboot集成jjwt<br>引入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- json工具 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.68<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jwt --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>token生成  JwtBuilder<br>token解析<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210181054296.jpg" alt></p>
<p>jwt过期校验<br>生成jwt时带有失效时间<br>setExpiration(new Date(exp))</p>
<p>jwtUtils<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lss.jwt_test.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lss.jwt_test.rest.TestController;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.codec.<span class="built_in">binary</span>.Base64;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class JwtUtils &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token 过期时间, 单位: 秒. 这个值表示 30 天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TOKEN_EXPIRED_TIME = <span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> jwtId = <span class="string">"tokenId"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jwt 加密解密密钥(可自行填写)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> JWT_SECRET = <span class="string">"1234567890"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建JWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> createJWT(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; claims, Long time) &#123;</span><br><span class="line">        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; <span class="comment">//指定签名的时候使用的签名算法，也就是header那部分，jjwt已经将这部分内容封装好了。</span></span><br><span class="line">        Date now = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        SecretKey secretKey = generalKey();</span><br><span class="line">        <span class="keyword">long</span> nowMillis = System.currentTimeMillis();<span class="comment">//生成JWT的时间</span></span><br><span class="line">        <span class="comment">//下面就是在为payload添加各种标准声明和私有声明了</span></span><br><span class="line">        JwtBuilder builder = Jwts.builder() <span class="comment">//这里其实就是new一个JwtBuilder，设置jwt的body</span></span><br><span class="line">                .setClaims(claims)          <span class="comment">//如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的</span></span><br><span class="line">                .setId(jwtId)                  <span class="comment">//设置jti(JWT ID)：是JWT的唯一标识，根据业务需要，这个可以设置为一个不重复的值，主要用来作为一次性token,从而回避重放攻击。</span></span><br><span class="line">                .setIssuedAt(now)           <span class="comment">//iat: jwt的签发时间</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey);<span class="comment">//设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">        <span class="keyword">if</span> (time &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> expMillis = nowMillis + time;</span><br><span class="line">            Date <span class="built_in">exp</span> = <span class="keyword">new</span> Date(expMillis);</span><br><span class="line">            builder.setExpiration(<span class="built_in">exp</span>);     <span class="comment">//设置过期时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证jwt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims verifyJwt(<span class="keyword">String</span> token) &#123;</span><br><span class="line">        <span class="comment">//签名秘钥，和生成的签名的秘钥一模一样</span></span><br><span class="line">        SecretKey <span class="built_in">key</span> = generalKey();</span><br><span class="line">        Claims claims;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()  <span class="comment">//得到DefaultJwtParser</span></span><br><span class="line">                    .setSigningKey(<span class="built_in">key</span>)         <span class="comment">//设置签名的秘钥</span></span><br><span class="line">                    .parseClaimsJws(token).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            claims = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="comment">//设置需要解析的jwt</span></span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由字符串生成加密key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecretKey generalKey() &#123;</span><br><span class="line">        <span class="keyword">String</span> stringKey = JWT_SECRET;</span><br><span class="line">        <span class="built_in">byte</span>[] encodedKey = Base64.decodeBase64(stringKey);</span><br><span class="line">        SecretKey <span class="built_in">key</span> = <span class="keyword">new</span> SecretKeySpec(encodedKey, <span class="number">0</span>, encodedKey.length, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据userId和openid生成token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> generateToken(<span class="keyword">String</span> openId, Integer userId) &#123;</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">"userId"</span>, userId);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">"openId"</span>, openId);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">"sub"</span>, openId);</span><br><span class="line">        <span class="keyword">return</span> createJWT(<span class="built_in">map</span>, TOKEN_EXPIRED_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">// 生成token</span></span><br><span class="line">        <span class="keyword">String</span> s = generateToken(<span class="string">"111"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证</span></span><br><span class="line">        <span class="keyword">String</span> token = <span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMTEiLCJvcGVuSWQiOiIxMTEiLCJleHAiOjE1OTI1NTc3ODMsInVzZXJJZCI6MjAsImlhdCI6MTU5MjU1NTE5MSwianRpIjoidG9rZW5JZCJ9.X7JHnx3Y5wtb-n3pT9tft2I4hENJdeRxW2QWaI4jv2E"</span>;</span><br><span class="line">        Claims claims = verifyJwt(token);</span><br><span class="line">        <span class="keyword">String</span> subject = claims.getSubject();</span><br><span class="line">        <span class="keyword">String</span> userId = (<span class="keyword">String</span>)claims.<span class="built_in">get</span>(<span class="string">"userId"</span>);</span><br><span class="line">        <span class="keyword">String</span> openId = (<span class="keyword">String</span>)claims.<span class="built_in">get</span>(<span class="string">"openId"</span>);</span><br><span class="line">        <span class="keyword">String</span> sub = (<span class="keyword">String</span>)claims.<span class="built_in">get</span>(<span class="string">"sub"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"subject:"</span> + subject);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"userId:"</span> + userId);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"openId:"</span> + openId);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"sub:"</span> + sub);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环依赖解决<br>spring:<br>  main:<br>      allow-circular-references: true</p>
<h2 id="spring-AOP日志"><a href="#spring-AOP日志" class="headerlink" title="spring AOP日志"></a>spring AOP日志</h2><p><a href="https://blog.csdn.net/zhuzhezhuzhe1/article/details/80565067" target="_blank" rel="noopener">参考博客</a></p>
<p>添加依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>自定义注解<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210203917818.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210203949909.jpg" alt></p>
<p>切点表达式、环绕通知、前置通知、后置通知</p>
<p>在消息产生的生产者方法加入效果<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210212622603.jpg" alt></p>
<p>博客接口开发</p>
<p>springboot与rabbitmq集成<br>加入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitmq--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210191441168.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210192122032.jpg" alt></p>
<p>rabbitmq 配置类</p>
<p>注入RabbitTemplate<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"boot_topic_exchange"</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"boot_queue"</span>;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="meta">@Bean(<span class="meta-string">"bootExchange"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange bootExchange()&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="meta">@Bean(<span class="meta-string">"bootQueue"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Queue bootQueue()&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列和交换机绑定关系Binding</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding bindQueueExchange(<span class="meta">@Qualifier(<span class="meta-string">"bootQueue"</span>)</span>Queue queue,<span class="meta">@Qualifier(<span class="meta-string">"bootExchange"</span>)</span>Exchange exchange)&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"boot.#"</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210200228920.jpg" alt><br>定义监听类，使用@RabbitListener注解完成队列监听<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210201452046.jpg" alt></p>
<h2 id="验证码检验功能开发"><a href="#验证码检验功能开发" class="headerlink" title="验证码检验功能开发"></a>验证码检验功能开发</h2><p><a href="https://www.jb51.net/article/143170.htm?utm_medium=referral" target="_blank" rel="noopener">参考实现</a></p>
<p>了解反射  ThreadLocal 循环依赖 aop  设计模式  </p>
<p>线程池    阅读数<br>redis数据结构</p>
<h2 id="前端Vue开发"><a href="#前端Vue开发" class="headerlink" title="前端Vue开发"></a>前端Vue开发</h2>]]></content>
      
        
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python开发图床工具]]></title>
      <url>/p/81qzl/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="picGo传输图片有数量限制所以自己设计用python开发了一个图床工具"><a href="#picGo传输图片有数量限制所以自己设计用python开发了一个图床工具" class="headerlink" title="picGo传输图片有数量限制所以自己设计用python开发了一个图床工具"></a>picGo传输图片有数量限制所以自己设计用python开发了一个图床工具</h1><h2 id="1-在gitee创建仓库和令牌"><a href="#1-在gitee创建仓库和令牌" class="headerlink" title="1 在gitee创建仓库和令牌"></a>1 在gitee创建仓库和令牌</h2><h2 id="2-本地用360浏览器截图并保存到固定文件夹中，由于文件夹按顺序排序，python获取文件夹最后一个图片即为刚刚截图的图片，用requests调用方法将图片传到gitee仓库"><a href="#2-本地用360浏览器截图并保存到固定文件夹中，由于文件夹按顺序排序，python获取文件夹最后一个图片即为刚刚截图的图片，用requests调用方法将图片传到gitee仓库" class="headerlink" title="2 本地用360浏览器截图并保存到固定文件夹中，由于文件夹按顺序排序，python获取文件夹最后一个图片即为刚刚截图的图片，用requests调用方法将图片传到gitee仓库"></a>2 本地用360浏览器截图并保存到固定文件夹中，由于文件夹按顺序排序，python获取文件夹最后一个图片即为刚刚截图的图片，用requests调用方法将图片传到gitee仓库</h2><h2 id="3-用tkinter做图形化界面，加按钮监听调用方法，同时返回需要的字符串，清空剪贴板，将字符串复制到剪贴板中。之后可用pyinstaller将python制作成exe文件运行"><a href="#3-用tkinter做图形化界面，加按钮监听调用方法，同时返回需要的字符串，清空剪贴板，将字符串复制到剪贴板中。之后可用pyinstaller将python制作成exe文件运行" class="headerlink" title="3 用tkinter做图形化界面，加按钮监听调用方法，同时返回需要的字符串，清空剪贴板，将字符串复制到剪贴板中。之后可用pyinstaller将python制作成exe文件运行"></a>3 用tkinter做图形化界面，加按钮监听调用方法，同时返回需要的字符串，清空剪贴板，将字符串复制到剪贴板中。之后可用pyinstaller将python制作成exe文件运行</h2><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211209213641555.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211209214101301.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211209214231783.jpg" alt></p>
<h2 id="4-源代码"><a href="#4-源代码" class="headerlink" title="4 源代码"></a>4 源代码</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line">from tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    token = gitee的token令牌</span><br><span class="line">    owner = <span class="string">'mosheng123456789'</span></span><br><span class="line">    repo = <span class="string">'pics'</span></span><br><span class="line">    message = <span class="string">'personal'</span></span><br><span class="line">    image_list=os.listdir(<span class="string">'D:/newcoder-test/img'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'D:/newcoder-test/img/'</span>+image_list[-<span class="number">1</span>], <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = base64.b64encode(f.read())</span><br><span class="line">    <span class="keyword">data</span> = &#123;<span class="string">'access_token'</span>: token, <span class="string">'message'</span>: message, <span class="string">'content'</span>: content&#125;</span><br><span class="line">    <span class="built_in">path</span> = <span class="string">'img/'</span>+image_list[-<span class="number">1</span>]</span><br><span class="line">    res = requests.post(<span class="string">'https://gitee.com/api/v5/repos/'</span> + owner + <span class="string">'/'</span> + repo +<span class="string">'/contents/'</span>+ <span class="built_in">path</span>, <span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">201</span> <span class="built_in">or</span> res.<span class="keyword">text</span> == <span class="string">'&#123;"message":"文件名已存在"&#125;'</span>:</span><br><span class="line">        tkinter.messagebox.showinfo(<span class="string">'提示'</span>, <span class="string">'图片上传成功'</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'https://gitee.com/'</span> + owner + <span class="string">'/'</span> + repo + <span class="string">'/raw/master/'</span> + <span class="built_in">path</span>)</span><br><span class="line">        str=<span class="string">'![]('</span>+<span class="string">'https://gitee.com/'</span> + owner + <span class="string">'/'</span> + repo + <span class="string">'/raw/master/'</span> + <span class="built_in">path</span>+<span class="string">')'</span></span><br><span class="line">        # l1 = Entry(top, <span class="keyword">text</span>=str)     #输入框</span><br><span class="line"></span><br><span class="line">        # l1 = Label(top, <span class="keyword">text</span>=<span class="string">'图片上传成功'</span>)</span><br><span class="line">        # l1.pack(side=BOTTOM)</span><br><span class="line">        # top.withdraw()</span><br><span class="line">        top.clipboard_clear()</span><br><span class="line">        top.clipboard_append(str)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tkinter.messagebox.showinfo(<span class="string">'提示'</span>, <span class="string">'图片上传失败'</span>)</span><br><span class="line">        </span><br><span class="line">top = tkinter.Tk()</span><br><span class="line">top.geometry(<span class="string">"500x400"</span>)</span><br><span class="line">top.<span class="built_in">title</span>(<span class="string">'python开发图床工具'</span>)</span><br><span class="line">B = tkinter.Button(top, <span class="keyword">text</span> =<span class="string">"上传截图图片"</span>, command = main)</span><br><span class="line">B.pack()</span><br><span class="line"># 进入消息循环</span><br><span class="line">top.mainloop()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java的IO学习]]></title>
      <url>/p/81li4/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通信<br><img src="https://s2.loli.net/2021/12/04/JAT2dajlZfVNOvb.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/04/1o3RkCYTGP7AmyU.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/04/d4zgojXVJNrxbsn.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/04/3ZyxsvAGkb8h6aU.png" alt></p>
<p>java.io<br>BIO多发多收   任意类型文件上传    端口转发</p>
<p>java.nio<br>NIO   面向缓冲区  基于通道</p>
<p>直接与非直接缓冲区    直接内存</p>
<p>NIO三大核心</p>
<p>Selector</p>
<p>linux 5种io模型<br>阻塞式I/O模型(也就是BIO，Blocking IO) 如果当前内核中数据没有准备好，那么会让出CPU时间片，一直阻塞等待，不会进行其他操作。直到内核中的数据准备好</p>
<p>非阻塞时I/O模型  当该数据未到达的时候，进程会不断询问内核，直到内核准备好数据。 </p>
<p>I/O多路复用模型<br>基础版的I/O复用模型<br>select和poll</p>
<p>epoll 基于事件 水平触发  边缘触发</p>
<p>信息驱动式I/O模型  内核准备好数据后，会给用户态发送一个信号</p>
<p>异步I/O模型   内核准备好数据后  在数据从内核态拷贝到用户空间之后，内核才通知用户态进程来处理数据</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库优化学习]]></title>
      <url>/p/81jzi/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>完全备份 差异备份  增量备份<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211214235917883.jpg" alt></p>
<p>热备  冷备   运行状态<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215001141835.jpg" alt><br>范式    主键   候选键  MVCC    表空间  线程</p>
<p>explain   执行计划<br><img src="https://s2.loli.net/2021/12/03/1HTOfsxWpkKgtnX.png" alt><br><img src="https://s2.loli.net/2021/12/03/9LdDphiUITJKs5v.png" alt><br><img src="https://s2.loli.net/2021/12/03/ks2Gc8N4j7KgUqf.png" alt><br>从上到下执行效率越来越低</p>
<p>type  访问类型<br><img src="https://s2.loli.net/2021/12/03/V5NMlpCFjBW4O7w.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/03/t2aU9kFTrRGPQqS.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/03/F2y5toh7WZKfVDp.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/03/p7fgoNAdQYGz3BP.png" alt><br>show profiles    sql语句各个阶段耗时情况<br><img src="https://s2.loli.net/2021/12/03/CYRPGfkWINbD4H1.png" alt><br>之后推荐用performance_schema</p>
<p><img src="https://s2.loli.net/2021/12/03/LpStdaVAMOnXuJ7.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/03/2XCcZuJdMORAft5.png" alt></p>
<p>trace优化器执行计划<br><img src="https://s2.loli.net/2021/12/03/3JyBUESDMlspKRq.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/03/3UpZF8bncsBLf6A.png" alt></p>
<p><img src="https://s2.loli.net/2021/12/03/9Db1t4fdkG5OQce.png" alt><br><img src="https://s2.loli.net/2021/12/03/wuUlQfTBJFVKCdz.png" alt></p>
<p>索引使用<br>全值匹配<br><img src="https://s2.loli.net/2021/12/03/nicPONo2Zb8xwWM.png" alt></p>
<p>最左前缀</p>
<p><img src="https://s2.loli.net/2021/12/04/7TjCe5NXuqSy3Qs.png" alt></p>
<p>字符串不加单引号索引失效   隐式字段运算</p>
<p>尽量使用覆盖索引，不使用select*   要再查</p>
<p>or索引失效   有一个不用都不用</p>
<p>like模糊匹配    like ‘ss%’不失效      覆盖索引</p>
<p>全表扫描更快    如果mysql评估全表扫描速度比走索引快不走索引</p>
<p>NULL值的判定   is NULL   is  not null    看哪个效率高</p>
<p>in和not in     in走索引   not in 不走索引   （有点问题  再查一查知识点）</p>
<p>尽量使用联合索引   相当于创建多个索引</p>
<p>查看索引使用情况<br>show status  like  ‘Handler_read%’</p>
<p>sql优化<br>大批量插入数据</p>
<p>insert</p>
<p>order by<br>group by<br>子查询<br>or<br>limit<br>索引提示</p>
<p>数据库三范式<br>第一范式（1NF）无重复的列<br>　　所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p>
<p>1NF的定义为：符合1NF的关系中的每个属性都不可再分<br>说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。<br>第二范式（2NF）属性完全依赖于主键<br> 　　第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。<br>        第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。 </p>
<p>第三范式（3NF）<br> 　　满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p>
<p>候选码和主码<br><a href="https://blog.csdn.net/cry_shoulder/article/details/94549319" target="_blank" rel="noopener">https://blog.csdn.net/cry_shoulder/article/details/94549319</a></p>
<p><a href="https://blog.csdn.net/weixin_34348174/article/details/93203053?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.fixedcolumn&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.fixedcolumn" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34348174/article/details/93203053?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.fixedcolumn&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.fixedcolumn</a></p>
<p>弱实体<br><a href="https://blog.csdn.net/sinat_38007523/article/details/80229186" target="_blank" rel="noopener">https://blog.csdn.net/sinat_38007523/article/details/80229186</a></p>
<p>ER图转关系模式<br><a href="https://blog.csdn.net/qq_43179428/article/details/105309972" target="_blank" rel="noopener">https://blog.csdn.net/qq_43179428/article/details/105309972</a></p>
<p>fiddler    certmgr.msc<br><a href="https://www.cnblogs.com/woaixuexi9999/p/9247705.html" target="_blank" rel="noopener">https://www.cnblogs.com/woaixuexi9999/p/9247705.html</a></p>
<p>regedit</p>
<p>csrf   csrftoken</p>
<p>java的Io流<br><a href="https://blog.csdn.net/zhaoyanjun6/article/details/54292148" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/54292148</a><br>节点流  处理流 </p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习计划]]></title>
      <url>/p/81jxd/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>看视频<br>王道考研：计算机网络   操作系统</p>
<p>黑马程序员：jvm  mysql高级优化  redis  并发</p>
<p>linux:看书 实践</p>
<p>设计模式：ppt 视频</p>
<p>javaio</p>
<p>刷题  看面试题</p>
<p>项目  shiro  springsecurity视频</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java并发学习]]></title>
      <url>/p/81jwd/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>函数式编程 lambda<br>应用  原理<br>多线程设计模式</p>
<p>spring<br>双重检查锁 2次检查1级缓存</p>
<p>读取配置<br>BeanDefinitionReader</p>
<p>解析<br>配置类解析器<br>Configurationclassparser</p>
<p>扫描<br>ClassPathBeanDefinitionScanner doScan方法</p>
<p>所有bean创建完扩展<br>实现SmartInitializingSingleton接口<br>创建ContextRefreshedEvent事件监听器</p>
<p>javaConfig<br>AnnotaionConfigApplicationContext<br>AnnotedBeanDefinitionReader<br>解析各种注解@Bean  @Component<br>ConfigureClassParser</p>
<p>xml<br>ClassPathXmlApplicationContext<br>XmlBeanDefinitionReader<br>解析<br>DefaultBeanDefinitionDocumentReader</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ELK学习]]></title>
      <url>/p/81i71/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dubbo学习]]></title>
      <url>/p/81i5h/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RPC框架<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222123629105.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222124538588.jpg" alt></p>
<p>推荐使用zookeeper做注册中心<br>@Service<br>@Reference 远程注入<br>配置项目名称<br>配置注册中心地址</p>
<p>dubbo高级特性<br>dubbo-admin管理平台<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222134056697.jpg" alt></p>
<p>序列化<br>地址缓存<br>超时<br>重试<br>多版本<br>负载均衡<br>集群容错<br>服务降级</p>
<p>从系统结构简易程序：springcloud的系统结构更简单、“注册+springmvc=springcloud”，而dubbo各种复杂的Url，protocol，register，invocation，dubbofilter，dubboSPI，dubbo序列化……….炫技的成分更多一些</p>
<p>从性能：dubbo的网络消耗小于springcloud，但是在国内95%的公司内，网络消耗不是什么太大问题，如果真的成了问题，通过压缩、二进制、高速缓存、分段降级等方法，很容易解</p>
<p>dubbo的神坑是jar包依赖，开发阶段难度极大</p>
<p>dubbo的改进是通过dubbofilter</p>
<p>从整个大的平台架构来讲，dubbo框架只是专注于服务之间的治理，如果我们需要使用配置中心、分布式跟踪这些内容都需要自己去集成，这样无形中使用dubbo的难度就会增加。Spring Cloud几乎考虑了服务治理的方方面面，更有Spring Boot这个大将的支持，开发起来非常的便利和简单。</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper学习]]></title>
      <url>/p/81i5h/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分布式应用程序协调服务<br>配置管理<br>分布式锁<br>集群管理（注册中心）</p>
<p>leader选举  paxos算法<br>leader follower observer</p>
<p>zoo.cfg<br>dataDir<br>server.1=             心跳端口  选举端口<br>server.2=<br>server.3=</p>
<p>myid<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222101228620.jpg" alt><br>序列化<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222101626751.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222101820370.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222102002325.jpg" alt></p>
<p>zkCli.sh -server ip</p>
<p>create -s(序列化) -e（临时）   默认非序列化 持久节点<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222105012641.jpg" alt><br>delete<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222110331140.jpg" alt><br>quota 日志警告<br>history redo<br>watcher<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222111307328.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222111559015.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222111745964.jpg" alt><br>集群选举<br>FastLeaderElection<br>全新集群   主要看服务器id<br>非全新集群<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222113628702.jpg" alt><br>数据发布与订阅<br>命名服务  分布式锁<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222113905103.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222114129395.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222114607154.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222114627759.jpg" alt><br>序列化</p>
<p>不同节点线程访问<br>redis分布式锁<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222115713701.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222115942913.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211222120348281.jpg" alt></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[rabbitmq学习]]></title>
      <url>/p/81i5a/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用解耦   提升容错性和可维护性<br>异步提速   提升吞吐量<br>削峰填谷   提高系统稳定性</p>
<p>可用性降低<br>复杂度提高   以前同步远程调用  现在MQ异步调用，怎么保证消息不重复  不丢失  顺序正确<br>一致性问题</p>
<p>容许短暂不一致性</p>
<p>开发语言   erlang<br>协议    AMQP   高级消息队列协议（网络协议   应用层协议开放标准）</p>
<p>吞吐量   万级                      RocketMQ<br>消息延迟   延迟最低                Kafka</p>
<p>并发能力强  社区活跃</p>
<p>publisher exchange（路由分发）  routes  queue   consumer</p>
<p>Broker（RabbitMQ  Server）    visual host 逻辑分区<br> Binding</p>
<p>建立tcp连接</p>
<p>JMS  java  message server java消息服务应用程序接口  api</p>
<p>15672  5672   25672  集群</p>
<p>生产者</p>
<p>创建连接工厂   ConnectionFactory<br>设置参数<br>创建连接 Connection<br>创建Channel<br>创建队列   queueDeclare<br>发送消息    basicPublish   exchange  简单模式交换机默认<br>routingkey  路由名称<br>props  配置信息<br>body  发送消息数据   字节数组</p>
<p>释放资源<br>channel.close()<br>connection.close()</p>
<p>消费者     监听队列<br>Consumer           DefaultConsumer          收到消息自动执行方法<br>basicConsume        callback回调对象</p>
<p>不关闭资源</p>
<p>工作模式   6种<br>简单      一个生产者一个消费者<br>工作队列     多个消费者竞争   任务较多     提高任务处理速度</p>
<p>发布订阅    一个消息可被多个消费者消费<br>exchange常见3种    只负责转发  不负责存储<br>fanout  广播   扇形   发送消息到每一个队列<br>direct 定向      routing key   路由key<br>topics 通配符    路由模式      *一个单词     #0或多个<br>headers    参数匹配 </p>
<p>创建交换机   exchangeDeclare</p>
<p>绑定队列和交换机<br>channel.queueBind()</p>
<p>Routing<br>Topics 表达式形式 *恰好1个单词    #0个或多个单词<br>RPC</p>
<p>springboot与rabbitmq整合  依赖  yml文件  ip  端口   username  password<br>写配置类   交换机   队列    队列和交换机绑定关系 Binding<br>ExchangeBuilder    QueueBuilder     BindingBuilder<br>bind()   to()  with()<br>无参数 noargs()<br>有参数  and()<br>生产者    RabbitTemplate<br>convertAndSend()</p>
<p>消费者<br>定义监听类    监听队列   @RabbitListener注解</p>
<p>高级特性<br>消息可靠投递<br>confirm   确认模式<br>开启   setConfirmCallBack</p>
<p>return    退回模式<br>Consumer Ack</p>
<p>消费端限流</p>
<p>TTL    消息设置过期时间</p>
<p>死信队列     过期消息再利用<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215001530502.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215002016026.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215001833578.jpg" alt><br>延迟队列<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215002814702.jpg" alt></p>
<p>日志与监控</p>
<p>消息追踪<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215003003367.jpg" alt></p>
<p>应用问题</p>
<p>消息可靠性保障<br>消息补偿<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215003635892.jpg" alt></p>
<p>消息幂等性<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215004033802.jpg" alt><br>乐观锁<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211215004244719.jpg" alt></p>
<p>集群搭建<br>镜像队列</p>
<p>haproxy</p>
<p>采用 RabbitMQ 实战异步写日志与异步发邮件    rabbitmq异步评论通知</p>
<p>场景一：异步记录用户操作日志</p>
<p>消息模型：DirectExchange+RoutingKey 消息模型<br>消息：用户登录的实体信息，包括用户名，登录事件，来源的IP，所属日志模块等信息<br>发送接收：在登录的 Controller 中实现发送，在某个 listener 中实现接收并将监听消费到的消息入数据表；实时发送接收</p>
<p>编译插件有什么用<br>@Qualifier</p>
<p>死信交换机</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty学习]]></title>
      <url>/p/81dqk/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>NioEventLoopGroup   DefaultEventLoopGroup</p>
<p>服务器端<br>Chnnel 连接数据通道<br>ServerBootStrap 启动器 负责组装netty组件 启动服务器<br>bosseventloop  可连接事件<br>   workereventloop()    可读事件<br>   selecter监听io事件 +线程</p>
<p>   ServerSocketChannel实现</p>
<p>   childHandler 决定worker能执行哪些操作<br>   添加其他Handler    连接建立后执行</p>
<p>   StringDecoder  ByteBuf转换为字符串<br>   自定义Handler   ChannelInboundHandlerAdapter</p>
<p>   bind() 端口</p>
<p>   accept事件<br>   read事件<br>客户端：<br>StringEncoder   字符串编码为ByteBuf</p>
<p>connect()<br>.sync()   阻塞方法直到连接建立<br>.channel()   代表连接对象<br>.writeAndFlush()   发送数据</p>
<p>经过pipeline加工  流水线</p>
<p>handler处理工序   inbound   outbound  入站 出站</p>
<p>pipeline发布事件传播给handler</p>
<p>事件循环对象<br>eventloop处理数据的工人      （io时 工人和channel有绑定为了线程安全）   可执行io操作也可进行任务处理 每个工人有任务队列<br>普通任务  定时任务   底层单线程线程池<br>继承ScheduledExecutorService     OrderedEventExecutor</p>
<p>按照pipeline顺序 按照handler规划处理数据</p>
<p>事件循环组   register方法<br>创建事件循环组   获取下一个事件循环对象   执行普通任务    异步处理<br> 定时任务  scheduleAtFixedRate  延时  分隔时间<br> <img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220112131421341.jpg" alt><br> 处理io事件<br>boss  只负责 serversocketchannel accept事件<br> worker只负责 socketchannel 读写<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220112135510494.jpg" alt><br> ctx.fireChannelRead()  让消息传递给下一个handler</p>
<p>eventloop切换线程（handler执行过程中换人）</p>
<p>ChannelFuture对象    sync() 同步处理结果  阻塞住当前线程  直到nio线程连接建立完毕<br>addListener （回调对象）    异步处理结果     ChannelFutureListener</p>
<p>connect方法  异步非阻塞  main发起调用  真正执行connect是nio线程</p>
<p>channel.close()   异步操作            关闭之后的操作<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220112141051586.jpg" alt><br>获取ClosedFuture对象    channel.closeFuture()   同步处理关闭  sync()<br>异步处理关闭    ChannelFutureListener</p>
<p>多线程   异步   响应时间增加  吞吐量提高  单位时间内处理请求速度<br>合理任务拆分</p>
<p>Netty  Future接口继承 jdk中Future    </p>
<p>Promise继承    Netty  Future接口</p>
<p>jdk中Future 同步等待任务结束    cancel 取消  isDone  任务是否完成，不区分是否失败    get获取任务结果，阻塞等待<br>Netty  Future    同步  异步   都要等任务结束    await不抛异常   isSuccess判断任务是否成功     sync抛异常<br>Promise    脱离任务独立存在    作为线程间传递结果的容器   setSuccess   setFailure </p>
<p>Future  Promise  和异步方法配套使用  用来处理结果</p>
<p>DefaultPromise   主动创建promise  结果容器</p>
<p>handler处理channel上的事件<br>入站处理器   channelinboundhandlerAdapter子类  读取客户端数据 写回结果<br>出站处理器   channeloutboundhandlerAdapter子类   对写回结果进行加工     从tail逆序<br>pipeline.addLast()       head   tail    双向链表</p>
<p>eventloopgroup  shutdownGracefully</p>
<p>embedded-channel   用来测试的channel</p>
<p>bytebuf创建   对字节数据的封装 ByteBufAllocator.DEFAULT.buffer()   容量可动态变化</p>
<p>writeBytes()   getBytes()<br>直接内存   读写效率高   directBuffer  适合配合池化   Netty默认直接内存<br>堆内存   分配效率高   heapBuffer</p>
<p>池化     重用ByteBuf  内存分配算法提升分配效率<br>非池化<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220112145839169.jpg" alt></p>
<p>组成<br>容量  最大容量    最开始读写指针都在0位置<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220112150912508.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220112151206445.jpg" alt><br>写入<br>网络编程   大端 writeInt()（先写高位  再写低位 网络编程一般大端）   小端   writeIntLE()<br>CharSequence</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220112151437892.jpg" alt><br>读取    readByte()   1次读取1个字节<br>读取int整数5   先标记    markReaderIndex()<br>重复读取  reset</p>
<p>内存释放   retain +1 release  -1<br>unpooledheapbytebuf   jvm内存   GC回收<br>unpooledDirectbytebuf   需特殊方法回收内存<br>pooledbytebuf  更复杂规则回收</p>
<p>引用计数   ByteBuf实现ReferenceCounted接口   计数为0内存回收</p>
<p>谁是最后使用者  谁负责release</p>
<p>头尾释放源码</p>
<p>slice  零拷贝体现之一    减少数据复制   切片   单独读写指针   setByte()</p>
<p>duplicate   零拷贝体现之一   截取原始ByteBuf所有内容    单独读写指针</p>
<p>copy  深拷贝</p>
<p>channelActive 连接建立成功后触发</p>
<p>双向通信   java socket全双工  读线程  写线程</p>
<p>粘包半包   服务器接收缓冲区小  半包   确认应答  滑动窗口<br>Nagle算法   会造成粘包         接收方ByteBuf设置过大</p>
<p>MSS限制   超过切片   半包    MTU</p>
<p>TCP流式协议，消息无边界</p>
<p>解决   短连接    childOption 调整netty缓冲区（ByteBuf）   效率低 能解决粘包  不能解决半包</p>
<p>固定长度解码器    空间浪费</p>
<p>分隔符确定边界   LineBasedFrameDecoder    \n   \r\n    换行符   设定最大长度   行解码器      效率比较低<br>DelimiterBased</p>
<p>LTC解码器   LengthFieldFrameDecoder   告诉内容有多长    回车13  换行10  消息不够紧凑</p>
<p>协议设计与解析  redis协议  http协议</p>
<p>netty提供了协议   HttpServerCodec()  编解码器结合  请求解码  响应编码   HttpRequest   HttpContent   SimpleChannelInboundHandler<br>DefaultFullHttpResponse</p>
<p>自定义协议<br>魔数 第一时间判断是否是有效数据包<br>版本号   支持协议升级<br>序列化算法   消息正文  json  protobuf  hession   jdk<br>指令类型<br>请求序号  双工通信  提供异步能力<br>正文长度</p>
<p>netty进阶</p>
<p>netty优化   扩展序列化算法</p>
<p>高性能序列化协议protobuf</p>
<p>Netty心跳机制</p>
<p>直接内存与Netty零拷贝</p>
<p>Socket与文件描述符</p>
<p>Socket与Tcp协议、Http协议的关系</p>
<p>Netty之Http协议开发</p>
<p>Netty之WebSocket协议开发</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图床设置]]></title>
      <url>/p/81aed/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>解决github进不去问题<br>有一种非常有效的办法。在知乎看到的 地址 把Widow10系统设置自动代理服务器的功能关闭后可以顺利打开。关闭过程如下：</p>
<p>win+r，输入inetcpl.cpl命令，点击确认，打开“internel 属性”面板，选择【连接】菜单，点击【局域网设置】后，将“为LAN使用代理服务器”前面的勾去掉，若 【自动检测设置】已勾选则取消勾选，若【自动检测设置】未勾选则将其勾选，然后点击确定，然后在internet 属性界面点击确定即可。</p>
<p>打开Google chrome浏览器的设置页面，选择【高级】，然后在系统界面把计算机代理关闭，之后就可以愉快的上github了。</p>
<p><a href="https://www.jianshu.com/p/9d91355e8418" target="_blank" rel="noopener">https://www.jianshu.com/p/9d91355e8418</a><br>Typora+PicGo+Gitee<br><a href="https://www.jianshu.com/p/1152941beaa7" target="_blank" rel="noopener">https://www.jianshu.com/p/1152941beaa7</a><br>picGo</p>
<p>vscode 配置插件 PicGo</p>
<p>尝试自己写图床    参考<a href="https://blog.csdn.net/lwq1998l/article/details/117611564" target="_blank" rel="noopener">https://blog.csdn.net/lwq1998l/article/details/117611564</a><br>截图保存图片上传到gitee获取链接</p>
<p>gitee图片链接示例<br><a href="https://gitee.com/mosheng123456789/pics/raw/master/img/20211126005428.png" target="_blank" rel="noopener">https://gitee.com/mosheng123456789/pics/raw/master/img/20211126005428.png</a></p>
<p>gitee搭建个人博客<br><a href="https://blog.csdn.net/qq_42477843/article/details/107165026" target="_blank" rel="noopener">https://blog.csdn.net/qq_42477843/article/details/107165026</a></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/202111251635897.png" alt></p>
<p>pyautogui学习<br><a href="https://blog.csdn.net/qq_43017750/article/details/90575240" target="_blank" rel="noopener">https://blog.csdn.net/qq_43017750/article/details/90575240</a></p>
<p>将python py文件打包成exe可执行文件<br>pyinstaller -F package-test.py</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/20211126005428.png" alt></p>
<p>python设置开机自动启动 .py文件<br>创建python_auto.bat的快捷方式，放入启动项：<br>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p>
<p>python_auto.bat编辑内容为运行脚本的语句，例如：python a.py</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springsecurity学习]]></title>
      <url>/p/819sf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>spring全家桶一员  集成方便<br>安全框架    充分利用spring ioc  aop  配置使用比shiro更重  功能更强<br>Oauth2 第三方登录的协议<br>sso 单点登录<br>jwt<br>springsecurityOauth2</p>
<p>redis存储token</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[抓包学习]]></title>
      <url>/p/81963/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>抓https包设置<br><a href="https://blog.csdn.net/lystest/article/details/100118389" target="_blank" rel="noopener">https://blog.csdn.net/lystest/article/details/100118389</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git学习]]></title>
      <url>/p/8181v/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>BitKeeper<br>svn  单点故障 容错性差<br>本地版本库                                                      stage<br>远程仓库   本地仓库(clone  push)  工作区（pull  add）  暂存区(commit)<br>tortoiseGit<br>工作目录</p>
<p>commit  日志<br>分支<br>   origin  远端<br>删除并保留本地副本    忽略文件<br>ssh密钥  github配置公钥<br>创建版本库</p>
<p>推送 拉取  冲突（不是在最新基础上做的修改  都对同一文件修改）   解决冲突<br>搭建私有git服务器</p>
<p>分支管理<br>提交串成一条时间线  就是分支   HEAD指针指向当前分支<br>创建分支   切换分支<br>在idea中配置git</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[floyd算法]]></title>
      <url>/p/817kv/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A    path初始-1</p>
<p>B-F关注边   松弛操作   对每条边做松弛操作   进行节点数-1次   每次至少确定一个最优值   节点数-1次后没有负数权不需要松弛操作了</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery学习]]></title>
      <url>/p/814x7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> CDN（内容分发网络）<br>jQuery 的功能概括</p>
<p>1、html 的元素选取</p>
<p>2、html的元素操作</p>
<p>3、html dom遍历和修改</p>
<p>4、js特效和动画效果</p>
<p>5、css操作</p>
<p>6、html事件操作</p>
<p>7、ajax异步请求方式</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux学习]]></title>
      <url>/p/811a3/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编译驱动程序</p>
<p>显卡 x window cpu</p>
<p>如果内存不够大， 就会使用到硬盘的内存交换空间（swap）</p>
<p>磁盘阵列（RAID）是利用硬件技术将数个硬盘整合成为一个大硬盘的方法，操作系统只会看到最后被整合起来的大硬盘  备份</p>
<p>在Linux系统中，每个设备都被当成一个文件来对待</p>
<p>SATA接口的硬盘的文件名称即为/dev/sd[a-d]<br>打印机   软盘 分别是/dev/lp0, /dev/fd0<br>Linux核心侦测到磁盘的顺序<br>磁盘的组成主要有盘片、机械手臂、磁头与主轴马达所组成， 而数据 的写入其实是在盘片上面</p>
<p>盘片上面又可细分出扇区（Sector）与磁道（Track）两种单位， 其中扇区的物理量设计有两种大小，分别是 512Bytes 与 4KBytes<br>第一个扇区  MBR （Master Boot Record） 格式   主要开机记录区     安装开机管理程序（446）   分区表（64）<br>GPT （GUID partition table）<br>柱面   </p>
<p>延伸分区的目的是使用额外的扇区来记录分区信息，延伸分区本身并不能被 拿来格式化。 然后我们可以通过延伸分区所指向的那个区块继续作分区的记录</p>
<p>主要分区与延伸分区最多可以有四笔<br>延伸分区最多只能有一个<br>逻辑分区是由延伸分区持续切割出来的分区</p>
<p>GPT  逻辑区块位址 LBA0   GPT 使用了 34 个 LBA 区块来纪录分区 信息<br>GPT 除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份</p>
<p>开机管理程序 grub</p>
<p>开机检测程序  BIOS UEFI<br>开机管理程序的目的是在载入（load）核心文件<br>挂载点<br>—help<br>man   info<br>编辑器  nano<br>关机 shutdown   -h 关机  -r 重启     reboot<br>init 0关机   init 6重启<br>echo $LANG  语系 locale</p>
<h1 id="代表以-root-的身份登陆系统，而-则代表一般身份使用者"><a href="#代表以-root-的身份登陆系统，而-则代表一般身份使用者" class="headerlink" title="代表以 root 的身份登陆系统，而 $ 则代表一般身份使用者"></a>代表以 root 的身份登陆系统，而 $ 则代表一般身份使用者</h1><p>GNOME/KDE</p>
<p>i-node  属性记录的有多少 不同的文件名链接到相同的一个i-node号码</p>
<p>u g o a  + - =</p>
<p>区块（block）设备文件    储存数据， 以提供系统随机存取的周边设备，举 例来说，硬盘与软盘等就是啦<br>字符（character）设备文件  键盘、鼠标 一次性读取”的，不能够截断输出</p>
<p>第5章 linux目录配置<br>寻找文件和指令</p>
<p>basename  dirname<br>cat -n -v  -A</p>
<p>g前进到第一行  G前进到最后一行<br>chattr   设置文件隐藏属性<br>lsattr</p>
<p>文件特殊权限    SUID SGID SBIT<br>file 文件类型<br>which （寻找“可执行文件”）   type （bash shell）   命令<br>whereis 或者是 locate 来检查</p>
<p>第7章 inode  block<br>命令别名设置功能： （alias）<br>管线  数据流重定向<br>环境变量例如 PATH、HOME、MAIL、SHELL,HOSTNAME,USER<br>export 变量变为环境变量<br>PS1 提示字符<br>read  declare<br>变量内容删除</p>
<p>bash环境配置文件<br>/etc/profile   ~/.bash_profile<br>source 或者.  读入配置文件<br>&amp;   工作控制 （job control）：将指令变成背景下工作</p>
<blockquote>
<p> 取代   &gt;&gt;累加<br>/dev/null 垃圾桶黑洞设备与特殊写法<br>2&gt;&amp;1    1&gt;&amp;2</p>
</blockquote>
<p>cut 处理多空格相连数据吃力    选行中的段<br>cut -d 分割字符  -f</p>
<p>grep   选行  -n<br>-i  忽略大小写<br>-v 反向选择</p>
<p>sort  r  f u          sort -t   -k (和cut类似)</p>
<p>uniq  -c 计数  -i  忽略大小写</p>
<p>wc -l ：仅列出行； -w ：仅列出多少字（英文单字）； -m ：多少字符；</p>
<p>双向重导向  tee<br>字符转换命令 tr,col,join,paste,expand<br>split  大文件分为小文件</p>
<p>xargs  x 是加减乘除的乘号，args 则是 arguments （参数） 的意思<br>xargs -n 1<br>—color=auto<br>行首 ^  行尾 $<br>只有行首跟行尾 （^$）  空白行<br>.*<br>{}<br>第11章 正则表达式<br>sed本身也是管线命令    取代、删除、新增、撷取特定行<br>-n ：使用安静（silent）模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。 但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行（或者动作）才会被列出来。 -e ：直接在命令行界面上进行 sed 的动作编辑； -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作； -r ：sed 的动作支持的是延伸型正则表达式的语法。（默认是基础正则表达式语法） -i ：直接修改读取的文件内容，而不是由屏幕输出。</p>
<p>sed ‘s/要被取代的字串/新的字串/g’<br>sed -i<br>awk</p>
<p>awk ‘条件类型1{动作1} 条件类型2{动作2} …’ filename<br>$1    $0代表一整列数据</p>
<p>NF 每一行 （$0） 拥有的字段总数<br>NR 目前 awk 所处理的是“第几行”数据<br>FS 目前的分隔字符，默认是空白键</p>
<p>BEGIN    END</p>
<p>磁盘与文件系统<br>ext2  block群组</p>
<blockquote>
<p>压缩 打包<br>进程管理</p>
</blockquote>
<p>select  poll epoll</p>
<blockquote>
<p>I/O</p>
</blockquote>
<h2 id="压缩和打包"><a href="#压缩和打包" class="headerlink" title="压缩和打包"></a>压缩和打包</h2><p>网络传输也用压缩，加快传输速度</p>
<p><em>.Z compress 程序压缩的文件；
</em>.zip zip 程序压缩的文件；<br><em>.gz gzip 程序压缩的文件； 
</em>.bz2 bzip2 程序压缩的文件；<br><em>.xz xz 程序压缩的文件； 
</em>.tar tar 程序打包的数据，并没有压缩过；<br><em>.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 
</em>.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩<br>*.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩<br>这些指令通常仅能针对一个文件来压缩与解压缩，如此一来， 每 次压缩与解压缩都要一大堆文件，岂不烦人？此时，那个所谓的“打包软件, tar”就显的很重要 啦、</p>
<p>目前 gzip 可以解开 compress, zip 与 gzip 等软件所 压缩的文件</p>
<p>选项与参数：<br> -c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；<br> -d ：解压缩的参数；<br> -t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；<br> -v ：可以显示出原文件/压缩文件的压缩比等信息；<br> -# ：# 为数字的意思，代表压缩等级，<br> -1 最快，但是压缩比最差、<br> -9 最慢，但是压缩比最好！<br> 默认是 -6</p>
<p> 如果你还想要从文字压缩文件当中找数据的话，可以通过 egrep 来搜寻关键字喔！而 不需要将压缩文件解开才以 grep 进行！ 这对查询备份中的文本文件数据相当有用</p>
<p> bzip2, bzcat/bzmore/bzless/bzgrep<br> 若说 gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代 gzip 并提供更佳的压缩比而来的</p>
<p> 选项与参数：<br> -c ：将压缩的过程产生的数据输出到屏幕上！<br> -d ：解压缩的参数<br> -k ：保留原始文件，而不会删除原始的文件喔！<br> -z ：压缩的参数 （默认值，可以不加）<br> -v ：可以显示出原文件/压缩文件的压缩比等信息；<br> -# ：与 gzip 同样的，都是在计算压缩比的参数，<br> -9 最佳， -1 最快！</p>
<p> xz, xzcat/xzmore/xzless/xzgrep<br> xz 这个压缩比更高<br> 选项与参数：<br> -d ：就是解压缩啊！<br> -t ：测试压缩文件的完整性，看有没有错误<br> -l ：列出压缩文件的相关信息<br> -k ：保留原本的文件不删除～<br> -c ：同样的，就是将数据由屏幕上输出的意思！<br> -# ：同样的，也有较佳的压缩比的意思！</p>
<p> 选项与参数：<br> -c ：创建打包文件，可搭配<br> -v 来察看过程中被打包的文件名（filename）<br>-t ：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；<br>-x ：解打包或解压缩的功能，可以搭配<br>-C （大写） 在特定目录解开 特别留意的是，<br>-c, -t, -x 不可同时出现在一串命令行中。<br>-z ：通过 gzip 的支持进行压缩/解压缩：此时文件名最好为 <em>.tar.gz<br>-j ：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 </em>.tar.bz2<br>-J ：通过 xz 的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串命令行中<br>-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！<br>-f filename：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）<br>-C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。<br> 其他后续练习会使用到的选项介绍：<br> -p（小写） ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件<br> -P（大写） ：保留绝对路径，亦即允许备份数据中含有根目录存在之意； —exclude=FILE：在压缩的过程中，不要将 FILE 打包！<br> <img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211209230213649.jpg" alt><br> dd 可备份完整的 partition 或 disk ，因为 dd 可读取磁盘的 sector 表面数据 cpio 为相当优秀的备份指令，不过必须要搭配类似 find 指令来读入欲备份的文件名数 据，方可进行备份动作。</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p> shell script 有点像是早期的批处理文件</p>
<p>/etc/init.d/* 这个脚本启动的方式 （systemV） 已经被新一代的 systemd 所取 代 （从 CentOS 7 开始）</p>
<ul>
<li>自动化管理的重要依据</li>
<li>追踪与管理系统的重要工作</li>
</ul>
<p>防火墙连续规则 （iptables），开机载入程序的项目 （就是在 /etc/rc.d/rc.local 里头的数据）<br>用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上， 就不够好</p>
<p>shell.sh 文件必须要具备可读与可执行 （rx） 的权限<br>将 shell.sh 放在 PATH 指定的目录内</p>
<p>PATH 与 LANG （如果有使用到输出相关的信息时） 是当中最重要的</p>
<p>程序码</p>
<p>使用 vim 而不是 vi ，因为 vim 会有额外的 语法检验机制</p>
<p>利用 test 指令的测试功能</p>
<p>在中括号 [] 内的每个元件都需要有空白键来分隔； 在中括号内的变量，最好都以双引号括号起来； 在中括号内的常数，最好都以单或双引号括号起来。</p>
<p>如果你想要重新 启动系统的网络，可以这样做：<br>/etc/init.d/network restart</p>
<p>$*<br>$#<br>$@</p>
<p>条件判断式  if  then</p>
<p>if [ 条件判断式 ]; then<br>   当条件判断式成立时，可以进行的指令工作内容；<br>else<br>    当条件判断式不成立时，可以进行的指令工作内容；<br>fi</p>
<p>if [ 条件判断式一 ]; then<br>   当条件判断式一成立时，可以进行的指令工作内容；<br>elif [ 条件判断式二 ]; then<br>   当条件判断式二成立时，可以进行的指令工作内容；<br>else<br>    当条件判断式一与二均不成立时，可以进行的指令工作内容；<br>fi</p>
<p>netstat 的指令，这个 指令可以查询到目前主机有打开的网络服务端口 （service ports）</p>
<p>80: WWW 22: ssh 21: ftp 25: mail 111: RPC（远端程序调用） 631: CUPS（打印服务功能）</p>
<p>case ${1} in “hello”）<br> echo “Hello, how are you ?”<br> ;;<br> “”）<br> echo “You MUST input parameters, ex&gt; {${0} someword}”<br>  ;;<br>  *） # 其实就相当于万用字符，0~无穷多个任意字符之意！<br>  echo “Usage ${0} {hello}”<br>  ;;<br>esac</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>while do done, until do done （不定循环）</p>
<p>while [ condition ] &lt;==中括号内的状态就是判断式<br>do         &lt;==do 是循环的开始！<br>   程序段落 done &lt;==<br>done 是循环的结束 </p>
<p>while 的中文是“当….时”，所以，这种方式说的是“当 condition 条件成立时，就进行循环，直 到 condition 的条件不成立才停止”的意思。还有另外一种不定循环的方式： </p>
<p>until [ condition ]<br>do<br>程序段落<br> done<br>这种方式恰恰与 while 相反，它说的是“当 condition 条件成立时，就终止循环， 否则就持续 进行循环的程序段</p>
<p>for var in con1 con2 con3 …<br>do<br>  程序段<br>done</p>
<p>for （（ i=1; i&lt;=${nu}; i=i+1 ））<br> do<br>    s=$（（${s}+${i}））<br> done</p>
<h2 id="例行性工作调度（crontab）"><a href="#例行性工作调度（crontab）" class="headerlink" title="例行性工作调度（crontab）"></a>例行性工作调度（crontab）</h2><p> Linux 工作调度的种类： at, cron<br>at ：at 是个可以处理仅执行一次就结束调度的指令，不过要执行 at 时， 必须要有 atd 这个服务的支持才行</p>
<p>crontab ：crontab 这个指令所设置的工作将会循环的一直进行下去！ 可循环的时间为分 钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。 至于让 crontab 可以生效的服务则是 crond 这个服务喔！</p>
<p>一只程序“ logwatch ”来主动分析登录信息</p>
<p>利用 /etc/at.allow 与 /etc/at.deny 这两个文件来进行 at 的使用限制</p>
<p>系统的配置文件： /etc/crontab, /etc/cron.d/*</p>
<p>anacron</p>
<p>nohup</p>
<h2 id="程序管理与SELinux"><a href="#程序管理与SELinux" class="headerlink" title="程序管理与SELinux"></a>程序管理与SELinux</h2><p>fork and exec：程序调用的流程</p>
<p>程序都会借由父程序以复制 （fork） 的方式产生一个一模一样的子程序， 然后被复制出来的子程序再以 exec 的方式来执行实际 要进行的程序，最终就成为一个子程序的存在</p>
<p>PPID</p>
<p>系统或网络服务：常驻在内存的程序</p>
<p>多重登陆环境的七个基本终端窗口<br>六个文字界面登陆窗口，以及一个图形界面</p>
<p>再按 [Alt]+[F1]…..[F7] 来 切换到其他的终端机界面，然后以 ps -aux 找出刚刚的错误程序，然后给他 kill 一下</p>
<p>工作管理<br>前景：你可以控制与下达指令的这个环境称为前景的工作 （foreground）；<br>背景：可以自行运行的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 调用该工作</p>
<p>观察目前的背景工作状态： jobs</p>
<p>将背景工作拿到前景来处理：fg</p>
<p>让工作在背景下的状态变成运行中： bg</p>
<p>如果你想要让在背景的工作在你登出后还能够继续的执行，使用 nohup 搭配 &amp; 是不错的</p>
<p>静态的 ps 或者是动态的 top，还能以 pstree 来查阅程序树之间的关系静 态的 ps 或者是动态的 top，还能以 pstree 来查阅程序树之间的关系</p>
<p>观察系统所有程序： ps aux<br>仅观察自己的 bash 相关程序： ps -l</p>
<p>选项与参数：<br> -d ：后面可以接秒数，就是整个程序画面更新的秒数。默认是 5 秒； -b ：以批次的方式执行 top ，还有更多的参数可以使用喔！ 通常会搭配数据流重导向来将批次的结果输出成为文件。<br> -n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。<br>  -p ：指定某些个 PID 来进行观察监测而已。<br>   在 top 执行过程当中可以使用的按键指令：<br>  ? ：显示在 top 当中可以输入的按键指令；<br>  P ：以 CPU 的使用资源排序显示；<br>  M ：以 Memory 的使用资源排序显示；<br>   N ：以 PID 来排序喔！<br>   T ：由该 Process 使用的 CPU 时间累积 （TIME+） 排序。<br>   k ：给予某个 PID 一个讯号 （signal）<br>    r ：给予某个 PID 重新制订一个 nice 值。<br>    q ：离开 top 软件的按键。</p>
<p>程序管理</p>
<p>系统资源的观察<br>free ：观察内存使用情况<br>uname：查阅系统与核心相关信息<br>uptime：观察系统启动时间与工作负载<br>netstat ：追踪网络或插槽档<br>dmesg ：分析核心产生的讯息<br>vmstat ：侦测系统资源变化</p>
<p>特殊文件与程序<br>查询已打开文件或已执行程序打开之文件</p>
<p>lsof ：列出被程序所打开的文件文件名</p>
<p>pidof ：找出某支正在执行的程序的 PID</p>
<p>SELinux   安全强化的 Linux</p>
<h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><p>Unix 的 system V 版本<br>基本上 init 的管理机制有几个特色<br>使用 bash shell script 所写成的脚本程序，需要启动、关闭、重新启动、观察状 态时， 可以通过如下的方式来处理：<br>启动：/etc/init.d/daemon start<br>关闭：/etc/init.d/daemon stop<br>重新启动：/etc/init.d/daemon restart<br>状态观察：/etc/init.d/daemon status</p>
<p>systemd<br>从 CentOS 7.x 以后，Red Hat 系列的 distribution 放弃沿用多年的 System V 开机启动服务的 流程，就是前一小节提到的 init 启动脚本的方法， 改用 systemd 这个启动服务管理机制</p>
<p>平行处理所有服务，加速开机流程： 旧的 init 启动脚本是“一项一项任务依序启动”的模 式，因此不相依的服务也是得要一个一个的等待<br>系统启动的速度变快</p>
<p>一经要求就回应的 on-demand 启动方式： systemd 全部就是仅有一只 systemd 服务搭 配 systemctl 指令来处理，无须其他额外的指令来支持</p>
<p>首先 systemd 先定义所有的服务为一个服务单位 （unit），并将该 unit 归类到不同的服务类型 （type） 去</p>
<p>向下相容旧有的 init 服务脚本</p>
<p>systemd 的配置文件放置目录</p>
<p>通过 systemctl 管理服务</p>
<p>systemctl [command] [unit]<br>command 主要有：<br>start ：立刻启动后面接的 unit<br>stop ：立刻关闭后面接的 unit<br>restart ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思<br> reload ：不关闭后面接的 unit 的情况下，重新载入配置文件，让设置生效<br> enable ：设置下次开机时，后面接的 unit 会被启动<br> disable ：设置下次开机时，后面接的 unit 不会被启动<br> status ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机默认执行否、登录等信息等！<br> is-active ：目前有没有正在运行中 is-enable ：开机时有没有默认要启用这个 unit</p>
<p>/etc    /usr/lib</p>
<h2 id="登录文件"><a href="#登录文件" class="headerlink" title="登录文件"></a>登录文件</h2><p> 记录系统活动信息的几个文件， 例如：何时、何地 （来源 IP）、何人 （什么服务名称）、做了什么动作 （讯息登录啰）。 换句话说就是：记 录系统在什么时候由哪个程序做了什么样的行为时，发生了何种的事件等等<br> /var/log/</p>
<p> systemd-journald.service：最主要的讯息收受者，由 systemd 提供的；<br> rsyslog.service：主要登录系统与网络等服务的讯息；<br> logrotate：主要在进行登录文件的轮替功能。</p>
<h2 id="开机流程，模块管理-loader"><a href="#开机流程，模块管理-loader" class="headerlink" title="开机流程，模块管理 loader"></a>开机流程，模块管理 loader</h2><p>按下电源按键后计算机硬件会主动的读取 BIOS 或 UEFI BIOS 来载入硬件信息及 进行硬件系统的自我测试， 之后系统会主动的去读取第一个可开机的设备 （由 BIOS 设置 的） ，此时就可以读入开机管理程序</p>
<p>开机管理程序可以指定使用哪个核心文件来开机，并实际载入核心到内存当中解压缩与执行， 此时核心就能够开始在内存内活动，并侦测所有硬件信息与载入适当的驱动程序来使整 部主机开始运行， 等到核心侦测硬件与载入驱动程序完毕后，一个最阳春的操作系统就开始 在你的 PC 上面跑了。</p>
<p>主机系统开始运行后，此时 Linux 才会调用外部程序开始准备软件执行的环境，并且实际的 载入所有系统运行所需要的软件程序哩！ 最后系统就会开始等待你的登陆与操作啦</p>
<p>核心： /boot/vmlinuz 或 /boot/vmlinuz-version；<br>核心解压缩所需 RAM Disk： /boot/initramfs （/boot/initramfs-version）；<br>核心模块： /lib/modules/version/kernel 或 /lib/modules/$（uname -r）/kernel；<br>核心源代码： /usr/src/linux 或 /usr/src/kernels/ （要安装才会有，默认不安装）</p>
<p>核心版本： /proc/version<br>系统核心功能： /proc/sys/kernel/</p>
<p>如果我有个新的硬件，偏偏我的操作系统不支持，该怎么办<br>重新编译核心，并加入最新的硬件驱动程序源代码；<br>将该硬件的驱动程序编译成为模块，在开机时载入该模块</p>
<p>核心模块与相依性</p>
<p>lsmod<br>模块名称（Module）；<br>模块的大小（size）；<br> 此模块是否被其他模块所使用 （Used by）</p>
<p> modinfo</p>
<p> 核心模块的载入与移除<br>insmod 则完全由使用者自行载入一个完整文件名的模块<br>rmmod</p>
<p>使用 insmod 与 rmmod 的问题就是，你必须要自行找到模块的完整文件名才行</p>
<p>核心模块的额外参数设置：/etc/modprobe.d/*conf</p>
<p>第一支程序 systemd 及使用 default.target 进入开机程 序分析</p>
<p>grub2<br>boot loader 的两个 stage<br>Stage 1：执行 boot loader 主程序：<br>Stage 2：主程序载入配置文件：</p>
<p>配置文件是放在哪里啊？这些与 grub2 有关的文件都放置到 /boot/grub2 中</p>
<p>grub2 的配置文件 /boot/grub2/grub.cfg 初探</p>
<p>grub2 配置文件维护 /etc/default/grub 与 /etc/grub.d</p>
<p>忘记root密码<br>文件系统错误无法开机</p>
<h2 id="x-window设置介绍"><a href="#x-window设置介绍" class="headerlink" title="x window设置介绍"></a>x window设置介绍</h2><h2 id="linux核心编译与管理"><a href="#linux核心编译与管理" class="headerlink" title="linux核心编译与管理"></a>linux核心编译与管理</h2><p>系统移植<br>编译前的任务：认识核心与取得核心源代码</p>
<p>这个核心文件通常被放置成 /boot/vmlinuz-xxx ，不过也不见得， 因为一部主机上面可以拥有 多个核心文件，只是开机的时候仅能选择一个来载入而已</p>
<p>自制核心 - 核心编译</p>
<p>关于驱动程序 - 是厂商的责任还是核心的责任</p>
<p>核心的编译重点在于“你要你的 Linux 作什么</p>
<p>核心的版本</p>
<p>核心源代码的解压缩/安装/观察</p>
<p>核心的编译与安装</p>
<p>开始安装新核心与多重核心菜单 （grub）</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot学习]]></title>
      <url>/p/810fg/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113095408385.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113100240611.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113100425175.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113101458509.jpg" alt></p>
<p>数组</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113101716195.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113101835865.jpg" alt></p>
<p>Environment env<br>env.getProperty(“”)</p>
<p>@Configuration(prefix=””)</p>
<p>开发 测试  生产<br>profile动态配置切换<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113103255897.jpg" alt><br>spring.profiles.active=dev</p>
<p>内部配置顺序<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113103943833.jpg" alt><br>外部配置顺序（命令行参数等）</p>
<p>EnableAutoConfigutation</p>
<p>@Conditional()  括号里加实现Condition接口的类matches方法</p>
<p>自定义注解<br>context metadata<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113113313816.jpg" alt><br>@ComponentScan<br>@Import注解导入配置类<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113115930538.jpg" alt></p>
<p>META-INF/spring.factories<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113120753512.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220113122225328.jpg" alt><br>4个核心<br>起步依赖     依赖传递<br>自动配置  利用了Spring 4的条件化配置特性，以及Maven和Gradle提供的传递依赖解析，以此实现Spring应用程序上下文里的自动配置<br>Actuator   运行时检视应用程序内部情况的能力</p>
<p>@SpringBootApplication   开启组件扫描和自动配置</p>
<p>springboot插件    构建插件的主要功能是把项目打包成一个可执行的超级JAR（uber-JAR）包括把应用程序的<br>所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行<br>应用程序</p>
<p>spring-boot:run</p>
<p>起步依赖本身的版本是由正在使用的Spring Boot的版本来决定<br>的，而起步依赖则会决定它们引入的传递依赖的版本</p>
<p>在Maven里，可以用<exclusions>元素来排除传递依赖</exclusions></p>
<p>配置Thymeleaf的模板解析器、视图解析器以及模板引擎。</p>
<p>实现Condition接口，覆盖它<br>的matches()方法</p>
<p>自定义配置<br>两种影响自动配置的方式——使用显式配置进行覆盖和使用属性进行精细<br>化配置</p>
<p>默认情况下，Spring Boot会用Logback（<a href="http://logback.qos.ch）来记录日志，并用INFO级别输" target="_blank" rel="noopener">http://logback.qos.ch）来记录日志，并用INFO级别输</a><br>出到控制台</p>
<p>要设置日志级别，你可以创建以logging.level开头的属性</p>
<p>自定义错误页    名为error视图   为错误视图提供错误属性</p>
<p>图片放在src/main/resources/static或src/main/resources/public里</p>
<blockquote>
<p>测试   单元测试  集成测试   测试辅助工具</p>
</blockquote>
<p>Spring Mock MVC测试框架来测试Web应用程序</p>
<p>Actuator Web端点<br>REST端点、远程shell和JMX</p>
<dependency> 
 <groupid>org.springframework.boot</groupid> 
 <artifactid>spring-boot-starter-actuator</artifactid> 
</dependency>
端点可以分为三大类：配置端点、度量端点和其他端点     健康指示器
http://localhost:8080/beans
最重要的端点就是/beans。它会返回一个JSON文档，
描述上下文里每个Bean的情况，包括其Java类型以及注入的其他Bean

保护Actuator端点

连接 Actuator 的远程 shell
<dependency> 
 <groupid>org.springframework.boot</groupid> 
 <artifactid>spring-boot-starter-remote-shell</artifactid> 
</dependency>

<p>定制 Actuator</p>
<p>部署</p>
<p>把spring.profiles.active属性设置为production。</p>
<p>PaaS提供了现成的应用程序部署平台，带有附加服务（比如数据库和消息代理），<br>可以绑定到应用程序上</p>
<p>应用程序部署到Cloud Foundry和Heroku这两个著名的PaaS平台</p>
<p>事件<br>事件源<br>监听器</p>
<p>这2个需要配置（建立META-INF/spring.factories 设置键值对）<br>ApplicationContextInitializer<br>SpringApplicationRunListener<br>环境对象准备<br>上下文对象准备<br>上下文对象加载</p>
<p>项目启动后执行<br>CommandLineRunner<br>ApplicationRunner</p>
<p>默认info  health<br>需要配置才能暴露所有</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统]]></title>
      <url>/p/81096/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>磁盘调度的主要目标是使磁盘的平均寻道时间最少<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211230232508614.jpg" alt></p>
<p>缓冲区管理</p>
<p>死锁检测和解除   资源分配图<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211231010128041.jpg" alt></p>
<p>协程</p>
<p>覆盖（程序分为多个段  固定区（常驻内存）   覆盖区）  增加编程负担<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211231152748468.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220101231427119.jpg" alt></p>
<p>单缓冲区  双缓冲区  循环缓冲区队列 缓冲池</p>
<p>到达时间和运行时间  根据这两个计算等待时间，周转时间等<br>非抢占（在结束时调度 ） 抢占（到达时也调度）<br>先到先服务  短作业优先（抢占、非抢占）   最高响应比（等待时间+运行时间）/运行时间<br>时间片轮转(分时  时间片太大会退化为先到先服务  时间片太小切换开销大)  优先级  多级反馈队列（先到先服务  时间片  优先级   有可能饥饿）</p>
<p>驻留集  固定分配  可变分配   局部置换 全局置换<br>运行前调入： 预调页策略<br>运行时调入：请求调页策略<br>文件区  对换区</p>
<p>抖动现象（为进程分配物理块不够）<br>工作集（一段时间间隔实际访问页面的集合）<br>驻留集大小&gt;=工作集大小</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[主题配置]]></title>
      <url>/p/80y9d/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.zhihu.com/question/39388850?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/39388850?sort=created</a></p>
<p><a href="https://hexo.fluid-dev.com/docs/guide/#覆盖配置" target="_blank" rel="noopener">https://hexo.fluid-dev.com/docs/guide/#覆盖配置</a></p>
<p>自己设计主题</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[freenom解析域名]]></title>
      <url>/p/80y8x/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[慢查询优化]]></title>
      <url>/p/80x2c/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>table |  type | possible_keys | key |key_len  | ref | rows | Extra  EXPLAIN列的解释：   </p>
<ul>
<li>table   显示这一行的数据是关于哪张表的           </li>
<li>type    这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</li>
<li>ref    表里面的哪个索引被用到了</li>
<li>rows   显示需要扫描行数</li>
<li><p>key     使用的索引</p>
<p> const就是针对主键或者唯一性索引的等值查询，通过索引查找一次就行了。仅仅是查一条数据。</p>
<p> ref_eq 唯一性索引查询，一般使用一个表去join另外一个表的唯一性索引字段时，就是ref_eq</p>
<p> ref 非唯一性索引查询，就是根据普通索引去查找数据，例如查询条件是where a = 1，a是普通索引，但是不是唯一性索引</p>
<p> range: 表示有范围条件的全索引范围查询，跟index全索引扫描相比就是有查询条件，可以减少一些扫描的数据量。同时除了显而易见的between，and以及’&gt;’,’&lt;’外，in和or也是索引范围扫描。</p>
<p> index: 表示全索引扫描(full index scan), 这是另外一种全表扫描，例如order by 字段是索引字段，如果是直接去聚集索引下全表扫描，那么查询出来的结果集还需要在内存中排序一边，如果是去非聚集索引下进行全表扫描，然后按照扫描顺序进行回表，回表的顺序就是order by的顺序，可以减少排序的时间，但是会有回表的开销。</p>
<p> all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p>
</li>
</ul>
<p>   1.减少请求的数据量</p>
<p>   2.减少表扫描的行数</p>
<p>   4.避免在查询时，对索引字段进行计算和使用函数。</p>
<p>   5.切分大查询</p>
<p>   使用show profile对一条SQL查询分析当前会话中语句执行的资源消耗情况</p>
<p>优化的方法：<br>1.优化索引使用情况。使用explain SQL查看解析结果，首先看结果中Extra那一列是否有Using Index，如果没有看是否是where判断条件的字段没有添加索引，不能使用索引。如果出现的是Using Where，可能是where子句里面判断的字段没有加索引，这样innodb就会把所有数据行查询出来，返回给MySQL Server层，Server层做的过滤。</p>
<p>2.减少扫描的行数。查看explain SQL解析结果中rows那一列，看行数是不是特别多，通过添加索引的方式减少扫描的行数。</p>
<p>3.只查询我们需要的列。看SQL中的查询字段是不是都是我们需要的，只选取我们需要的字段，而不是所有查询SQL都是使用SELECT *，这些多的字段的存在，会增大查询的时间，以及网络传输的数据量。</p>
<p>4.优化join的方式，一般join的字段在被驱动表中有索引，那么join使用的算法就会是index Nested-Loop Join，如果没有索引那么就是block Nested-Loop Join。尽量让join的字段有索引可以使用，是在不行，可以增加join buffer Size的大小(默认是256K)。</p>
<p>5.如果单表数据量大于1000万，考虑进行分库分表。</p>
<p>Nested-Loop Join翻译成中文则是“嵌套循环连接”。</p>
<p>index Nested-Loop Join<br>原来的匹配次数 = 外层表行数 <em> 内层表行数 优化后的匹配次数= 外层表的行数 </em> 内层表索引的高度</p>
<p>Block Nested-Loop Join通过一次性缓存多条数据，把参与查询的列缓存到Join Buffer 里，然后拿join buffer里的数据批量与内层表的数据进行匹配，从而减少了内层循环的次数（遍历一次内层表就可以批量匹配一次Join Buffer里面的外层表数据）。</p>
<p>什么是Join Buffer？ （1）Join Buffer会缓存所有参与查询的列而不是只有Join的列。 （2）可以通过调整join_buffer_size缓存大小 （3）join_buffer_size的默认值是256K，join_buffer_size的最大值在MySQL 5.1.22版本前是4G，而之后的版本才能在64位操作系统下申请大于4G的Join Buffer空间。 （4）使用Block Nested-Loop Join算法需要开启优化器管理配置的optimizer_switch的设置block_nested_loop为on，默认为开启。</p>
<p>performance_schema这个数据库，里面总共有52个性能统计结果表，其中有一个table_io_waits_summary_by_index_usage表，里面统计了索引使用情况，里面有统计索引在查询，插入，更新，删除语句中使用到的次数。</p>
<p>三大范式</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[项目实践]]></title>
      <url>/p/80vhu/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>g盘创建vueblog      f盘vueblog-vue(前端)<br>Devtools 热加载</p>
<p>浏览器json插件</p>
<p>代码生成器<br>controller<br>entity<br>mapper<br>service</p>
<p>shiro+jwt  会话共享</p>
<p>（用户名，密码）<br>用户         —》后端  检验密码(错误抛出异常) 生成jwt 给用户</p>
<pre><code>   访问接口               有jwt                    jwt异常：过期，密钥不对
</code></pre><p>用户名—————-》Jwtfilter—————&gt;&gt;shiro登录处理———————》抛出异常——》全局异常捕获         </p>
<p>jwt正常，无jwt    注解过滤  xxxxController    shiro注解  @RequireRoles(“admin”)  无权限抛出异常    有权限-》controller</p>
<p>shiro与redis整合    realm自己定义<br>sessionManager  securityManager</p>
<p>重写快捷键 ctrl+i</p>
<p>一个认证  一个授权    前后端分离返回json</p>
<p>编写jwtfilter</p>
<p>shiro与权限相关都是抛异常处理</p>
<p>实体校验处理   注解     （注解失败导入spring-boot-starter-validation）</p>
<p>跨域 controller设置  filter设置</p>
<p>vue-cli 安装    npm i -g @vue/cli<br>shift+右键 打开powershell</p>
<p>postman  web请求调试</p>
<p>卸载老版本：cnpm uninstall vue-cli -g，下载新版本：cnpm install @vue/cli -g<br>vue ui   -&gt;  localhost:8000</p>
<p>路由  状态管理加入<br>hbuilder   webstorm</p>
<p>npm run serve</p>
<p>localstorage   sessionStorage    localStorage.getItem()</p>
<p>JSON.parse() 反序列化为对象</p>
<p>axios   前置拦截   后置拦截</p>
<p>console.log()</p>
<p>分割线   时间线</p>
<p>router-link to  name(组件) params（参数）</p>
<p>分页   事件 箭头函数</p>
<p>博客编辑用markdown编辑器   mavon-editor</p>
<p>回显  created()</p>
<p>路由权限拦截   permission.js做<br>meta:{<br>  requireAuth:true<br>}</p>
<h1 id="用于解析md文档"><a href="#用于解析md文档" class="headerlink" title="用于解析md文档"></a>用于解析md文档</h1><p>cnpm install markdown-it —save</p>
<h1 id="md样式"><a href="#md样式" class="headerlink" title="md样式"></a>md样式</h1><p>cnpm install github-markdown-css</p>
<p>博客详情   回显 渲染</p>
<p>padding  margin</p>
<v-if>

<p>部署</p>
<p>CloudXNS 解析域名</p>
<p>npm run build</p>
<p>nginx.exe -s stop</p>
<p>排序  全文检索</p>
<p>标题  摘要  正文</p>
<p>标签  分类</p>
<p>需求分析  设计<br>build.gradle</p>
<p>@restController</p>
<p>MockMvc</p>
<p>gradlew build</p>
<p>评论  点赞  分类    标签展示   关于我  归档</p>
<p>验证码redis看<br>获取ip   md5 避免过长   存key-value对   key(ip+user-Agent)   value(captchaText) 存到redis 设置过期时间  ip+user-Agent用MD5处理避免字符串过长<br>根据captchaText在后台生成图片 返回客户端   flush  close  刷新显示</p>
<blockquote>
<p>thymeleaf<br>ognl springel表达式<br>引入命名空间   xmlns:th=”<a href="http://www.thymeleaf.org" target="_blank" rel="noopener">http://www.thymeleaf.org</a>“<br>${}  变量表达式   #{}  消息表达式（文本外部化，国际化或i18n）<br>选择表达式   th:object     th:text=”<em>{}”    当前选择对象   用于遍历    表单<br>链接表达式   @{}<br>分段表达式   th:insert  th:replace         重用    th:fragment<br>字面量(文字)   文本 ‘’  数字  布尔   + - </em> / %  &gt;  &lt;  &gt;=   &lt;=(gt  )    ==   eq  ne<br>th:if<br>th:class<br>无操作  _<br>设置属性值   th:attr=”action=”<br>设置值到指定的属性   th:action<br>固定值布尔属性     checkbox      th:checked  selected<br>迭代器  th:each=”book: ${books}”     数组，列表，list  遍历<br>状态变量  index(0开始)  count（1开始）  size  current  even/odd   first  last<br>条件语句    th:if    th:unless    th:switch   th:case<br>模板布局   定义和引用片段    th:insert  th:replace    th:include<br>属性优先级<br>注释<br>解析器级注释块<!--/*-->      <!--*/--><br>原型注释块            静态    模板执行<br>内联  [[]]    [()]     th:inline=”none” 禁用内联<br>th:text  转义   th:utext  不转<br>表达式基本对象  ctx 上下文对象    locale<br>request   HttpServletRequest<br>session   HttpSession<br>thymeleaf标准方言  th:text=”${}”     data-th-text=””</p>
</blockquote>
<p>@PathVariable</p>
<p>restful 规范<br>form表单  action  method</p>
<p>es  存储  搜索  分析   分布式  （自带协调管理）</p>
<p>个人设置  头像变更  profile.html</p>
<p>bootstrap  响应式布局  移动设备优先   响应式meta标签   Normalize.css跨浏览器一致性    Reboot<br>网格系统    css移动优先  媒体查询  渐进增强<br>响应式： viewport尺寸增加  系统会自动分为最多12列<br>网格选项  xs  sm md  lg (不同设备大小)<br>bootstrap常用组件 样式 Typography   Table Form Button Dropdown      /  container   btn  btn-default   table table-striped</p>
<p><nav></nav>   toggle</p>
<p>csrf防护</p>
<p>非结构化  不定长  无固定格式<br>顺序扫描法   全文搜索<br>建立文本库    建立索引   执行搜索   过滤结果</p>
<p>es服务地址  连接超时时间<br>文档<br>@Document(indexName=”blog”,type=”blog”)    索引名</p>
<p>分页查询博客去重</p>
<p>@RunWith(SpringRunner.class)<br>@SpringBootTest </p>
<p>@Test   @Before  @After   assertThat  junit断言<br>@RequestParam(value=”title”)</p>
<p>rdb地址  <a href="https://pan.baidu.com/s/1Rfxw6bQEsch1osMx9Eg2lQ#hkwg" target="_blank" rel="noopener">https://pan.baidu.com/s/1Rfxw6bQEsch1osMx9Eg2lQ#hkwg</a></p>
<p>oauth2.0</p>
<p>oss 对象存储  springsecurity  mq    axios</p>
<p>qq微博第三方登录  qq互联</p>
<p>echarts   权限管理、第三方登录、websocket</p>
<p>fastdfs   vuex保存变量  持久化到session</p>
<p>swagger  加依赖 配置 @Configuration @EnableSwagger2 注解  @Api(tags=” “)    @ApiOperation(“”)   测试接口  enable.swagger:true    @Value()</p>
<p>模块化写法</p>
<p><dependencymanager></dependencymanager></p>
<p><modules></modules><br>@ControllerAdviece</p>
<p>@ExceptionHandler(Exception.class)</p>
<p>windows杀死占用端口的进程<br>netsat -ano<br>taskkill /pid pid号</p>
<p>上传的图片可以保存到七牛云</p>
<p>新增日志管理记录（aop + 自定义注解）<br>新增在线预览</p>
<p> JMETER_HOME<br> jmeter使用</p>
<p>悲观锁效率低   其他线程都会阻塞      用户体验差<br> 不在业务方法加同步块synchronized  要加在调用处<br> 事务范围大读到旧值   一个事务提交了多个请求</p>
<p>高并发：<br>缓存   提升访问速度  吞吐量<br> 降级   关闭不必要的服务<br>  限流<br>  RateLimiter</p>
<p>接口限流<br> 令牌桶和漏桶</p>
<p> 秒杀接口隐藏处理</p>
<p>验证码</p>
<p>检验验证码     减少qps   防止脚本ocr计数</p>
<p>gitee</p>
<p>springsecurity登录<br>easycaptcha    验证码存redis</p>
<p>消息对象</p>
<p>下单用rabbitmq<br>生产者  订单信息发到消息队列  返回显示正在排队中  创建订单消息对象传到消息队列（实现）<br>限流后   消费者再消费消息    更改数据库 增加订单</p>
<p>客户端轮询秒杀结果</p>
<p>md5加密</p>
<p>validation</p>
</v-if>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mancher回文串]]></title>
      <url>/p/80uv4/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记录不太熟悉的考点]]></title>
      <url>/p/80sm9/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>三次握手  4次挥手<a href="https://blog.csdn.net/weixin_33929309/article/details/91629868" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33929309/article/details/91629868</a></p>
<p>最擅长领域  学习经历<br>项目看视频   为什么用这个技术  设计 规划   功能实现  场景<br>协程<br>hashmap 线程不安全<br>快恢复     <a href="https://blog.csdn.net/qq_36953135/article/details/77506009" target="_blank" rel="noopener">https://blog.csdn.net/qq_36953135/article/details/77506009</a><br>2、快恢复   <a href="https://blog.csdn.net/jtracydy/article/details/52366461" target="_blank" rel="noopener">https://blog.csdn.net/jtracydy/article/details/52366461</a><br>（1）当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半。这是为了预防网络发生拥塞，但不执行慢开始算法。<br>（2）由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认）。因此与慢开始不同之处就是现在不执行慢开始算法（即拥塞窗口现在不设置为1）而是把拥塞窗口的值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p>快重传<br>1、快重传<br>快重传算法首先要求接收方每收到一个失序的报文段就立即发出重复确认（为的是使发送方及早的知道有报文段没有到达对方）而不要等到自己发送数据时才捎带确认。</p>
<p>快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期。</p>
<p>https过程<br>内部类    <a href="https://www.cnblogs.com/dearcabbage/p/10609838.html" target="_blank" rel="noopener">https://www.cnblogs.com/dearcabbage/p/10609838.html</a><br>内部类可以分为四种:成员内部类、局部内部类、匿名内部类、静态内部类</p>
<p>局部内部类存在于方法中。<br>他和成员内部类的区别在于局部内部类的访问权限仅限于方法或作用域内<br>局部内部类就像局部变量一样，前面不能访问修饰符以及static修饰符</p>
<p>静态内部类和成员内部类相比多了一个static修饰符。它与类的静态成员变量一般，是不依赖于外部类的。同时静态内部类也有它的特殊性。因为外部类加载时只会加载静态域，所以静态内部类不能使用外部类的非静态变量与方法。<br>同时可以知道成员内部类里面是不能含静态属性或方法的。</p>
<p>静态内部类对象的创建一般是外部类.内部类 类名 = new 外部类.内部类();<br>成员内部类对象的创建一般是外部类.内部类 类名 = 外部类对象名.new 内部类();</p>
<p>内部类的好处<br>完善了Java多继承机制，由于每一个内部类都可以独立的继承接口或类，所以无论外部类是否继承或实现了某个类或接口，对于内部类没有影响。<br>方便写事件驱动程序。</p>
<p>bean生命周期<br>spring事务传播行为<br>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性<br>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播<br>PROPAGATION_</p>
<p>spring事务隔离级别<br>TransactionDefinition接口中定义了五个表示隔离级别的常量<br><a href="https://www.cnblogs.com/Jomini/p/14016229.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jomini/p/14016229.html</a><br>循环依赖三重缓存<br> Java中的循环依赖分两种，一种是构造器的循环依赖（只能报错），另一种是属性的循环依赖<br> Spring解决的循环依赖就是指属性的循环依赖</p>
<p>可以看出这三个map的优先级。其中singletonObjects里面存放的是初始化之后的单例对象；earlySingletonObjects中存放的是一个已完成实例化未完成初始化的早期单例对象；而singletonFactories中存放的是ObjectFactory对象，此对象的getObject方法返回值即刚完成实例化还未开始初始化的单例对象。所以先后顺序是，单例对象先存在于singletonFactories中，后存在于earlySingletonObjects中，最后初始化完成后放入singletonObjects中。<br>当debug到此处时，以上述Teacher和Student两个循环引用的类为例，如果第一个走到这一步的是Teacher，则从此处这三个map中get到的值都是空，因为还未添加进去。这个方法主要是给循环依赖中后来过来的对象用。</p>
<p>Spring通过将实例化后的对象提前暴露给Spring容器中的singletonFactories，解决了循环依赖的问题</p>
<p>最左前缀匹配  慢查询<br><a href="https://blog.csdn.net/sinat_41917109/article/details/88944290" target="_blank" rel="noopener">https://blog.csdn.net/sinat_41917109/article/details/88944290</a><br>最左边开始连续匹配，用到了索引<br>匹配列前缀<br>如果左边的列是精确查找的，右边的列可以进行范围查找<br>drop（删除表） truncate（释放空间） delete（不释放空间）<br><a href="https://www.cnblogs.com/zhizhao/p/7825469.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhizhao/p/7825469.html</a><br>快排 排序算法时间复杂度 空间复杂度<br>红黑树</p>
<p>连通分支等图编程  trie 并查集<br>jvm 三色标记法<br>白色：没有检查（或者检查过了，确实没有引用指向它了）<br>灰色：自身被检查了，成员没被检查完（可以认为访问到了，但是正在被检查，就是图的遍历里那些在队列中的节点）<br>黑色：自身和成员都被检查完了</p>
<p>初始时，所有对象都在 【白色集合】中；<br>将GC Roots 直接引用到的对象 挪到 【灰色集合】中；<br>从灰色集合中获取对象：<br>3.1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；<br>3.2. 将本对象 挪到 【黑色集合】里面。<br>重复步骤3，直至【灰色集合】为空时结束。<br>结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。</p>
<p>树状数组 线段树</p>
<p>spring bean生命周期<br>实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。</p>
<blockquote>
<p>实例化 Instantiation<br>属性赋值 Populate<br>初始化 Initialization<br>销毁 Destruction</p>
</blockquote>
<p>单实例在容器启动时创建对象（当然也可以设置懒加载方式，使得单实例也可以在获取时创建）<br>多实例在每次获取时创建对象</p>
<p>对象的初始化<br>当对象已经创建完成，并赋好了值，再去调用初始化的方法</p>
<p>对象的销毁<br>单实例在容器关闭时，容器会自动调用销毁方法<br>多实例容器不会调用销毁方法，必须用户自定义销毁方法</p>
<p>实例化：Spring 容器根据配置中的 beanDefinition实例化bean。<br>属性赋值：Spring 使用依赖注入(构造器或者setter)填充所有属性，如 bean 中所定义的配置。<br>初始化之前： 如果存在bean实现的任何XXXBeanPostProcessors，则调用 postProcessBeforeInitialization() 方法。<br>初始化：如果为 bean 指定了 init 方法（ 的 init-method 属性），那么将调用它，或者实现了InitializingBean接口，则调用postPropertiesSet()方法实现初始化逻辑。<br>初始化之后：如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。<br>销毁：如果为 bean 指定了 destroy 方法（ 的 destroy-method 属性），那么将调用它，或者实现了DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</p>
<p>CMS：写屏障 + 增量更新  并发标记  重新标记<br>G1：写屏障 + SATB（原始快照）<br>ZGC：读屏障</p>
<p>第一种问题： 错标   没什么太大影响 下一轮垃圾回收可解决<br>第二种问题：漏标，或者叫错杀<br>错杀的情况只有在 下边两个条件同时发生，才会发生<br>黑色对象指向了白色对象；<br>而本来指向这个白色对象的灰色对象断开了对它的连接。</p>
<p>在这讲述解决方案之前，要描述两个名词：读屏障和写屏障。注意，这里的屏障和并发编程中的屏障是两码事儿。这里的屏障很简单，可以理解成就是在读写操作前后插入一段代码，用于记录一些信息、保存某些数据等，概念类似于AOP。</p>
<p>增量更新，就是在赋值操作之前添加一个写屏障，在写屏障中记录新增的引用<br>在我们这个例子中，在并发标记阶段，A是一个黑色对象，F是一个白色对象，A引用了F，这个引用关系会被记录下来，然后通过这个记录在重新标记阶段再从A对象开始枚举一次，保证如果A还是保持着F的引用，那么F会被正确标记；如果A到F的引用在并发标记阶段又断开了，此次枚举也无法访问到它，活该被清除。</p>
<p>在重新标记阶段如果用户线程还是继续执行，那么这个GC永远可能也做不完了，所以重新标记需要STW，但是这个时间消耗不会太夸张。如果实在重新标记阶段耗时过长，那么可以尝试在重新标记之前做一次Minor GC</p>
<p>原始快照是站在减少引用的对象（也就是例子中的B对象）的角度来解决问题。所谓原始快照，简单的讲，就是在赋值操作（这里是置空）执行之前添加一个写屏障，在写屏障中记录被置空的对象引用。比如，用户线程要执行：B.f=null；那么在写屏障中，首先会把B.f记录下来，然后再进行置空操作。记录下来的这个对象就可以称为原始快照。<br>那么记录下来之后呢？很简单，之后直接把它变为黑色。意思就是默认认为它不是垃圾，不需要将其清理。当然，这样处理有两种情况，一种情况是，F的确不是垃圾，直到清理的那一刻，都仍然有至少一个引用链能访问到它，这没有什么问题；另一种情况就是F又变成了垃圾。在上述的例子中，就是A到F的引用链也断了，或者直接A都成垃圾了，那F对象就成了浮动垃圾。对于浮动垃圾，前面不止一次就提到了，直接不用理会，如果到下一次GC时它仍然是垃圾，自然会被清理掉。</p>
<p>白色对象可能是从其他对象的引用链上”转移“过来的，也可能就是一个新对象。其实可以想象的到，对于新对象加入到黑色节点，我们无法使用原始快照，但是可以使用增量更新，或者直接简单处理，和并发清理阶段一样：在这期间创建的新对象都认为不是垃圾（比如标记为黑色），如果成了垃圾，那就是浮动垃圾，还是留待下一次GC处理。总之，标记的总体原则就是，“另可放过，不可杀错”<br><a href="https://blog.csdn.net/huangzhilin2015/article/details/115282572" target="_blank" rel="noopener">https://blog.csdn.net/huangzhilin2015/article/details/115282572</a></p>
<p><a href="https://www.jianshu.com/p/14cd2c9d2cd2" target="_blank" rel="noopener">https://www.jianshu.com/p/14cd2c9d2cd2</a><br>对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。</p>
<p>非对称加密与对称加密相比，其安全性更好<br>HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</p>
<p>验证证书<br>根证书在验证证书的过程中起着核心的作用<br>证书的指纹和签名(指纹算法)<br>指纹的字符串，指纹可以理解为证书身份的唯一代表，是用来保证证书的完整性的，确保证书没有被修改过<br>签名是在信息后面加上的一段数字串，可以证明该信息有没有被修改过。数字证书在发布的时候，CA机构将证书的指纹和指纹算法通过自己的私钥加密得到的就是证书的签名了</p>
<p>我们在验证证书的时候，首先通过机构的根公钥去解密证书的签名，解密成功的话会得到证书的指纹和指纹算法，指纹是一个hash值，它代表着证书的原始内容，此时再通过指纹算法计算证书内容得到另外一个hash值，如果这两个hash值相同，则代表证书没有被篡改过，否则就是被篡改了</p>
<p>中间人攻击  对比证书上的URL和我们请求的URL是否相同，我们还是可以判断当前证书是不是服务器发的证书</p>
<p>time_wait close_wait</p>
<p>线程池状态<br>running  能够接收新任务，以及对已添加的任务进行处理<br>shutdown    不接收新任务，但能处理已添加的任务<br>stop   不接收新任务，不处理已添加的任务，并且会中断正在处理的任务<br>tyding   所有的任务已终止<br>terminated   线程池彻底终止，就变成TERMINATED状态</p>
<p>跨域   同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互</p>
<p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。</p>
<p>核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。<br>CORS 是跨域资源分享<br>nginx反向代理</p>
<p>restful接口<br>web攻击</p>
<p>jwt 字符串 hear payload 签名<br>token  服务端 生成验证 扩展 app 跨域<br>对于springSecurity的过滤器，我的理解是大致可以分为三类：</p>
<p>1.常规的过滤器，用于对http协议进行支持，如cors,xsrf,headerWrite等，它们通常需要沿着过滤链继续传递;</p>
<p>2.用于认证的过滤器，它们可以根据认证的结果对过滤链进行阻断，如直接返回结果给前端，或者重定向;</p>
<p>3.用于授权的过滤器，它以认证为前提。处于过滤链的末端，通过它之后，将会进入到servlet进行服务;</p>
<p>红黑树的规定   它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</p>
<p>每个节点要么是红色，要么是黑色。<br>根节点必须是黑色<br>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。<br>对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点</p>
<p>插入或者删除操作往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件<br>一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（RotateRight）。</p>
<p>设计模式的目的<br>公司有什么了解</p>
<p>explain 命令</p>
<p>二维数组寻找峰值 O(nlogm)<br>指针head变</p>
<p>跳跃表  压缩列表 </p>
<p>TCP粘包拆包<br>happens before<br>分布式  高并发 微服务</p>
<p>字节序大端小端<br>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。<br>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。</p>
<p>首先，为什么会有小端字节序？<br>答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。<br>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。<br>4.<br>计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。<br>如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。<br>理解这一点，才能理解计算机如何处理字节序。</p>
<p>实现生产者消费者<br>jvm命令排查</p>
<p>I/O<br>zookeeper</p>
<p>序列化保证传输完整性</p>
<p>dto  vo<br>@Resource  和@Autowired</p>
<p>偏向锁  一个线程获取锁<br>轻量级锁 线程交替执行  不存在锁竞争</p>
<p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。</p>
<p>然后线程尝试用CAS操作将自己线程栈中拷贝的锁记录的地址写入到锁对象的Mark Word中。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p>
<p>自旋（不释放cpu 空操作）</p>
<p>JDK采用了适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋时触发重量级锁的阀值会更高，如果自旋失败了，则自旋的次数就会减少。</p>
<p>当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。(锁释放失败)</p>
<p>重量级锁  操作系统Mutex lock   重量级锁会设置几种状态用来区分请求的线程<br>阻塞 唤醒开销大<br>重量级锁就是由对象监视器monitor来实现的，当多个线程同时请求某个重量级锁时，重量级锁会设置几种状态用来区分请求的线程：</p>
<p>锁降级因为如果没有多线程竞争，还是使用重量级锁会造成额外的开销，所以当JVM进入SafePoint安全点（可以简单的认为安全点就是所有用户线程都停止的，只有JVM垃圾回收线程可以执行）的时候，会检查是否有闲置的Monitor，然后试图进行降级。</p>
<p>偏向锁的解锁很简单，其仅仅将线程的栈中的最近一条 lockrecord的 obj字段设置为null</p>
<p>ReentrantLock公平锁和非公平锁</p>
<p>其次是synchronized的等待队列只有一个(调用wait()方法的线程会进入等待队列)，而ReentrantLock可以有多个条件等待队列。</p>
<p>注解可以是作用于源码层面，字节码文件层面，运行时层面。</p>
<p>通常情况下，我们使用的注解都是运行时注解，在运行时，JVM在运行时会针对注解生成一个动态代理类，通过反射获取注解时，实际上返回的是Java运行时生成的动态代理对象$Proxy1，而Proxy类就是我们注解（接口）的具体实现类。</p>
<p>扩容  hashtable(sychronized)  concurrenthashmap(标识节点 到新数组)</p>
<blockquote>
<p>假设原数组长度为16，length-1二进制表示为1111。key1的hash值为9，二进制表示为01001，key2的hash值为25，11001，</p>
</blockquote>
<p>所以hash&amp;(length-1)的结果只要看低4位的结果，9和25的低4位都是1001，所以计算结果一致，计算结果都是9，所以在数组中处于数组下标为9的元素链表中。</p>
<p>扩容后数组长度为32，length-1二进制表示为11111，key1的hash值为9，二进制表示为01001，key2的hash值为25，11001，</p>
<p>所以hash&amp;(2*length-1)的结果需要看低5位的结果，9和25的低4位都是1001，所以计算结果不一致，计算结果都是9和25，因为key2的hash值的第五位为1，key1的hash值的第五位为0，所以会多16，也就是原数组长度的大小。</p>
<p>所以原数组同一下标index下的链表存储的hash冲突的元素，扩容后在新数组中的下标newIndex要么为index，要么为index+length（去决定于hash值的第N位为1，还是0，也就是hash&amp;length的结果，原数组长度length为2的N-1次幂）</p>
<p>所以会遍历链表(或者红黑树)，然后对数组下标index下每个节点计算hash&amp;length的结果，然后存放在两个不同的临时链表中，遍历完成后，hash&amp;length结果为0的元素组成的临时链表会存储在新数组index位置，hash&amp;length结果为1的元素组成的临时链表会存储在新数组index+length位置。</p>
<blockquote>
<p>ConcurrentHashMap，HashTable是线程安全的， 在多线程操作时，因为get(key)和containsKey(key)两个操作和在一起不是一个原子性操作，可能在containsKey(key)时发现存在这个键值对，但是get(key)时，有其他线程删除了键值对，导致get(key)返回的Node是null，然后执行方法时抛出异常。所以无法区分value为null还是不存在key。</p>
</blockquote>
<p>LinkedHashMap   LRU    before指针 after指针</p>
<p>hashmap链表成环  1.7<br>扩容头插法</p>
<p>1.8之后<br>首先迁移时不是拿到一个键值对就迁移一个了，而是对一个数组下标下的链表进行遍历，根据hash值的不同，分成两个链表，然后将两个链表分别设置到新的数组的<br>下标下。</p>
<p>扩容尾插法</p>
<p><a href="https://blog.csdn.net/jiangjunlanzhoulan/article/details/81239054">https://blog.csdn.net/jiangjunlanzhoulan/article/details/81239054</a></p>
<p>concurrenthashmap</p>
<p>atomic原子变量类就是乐观锁</p>
<p>time_wait状态存在的意义是可以有效地终止TCP连接</p>
<p>LockSupport</p>
<p>jdk动态代理<br>Proxy.newProxyInstance()</p>
<p>创建一个类，继承InvocationHandler，重写invoke()方法，在这个方法里面做一些日志打印的操作后，然后通过反射的API调用method.invoke(target, args);</p>
<p>实现原理：就是在调用Proxy.newProxyInstance()时会根据类加载器和目标类Class对象动态创建一个代理类出来，动态代理类的所有方法的实现都是向下面这样，方法内部都是调用invocationHandler的invoke()方法</p>
<p>cglib动态代理</p>
<p>创建一个类，继承MethodInterceptor类，重写intercept方法，接受方法调用。创建一个Enhancer实例，设置代理类的父类为目标类，设置回调。</p>
<p>树状数组 是一种用于维护前缀信息的的数据结构</p>
<p>Floyd算法 （最短路径）</p>
<p>jquery  bootstrap</p>
<p>油猴脚本<br><a href="https://blog.csdn.net/u011054333/article/details/104101806">https://blog.csdn.net/u011054333/article/details/104101806</a></p>
<p>项目遇到问题   项目亮点</p>
<p>JVM<br>组成：类加载器，运行时数据区，内存分区，执行引擎，本地库接口，<br>类加载：</p>
<p>双亲委派机制：加载器（应用加载器，扩展加载器，根加载器）<br>JVM启动过程（JVM的装入环境和配置（查JRE）、装载JVM（LoadJavaVM）、初始化JVM（CreateJavaVM），运行Java程序（GetMainClassName））<br>JVM内存模型：<br>本地方法栈：执行本地native方法<br>虚拟机方法栈:执行java方法（局部变量表、操作数栈、动态连接、方法出口）<br>程序计数器：字节码的行号<br>方法区：虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等 1.8之前永生代堆中，之后本地内存元空间<br>堆<br>内存溢出泄露：<br>java编译过程：初始化插入式注解处理器、解析与填充符号表过程、注解处理、分析与字节码生成）</p>
<p>Redis扩容机制</p>
<p>时间复杂度分析</p>
<p>web开发<br>spring核心：aop（动态代理，切点切面通知）ioc(控制反转 DI)<br>JDK动态代理和cglib区别：接口   ；底层字节码技术，子类代理（在性能方面，CGLib高很多。但是，CGLib在创建代理对象时所花费的时间多）<br>spring boot：使用“习惯优于配置”的理念，很容易创建一个能独立运行、准生产级别、基于Spring框架的项目<br>stater:Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度<br>springboot启动流程：<br>自动装配：引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数<br>过程：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类（@Conditional指定的生效条件），实例化类中定义的Bean（组件等），并注入Spring容器<br>常用注解：@SpringBootApplication（启动类）；@EnableAutoConfiguration（自动配置） @Import @Conditional<br>@Autowired @Resource 区别：Spring注解，JDK注解； 按类型注入，按名称（也可以按类型）注入；<br>bean的作用域：@Scope注解修改Bean的作用域<br>bean生命周期：实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁<br>解决循环依赖：<br>  a. 构造器：这种依赖spring是处理不了的，抛出异常。<br>  b. 单例模式下的setter：通过“三级缓存”处理循环依赖。<br>  c. 非单例：无法处理。<br>这三级缓存的作用分别是：<br>spring管理事务：编程式事务  声明式事务 （@Transactional）<br>spirng事务传播方式：<br>spring MVC：<br>流程：请求 建立连接 前端控制器 请求映射器 请求适配器 ModelAndView 视图解析器 view  渲染返回<br>注解：@RequestMapping （请求地址映射）@RequestParam（请求参数绑定）@RequestBody：@PathVaribale（绑定url中的占位符）</p>
<p>rehash<br>switch里面内容</p>
<p>正向代理和反向代理</p>
<p>tomcat类加载   字节码文件剖析</p>
<p>vo dto<br><a href="https://www.cnblogs.com/zxf330301/p/6534643.html">https://www.cnblogs.com/zxf330301/p/6534643.html</a></p>
<p>http缓存</p>
<p>多路io复用</p>
</script></p>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis]]></title>
      <url>/p/80p92/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>redis设计与实现</p>
<p>G1垃圾回收器的原理：<br>8.binlog有哪些<br>9.ip协议的划分</p>
<p>关于项目：<br>数据库的设计<br>session机制的时间设置，会不会过期</p>
<p>哈希表扩展与收缩 rehash</p>
<p>压缩列表  ziplist</p>
<p>大部分情况跳跃表和平衡树效率差不多 但实现简单<br>zskiplistnode<br>zskiplist 节点数量 头节点   尾节点<br>层  前进指针    跨度<br>后退指针<br>节点按分值从小到大排序<br>节点成员对象</p>
<p>多个跳跃表节点组成一个跳跃表</p>
<p>压缩列表是列表键和哈希键底层实现<br>小整数  短字符串<br>节约内存  特殊编码 连续内存块 顺序形数据结构<br>包含任意多个节点 每个节点可保存一个字节数组或一个整数值<br>zlbytes zltail  zllen</p>
<p>previous_entry_length  记录前1个节点长度<br>1字节或5字节</p>
<p>尾部向前遍历</p>
<p>encoding   记录节点content属性保存数据类型和长度<br>00   01 10 字节数组<br>11  整数</p>
<p>redisServer<br>服务器中数据库  db数组<br>初始化服务器  dbnum决定应创建多少个数据库</p>
<p>切换数据库  select</p>
<p>redisClient db属性记录客户端当前目标数据库 指针</p>
<p>数据库键空间  dict字典保存所有键值对 字典称为键空间</p>
<p>watch命令监视某个键  脏 修改</p>
<p>ttl   setex  expire  expireat    persist<br>pttl<br>expires字典保存数据库所有键过期时间<br>键是指针指向某个数据的键<br>值是过期时间</p>
<p>定时删除   定时器  cpu不友好<br>惰性删除    内存不友好<br>定期删除   难点是时长和频率<br>实现</p>
<p>RDB持久化<br>bgsave  save  实现<br>生成rdb文件    压缩二进制文件<br>载入rdb文件<br>启动redis时 开启rdb功能会载入rdb文件   分主从<br>rdb保存键值对  aof保存写命令<br>rdb文件结构<br>AOF持久化<br>实现  命令追加  文件写入  文件同步<br>aof文件重写实现</p>
<p>去除冗余浪费空间的命令 读取服务器当前数据库状态实现<br>优先aof<br>bgrewriteaof<br>aof写入<br>aof重写</p>
<p>aof缓冲区<br>aof重写缓冲区<br>aof后台重写</p>
<p>持久化可以手动执行也可以根据服务器配置定期执行</p>
<p>事件<br>客户端<br>服务器<br>复制<br>Sentinel  高可用   sentinels字典   监视  主观下线  客观下线<br>命令连接  订阅连接<br>每秒10次发送INFO命令<br>ping   指定时长连续发送无效回复认为主观下线<br>集群<br>分布式数据库方案 通过分片进行数据共享  提供复制和故障转移功能<br>cluster meet  连接节点   握手<br>集群数据结构<br>clusterNode 保存节点当前状态<br>重新分片  redis-trib 将属于某个槽的所有键值对从一个节点转移至另一个节点<br>事务</p>
<p>单线程实现简单  基于内存操作 瓶颈是内存和网络带宽<br>单线程指的是处理客户端发送的请求命令的文件处理器模块是单线程，其他模块不一定是单线程的</p>
<p>优点：<br>锁  上下文切换</p>
<p>Redis采用单线程的劣势:<br>1.无法充分发挥多核机器的优势，不过可以通过在机器上启动多个Redis实例来利用资源。（但是启动多个Redis实例可能会导致在进行AOF重写时，竞争IO资源，导致磁盘写入压力过大，所以可以使用脚本来触发实例的AOF重写，让所有实例的 AOF 串行执行。）</p>
<p>SDS会使用空间预分配和惰性空间释放</p>
<p>非阻塞：  不断询问</p>
<p>I/O复用指的是多个I/O连接复用一个进程</p>
<p>epoll是对select和poll的升级版，解决了很多问题，是线程安全的，而且可以通知进程是哪个Socket连接有I/O事件,不需要进行全部连接进行遍历，提高了查找效率。</p>
<p>epoll和select/poll最大区别是</p>
<p>(1)epoll内部使用了mmap共享了用户和内核的部分空间，避免了数据的来回拷贝。 (2)epoll基于事件驱动，epoll_wait只返回发生的事件避免了像select和poll对事件的整个轮寻操作（时间复杂度为O(N)），epoll时间复杂度为O（1）。</p>
<p>发送信号</p>
<p>epoll水平触发和边缘触发的区别？</p>
<p>select/poll  epoll</p>
<p>redis数据结构   字符串  hash list  set zset</p>
<p>在Redis中，字符串有两种存储方式，int编码，embstr编码和raw编码。</p>
<p>在Redis中，字符串有两种存储方式，int编码，embstr编码和raw编码。</p>
<p>hash   ziplist或者hashtable</p>
<p>ziplist     (字符串长度较短且元素个数较少)<br>元素保存的字符串长度较短且元素个数较少时(小于64字节，个数小于512)，出于节约内存的考虑，hash表会使用ziplist作为的底层实现，ziplist是一块连续的内存，里面每一个节点保存了对应的key和value，然后每个节点很紧凑地存储在一起，优点是没有冗余空间，缺点插入新元素需要调用realloc扩展内存。（可能会进行内存重分配，将内容拷贝过去，也可能在原有地址上扩展）。</p>
<p>hashtable<br>元素比较多时就会使用hashtable编码来作为底层实现，这个时候RedisObject的ptr指针会指向一个dict结构，dict结构中的ht数组保存了ht[0]和ht[1]两个元素，通常使用ht[0]保存键值对，ht[1]只在渐进式rehash时使用。hashtable是通过链地址法来解决冲突的，table数组存储的是链表的头结点（添加新元素，首先根据键计算出hash值，然后与数组长度取模之后得到数组下标，将元素添加到数组下标对应的链表中去）。</p>
<blockquote>
<p>Java中的列表数据进行缓存时一般是序列化成JSON，以字符串的形式存储在Redis上，而不是使用Redis中的List来进行存储</p>
</blockquote>
<p>quicklist   双向链表 链表节点是ziplist</p>
<p>set   元素少  整数数组  元素多 hashtable</p>
<p>zset元素较少用ziplist   元素较多时用skiplist+dict</p>
<p>skiplist+dict<br>当元素较多时，使用skiplist+dict来实现。 skiplist存储元素的值和Score，并且将所有元素按照分值有序排列。便于以O(logN)的时间复杂度插入，删除，更新，及根据Score进行范围性查找。</p>
<p>dict存储元素的值和Score的映射关系，便于以O(1)的时间复杂度查找元素对应的分值。</p>
<blockquote>
<p>跳跃表理解   (多级索引)</p>
</blockquote>
<p>就是单链表的查找的时间复杂度为O(N)，为了提高查询效率，可增加一些索引节点，让查询时间复杂度降低为O(logN)。（只有底层单链表会保存节点数据，上层的节点之后保存几个索引项和分数，也就是向左指向前一个节点的索引，向右指向后一个节点的索引，向下指向上一级的索引。）</p>
<p>时间复杂度的推理过程可以认为，从每一级索引中两个节点中选一个节点作为下一级索引的节点，让下一级索引的节点数量为本级索引节点数量的一半。假设原始链表的长度为n，第一级索引节点个数为n/2,第二级为n/4，一直到最高层。</p>
<p>要原因是因为作为一种动态的数据结构，其删除和添加的节点是不可预测的，而跳跃表又不能像平衡二叉树那样，可以通过染色或者旋转来维持平衡，如果严格按照两个节点之间建立一个索引，在删除和添加节点时，需要更新的索引太多了。所以在这种情况下，就需要一种概率随机化的方式来自动均衡跳跃表的多级索引，通过这种方式虽然不能完全保证跳跃表的均匀性，但总体上可以使得跳跃表趋于平衡，从而能够达到较高的综合性能。</p>
<p>时间复杂度</p>
<p>所以每一层最多遍历的节点数是&lt;=3,这是由于每一层索引节点数是上一层的节点数的一半来得到的，每两个节点的区间，在上一层中都是两个区间，就是第三层的 1  5区间对应上一层的1  3 区间和3  5 区间。<br>所以时间复杂度=总层数*每层遍历节点数=3logN,去掉常数后是log(N)<br>空间复杂度 1/(1-p)</p>
<p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p>
<p>每一次IO读取的数据我们称之为一页(page)<br>具体一页有多大数据跟操作系统有关，一般为4k或8k，innodb中一页是16K。)</p>
<blockquote>
<p>因为每个节点有多层前进指针，首先取第一个节点的最上层的前进指针level[i]，比较指针level[i]跳转到的节点的score与查找的score的大小</p>
</blockquote>
<p>如果大于，那么说明要查找的score就处于当前节点与当前的level[i]跳转的节点之间，不能跳转，直接下降一级，取level[i-1]的指针进行判断。如果level[i-1]是最下面的一层，也就是单链表的指针，那么就直接向后进行遍历查找，直到找到这个score或者第一个大于这个score的值(也就是范围查找的左边界)。</p>
<p>如果小于，说明说明要查找的score就处于当前节点与当前的level[i]跳转的节点的后面，跳转后，取跳转后的节点进行这个判断。</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210213345813.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210213646261.jpg" alt></p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>RDB   写时复制  共享内存    备份  快速重启<br>save阻塞</p>
<p>bgsave非阻塞</p>
<p>flushall</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210220946752.jpg" alt></p>
<p>AOF<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210221246117.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210222737692.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210223018718.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210223236925.jpg" alt><br>redis-check-aof —fix  修复aof文件</p>
<p>发布订阅  主从复制  哨兵模式<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210224120960.jpg" alt></p>
<p>单个主机单点故障</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210224659439.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210224857834.jpg" alt><br>slaveof no one</p>
<p>哨兵模式原理<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210225029138.jpg" alt></p>
<p>哨兵故障<br>多哨兵模式   奇数节点<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210225310267.jpg" alt><br>主观下线<br>客观下线<br>选哨兵领导</p>
<p>队列offset</p>
<p>选offset大的 比较新<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211210225850095.jpg" alt></p>
<p>全量复制<br>部分复制</p>
<p>集群cluster</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis]]></title>
      <url>/p/80p8o/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>EJB配置复杂  适用范围小<br>pojo  和数据库表的映射    xml映射文件或者注解<br>pojo操作数据库数据    hibernate全表映射</p>
<p>mybatis  映射文件  sql语句   支持存储过程   自动映射<br>mybatis_config.xml 配置文件<br>sqlsessionFactory  sqlsession  映射器</p>
<p>sqlSession.commit()<br>sqlSession.rollback()<br>sqlSession.close()</p>
<p>parameterType参数类型     resultType返回数据类型<br>读取配置文件生成映射器<br>SQL Mapper</p>
<p>sqlSession.selectOne  不推荐<br>sqlSession及时关闭</p>
<p>log4j.properties    打印运行sql和参数</p>
<p>preparedstatement 预处理语句</p>
<p>environments配置环境<br>配置多个数据源（数据库源  数据库事务）<br>自定义数据源  实现DataSourceFactory接口</p>
<p>系统别名（基本数据类型 集合类）  自定义别名</p>
<p>文件路径/包名引入映射器/类注册</p>
<p>select   resultMap  (id  result  property column)   useCache</p>
<p>insert flushCache(是否清空本地缓存 二级缓存)   自定义主键生成规则</p>
<p>存储过程支持<br>自定义缓存</p>
<p>association  collection discriminator 级联  </p>
<p>N+1问题   延迟加载   lazyLoadingEnabled    按层级延迟加载</p>
<p>sqlsessionZ在一级缓存隔离  为了克服用二级缓存<br>实现二级缓存  pojo序列化    sqlsessionfactory层面共享</p>
<p>自定义缓存</p>
<p>动态sql<br>if test<br>choose  when otherwise<br>where trim set<br>foreach  遍历集合 支持数组 List Set<br>bind  OGNL表达式</p>
<p>反射<br>jdk动态代理      映射器<br>cglib动态代理    mabatis延迟加载用到<br>建造者模式创建sqlSessionFactory<br>构建sqlSessionFactory过程</p>
<p>映射器内部组成<br>sqlSession运行过程   插件基础</p>
<p>Executor 执行器  3种  重用  批量更新<br>StatementHandler    适配器   prepare()<br>ParameterHandler   parameterize()<br>ResultHandler 结果处理器</p>
<p>query/update  执行sql</p>
<hr>
<p>spring<br>构造方法注入<br>setter<br>注解<br>接口注入   配置jndi数据源</p>
<p>aop:<br>切点 切面 连接点 通知  目标对象  aop代理</p>
<p>事务传播行为 自调用问题</p>
<p>spring 自动扫描  component-scan</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring]]></title>
      <url>/p/80p8o/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于注解组件扫描<br>Spring组件扫描和自动织入<br>spring技术内幕  java nio</p>
<p>bean生命周期等</p>
<p>设计思路，项目架构</p>
<p>java 过滤器  拦截器</p>
<p>多种环境中配置和使用事务处理的能力 提供通用支持<br>ioc容器强大配置能力 声明事务</p>
<p>aop  事务属性配置和读取 事务对象抽象<br>事务处理器    数据源事务处理支持<br>事务管理  并发  数据一致性<br>事务处理拦截器<br>编程实现<br>事务处理器实现</p>
<p>springboot启动过程<br>构造SpringApplication实例 调用SpringApplication的静态方法run()<br>调用构造器方法创建出一个SpringApplication实例，在构造器中会确定当前web应用类型，是reactive web类型，还是servlet web类型，还是none类型。以及设置监听器等等，完成一些初始化操作。(监听器就是来监听SpringApplication启动过程的，在开始启动，创建上下文，启动失败等生命周期事件时都会调用监听器相关的方法)</p>
<p>执行实例的run()方法，首先会创建一个StopWatch计时器，来统计run()方法的启动耗时，在日志里面会显示启动时间，那个时间就是在这里统计的。然后处理环境参数，就是java -jar <em>*</em>.jar启动命令中带的那些jvm参数。</p>
<p>创建applicationContext</p>
<p>执行prepareContext()方法<br>会调用prepareContext()方法来为应用上下文做一些准备工作，会将运行时的参数封装成bean，注册到beanFactory中去，以及使用load方法加载启动类</p>
<p>执行refreshContext()方法<br>动容器，也就是会为beanFactory做很多配置，注册BeanPostProcessors，设置类加载器等等。在这一步也会解析启动类中@SpringBootApplication这个组合注解。</p>
<p>afterRefresh()方法<br>这个方法里面会把容器里面所有ApplicationRunner自定义子类和CommandLineRunner自定义子类的Bean全部取出来，执行它们的run()方法。(就是有时候如果需要在应用启动后执行一些我们自定义的初始化操作，可以通过自定义一个类，继承ApplicationRunner类来实现。)</p>
<p>之后会调用listeners.started()方法，通知所有Listener，application已经启动完成了，以及调用listeners.running()方法通知所有Listener，application已经运行了。</p>
<p>C和A是无法同时做到。所以一般对于数据一致性要求特别高的业务，例如支付，交易相关的业务，就是会优先保证一致性C和分区容错性P，就是保证数据一致性，例如让所有子节点都收到更新后才算提交成功，就像MySQL主从同步中的全同步模式一样。普通的业务是优先保证可用性A和分区容错性P，比如在MySQL主从同步时，默认就是异步的方式，我们执行一条更新SQL，只需要主节点更新成功就行就对事务进行提交，不需要等待从节点更新数据成功，主节点会异步把SQL发送给从节点。</p>
<p>客户端向zookeeper从节点发送读请求，节点会直接从数据库中找到这个节点的数据然后返回。</p>
<p>客户端向zookeeper从节点发送写请求，节点会将znode路径和数据转发到leader节点，leader会将写请求转换为proposal提案，并且分配一个事务ID zxid，将这个proposal放到每个节点的队列（主节点会给每个从节点分配一个专用队列）中去，然后会根据先进先出的策略，将消息发送给从节点，从节点接收到后会将事务写入到磁盘中去，然后返回ACK响应给主节点，当主节点接收到半数以上的从节点的ACK响应后，主节点会认为这个事务提交成功，完成这个事务提交，同时给所有从节点发送commit消息，从节点接收到消息后，会将这条事务提交。</p>
<p>由此看来zookeeper没法保证客户端读取的都是最新的数据，</p>
<p>所有节点都有两个属性，SID：节点ID，zoo.cfg中配置的myid，ZXID：节点当前的最大事务ID 选举的目的就是选目前所有节点中拥有最大ZXID的节点作为Leader，如果拥有的ZXID相同，就选取SID最大的节点作为Leader。<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220115125322064.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220115135654620.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20220115205539702.jpg" alt></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统总结]]></title>
      <url>/p/80p6r/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>物理地址、逻辑地址、线性地址<br>物理地址：它是地址转换的最终地址，是内存单元真正的地址。如果采用了分页机制，那么线性地址会通过页目录和页表得方式转换为物理地址。如果没有启用则线性地址即为物理地址<br>逻辑地址：在编写c语言的时候，通过&amp;操作符可以读取指针变量本省得值，这个值就是逻辑地址。实际上是当前进程得数据段得地址，和真实的物理地址没有关系。只有当在Intel实模式下，逻辑地址==物理地址。我们平时的应用程序都是通过和逻辑地址打交道，至于分页，分段机制对他们而言是透明得。逻辑地址也称作虚拟地址<br>线性地址：线性地址是逻辑地址到物理地址的中间层。我们编写的代码会存在一个逻辑地址或者是段中得偏移地址，通过相应的计算(加上基地址)生成线性地址。此时如果采用了分页机制，那么吸纳行地址再经过变换即产生物理地址。在Intelk 80386中地址空间容量为4G，各个进程地址空间隔离，意味着每个进程独享4G线性空间。多个进程难免出现进程之间的切换，线性空间随之切换。基于分页机制，对于4GB的线性地址一部分会被映射到物理内存，一部分映射到磁盘作为交换文件，一部分没有映射，通过下面加深一下印象</p>
<p>cache  buffer</p>
<p>磁盘调度算法<br>扫描  最短寻道时间  先到先服务</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络总结]]></title>
      <url>/p/80p6r/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图解HTTP  HTTP权威指南</p>
<p>Integer.toBinaryString(num)<br>很显然&gt;&gt;,&gt;&gt;&gt;的区别是有无符号，相比&gt;&gt;&gt;右移后的无脑补0，&gt;&gt;显然更聪明。在右移时它能判断正负，如果是正则高位补0，负补1；</p>
<p>boolean 几个字节<br>java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了4个字节，和boolean数组1个字节的定义，具体还要看虚拟机实现是否按照规范来，所以1个字节、4个字节都是有可能的。<br><a href="https://blog.csdn.net/qq_40262896/article/details/103309321" target="_blank" rel="noopener">https://blog.csdn.net/qq_40262896/article/details/103309321</a><br>机器数和真值：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a><br>原码 反码 补码</p>
<blockquote>
<p>反码的表示方法是:<br>正数的反码是其本身<br>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</p>
<p>补码的表示方法是:<br>正数的补码就是其本身<br>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
</blockquote>
<p>有符号右移&gt;&gt;（若正数,高位补0,负数,高位补1）</p>
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
<p>x mod y = x - y L x / y J<br>如果a ≡ b (mod m)，c ≡ d (mod m) 那么:<br>(1)a ± c ≡ b ± d (mod m)<br>(2)a <em> c ≡ b </em> d (mod m)</p>
<p>https过程<br>虚拟节点  物理节点  逻辑节点<br>快恢复  快重传<br>传输层流量控制  滑动窗口 可变化</p>
<p>有限广播  直接广播<br>网络地址  主机本身地址  </p>
<p>回送地址   本地软件测试和本机网络应用程序之间通信地址</p>
<p>专用IP地址<br>10.0.0.0-10.255.255.255   1个A类<br>172.16.0.0-172.31.255.255 16个B类<br>192.168.0.0.-192.168.255.255  256个C类</p>
<p>CIDR 无分类编址  网络前缀  主机号<br>路由聚合  构成超网  最长前缀匹配</p>
<p>IP报文格式<br>IP路由选择<br>直接交付  间接交付</p>
<p>ARP<br>DHCP   动态主机配置<br>动态指定ip地址  配置参数<br>广播   dhcp服务器<br>发现  提供  选择</p>
<p>自协议<br>internet控制报文协议   ICMP</p>
<p>差错报文  查询报文</p>
<p>ip无连接协议  没有流量控制  源点抑制<br>ping 测试网络连通性  回显请求  回显应答<br>Tracert程序  测试目的主机路由线路的程序<br>利用TTL值获得目的主机的所有连接路由器</p>
<p>ip 校验和不算数据</p>
<p>internet组管理协议   IGMP<br>单播 广播 多播（UDP   D类ip地址）<br>减少网络资源消耗</p>
<p>伪首部  12字节<br>udp  用户数据报  udp首部不少于8字节<br>不可靠 非连接 不提供端到端确认和重传功能</p>
<p>tcp   字节流服务   tcp首部20字节<br>提供端到端的流量控制  计算和验证端到端检查和 必须</p>
<p>路由表<br>目的网络  掩码  下一跳   接口</p>
<p>以太网  MTU 1500字节</p>
<p>反码算术运算求和 取反码</p>
<p>路由器转发数据报  维持路由表<br>目的ip 网络掩码 下一跳路由器ip地址  指定接口</p>
<p>arp广播发送  ip对应发回MAC   地址解析协议<br>arp高速缓存  arp -a<br>arp代理<br>ip地址和硬件地址映射</p>
<p>目的ip和本子网掩码与看是否和网络一致</p>
<p>DNS<br>顶级  网络信息中心<br>2层  少于12字符<br>域名服务器</p>
<p>缓冲区<br>重复解释<br>递归解释</p>
<p>IMAP POP(脱机程序) IMAP</p>
<p>ftp 基于TCP 两台异构主机间传输文件<br>20端口传数据  21端口传命令<br>主动模式<br>被动模式</p>
<p>origin和referrer<br><a href="https://blog.csdn.net/zdavb/article/details/51161130" target="_blank" rel="noopener">https://blog.csdn.net/zdavb/article/details/51161130</a></p>
<p>origin与referer的区别<br><a href="https://www.cnblogs.com/yanze/p/7919662.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanze/p/7919662.html</a></p>
<p>referer显示来源页面的完整地址，而origin显示来源页面的origin: protocal+host，不包含路径等信息，也就不会包含含有用户信息的敏感内容</p>
<p>referer存在于所有请求，而origin只存在于post请求，随便在页面上点击一个链接将不会发送origin</p>
<p>因此origin较referer更安全，多用于防范CSRF攻击。</p>
<p>http   keep-alive<br><a href="https://blog.csdn.net/xiaoduanayu/article/details/78386508" target="_blank" rel="noopener">https://blog.csdn.net/xiaoduanayu/article/details/78386508</a></p>
<p>http的keep-alive 和TCp的keep-alive<br><a href="https://blog.csdn.net/weixin_37672169/article/details/80283935" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37672169/article/details/80283935</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM总结]]></title>
      <url>/p/80p6q/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>debug              vmoptions<br>step into     f7</p>
<p>java二进制字节码运行环境    native调用操作系统完成任务</p>
<p>一次编写，到处运行<br>自动内存管理，垃圾回收</p>
<p>理解底层原理    定位分析  解决</p>
<p>字节码结构   jvm指令</p>
<p>解释器(翻译成机器码)   JIT即时编译器</p>
<p>每个线程只能有一个活动栈帧   对应正在执行方法<br>栈：线程运行需要内存空间<br>栈帧：每个方法运行时需要的内存    （参数  局部变量  返回地址）   局部变量线程安全   看作用域      基本数据类型？</p>
<p>内存溢出 （栈帧过多  栈帧过大）</p>
<p>线程诊断<br>1 cpu占用高<br>定位<br> top     ps H -eo  pid,tid,%cpu|grep<br>jstack</p>
<p>2 迟迟得不到结果     线程死锁</p>
<p>本地方法栈     调用c,c++方法的空间   像wait  clone等</p>
<p>堆   -Xmx   -Xms<br>堆内存溢出 </p>
<p>jps<br>jmap    某一时刻    jmap -heap    内存快照信息<br>jconsole    实时监测  图形界面  多功能   直观</p>
<p>垃圾回收后内存占用依然很高<br>jvisualvm   堆转储（内存快照）  分析大对象</p>
<p>方法区（概念）   1.6  用堆内存永久代作为方法区    1.8用操作系统内存  元空间    类  类加载器  常量池<br>以前导致永久代内存溢出<br>之后元空间内存溢出</p>
<p>直接内存</p>
<p>String Table</p>
<p>分析GC日志</p>
<p>简历熟悉</p>
<p>一个.java文件在编译后会形成相应的一个或多个Class文件（若一个类中含有内部类，则编译后会产生多个Class文件），但这些Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。事实上，虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的 类加载机制</p>
<p>类加载时机？步骤</p>
<p>垃圾收集器工作流程   场景<br>class类文件结构   字节码指令执行引擎<br>先行发生原则   happen before</p>
<p>as if serial<br>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变</p>
<p>CMS:是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片；</p>
<p>三色标记法  <a href="https://blog.csdn.net/CSDN_WYL2016/article/details/108440494" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_WYL2016/article/details/108440494</a></p>
<p>happens before<br>看书：<br>java并发编程的艺术<br>java多线程编程核心技术<br>图解HTTP<br>图解TCP/Ip<br>spring技术内幕<br>深入浅出MyBatis技术原理与实战<br>redis设计与实现</p>
<p>牛客网刷动态规划</p>
<p>gc日志<br>cpu占用<br>jstat可以打印出当前JVM运行的各种状态信息</p>
<p>jstack可以生成当前JVM的线程快照，也就是当前每个线程当前的状态及正在执行的方法，锁相关的信息<br>jstack -l 进程id</p>
<p>jmap<br>这个命令可以生成当前堆栈快照。使用 jmap -heap 进程id可以打印出当前堆各分区内存使用情况的情况，新生代(Eden区,To Survivor区,From Survivor区)，老年代区的内存使用情况。</p>
<p>jmap -histo 进程id 打印出当前堆中的对象统计信息，包括类名，每个类的实例数量，总占用内存大小。</p>
<p>执行jvisualvm命令打开使用Java自带的工具Java VisualVM来打开堆栈快照文件，进行分析。可以用于排查内存溢出，内存泄露问题 在Java VisualVM里面可以看到每个类的实例对象占用的内存大小，以及持有这个对象的实例所在的类等等信息。</p>
<p>也可以配置启动时的JVM参数，让发送内存溢出时，自动生成堆栈快照文件。</p>
<p>使用jmap -dump:format=b,file=/存放路径/heapdump.hprof 进程id就可以得到堆转储文件，然后执行jvisualvm命令就可以打开JDK自带的jvisualvm软件</p>
<p>MAT主要可以用于分析内存泄露，可以查询dump堆转储文件中的对象列表，以及潜在的内存泄露的对象。hprof文件，主页会展示潜在的内存泄露问题</p>
<p>卡表 rememberset  跨代引用<br><a href="https://www.cnblogs.com/hongdada/p/14578950.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongdada/p/14578950.html</a></p>
<p>类加载过程<br><a href="https://blog.csdn.net/u010942465/article/details/81709246" target="_blank" rel="noopener">https://blog.csdn.net/u010942465/article/details/81709246</a></p>
<p>文件格式验证（符合class文件格式规范）、元数据验证（语法）、字节码验证（语义）和符号引用验证</p>
<p>准备阶段是证实为类变量分配内存并且设置初始化值的阶段<br>这个阶段进行初始化的数据只有静态字段，并且是赋值初始化值(final修饰的字段除外)</p>
<p>初始化阶段是类加载过程的最后一步，这个阶段才开始真正的执行用户定义的Java程序。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则需要为类变量(非final修饰的类变量)和其他变量赋值，其实就是执行类的<clinit>()方法</clinit></p>
<p>在Java语言体系中，<clinit>()不是一个合法变量，这个方法也不是由用户显示定义的，是由编译器生成的，编译器在编译阶段会自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合并而成的，编译器收集的顺序是由语句的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在静态语句块之后的变量，可以赋值，但是不能访问。</clinit></p>
<p><clinit>()方法对于类和接口来说不是必须的，如果类或接口中没有定义类变量，也没有静态语句块，那么编译器将不为这个类或者接口生成<clinit>()方法，如果类或者接口中生成了<clinit>()方法，那么这个方法在执行过程中，虚拟机会保证在多线程环境下的线程安全问题。</clinit></clinit></clinit></p>
<p>操作码 操作数</p>
<p>增量更新：黑色对象新增一条指向白色对象的引用，那么要进行深入扫描白色对象及它的引用对象。</p>
<p>原始快照：灰色对象删除了一条指向白色对象的引用，实际上就产生了浮动垃圾，好处是不需要像 CMS 那样 remark，再走一遍 root trace 这种相当耗时的流程。</p>
<p>SATB可能造成更多的浮动垃圾</p>
<p>GC调优</p>
<p>select和poll</p>
<p>继承树，底层数据结构，线程安全，执行效率</p>
<p>ArrayList  并发修改 ConcurrentModificationException异常   默认会是10</p>
<p>SynchronizedList   CopyOnWriteArrayList</p>
<p>如果不指定初始容量，HashMap和ConcurrentHashMap默认会是16，HashTable的容量默认会是11    </p>
<p>LinkedHashMap</p>
<p>expectedModCount</p>
<p>一致性hash</p>
<p> 所以有了一致性hash，一致性hash就是创建出n个虚拟节点，n个虚拟节点构成一个环，从n个虚拟节点中，挑选出一些节点当成真实的upstream server节点。构成一个每次将计算得到的hash%n，得到请求分配的虚拟节点的位置c，从位置c顺时针移动，获得离c最近的真实upstream server节点。</p>
<p>这样请求分配时就会比较均匀，而且upstream server的数量变化只会影响计算出key值hash与其”最近”的预分配的虚拟节点。</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多线程]]></title>
      <url>/p/80p61/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线程池状态 5种<br>running shutdown stop tidying terminated</p>
<p>4种拒绝策略  7个阻塞队列</p>
<p>execute()：只能执行 Runnable 类型的任务。<br>submit()：可以执行 Runnable 和 Callable 类型的任务。</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql体系结构和存储引擎]]></title>
      <url>/p/80oue/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>frm 表结构<br>插件式表存储引擎<br>实例（数据库后台进程/线程和一个共享内存区 ）<br>和数据库（frm myi myd ibd）</p>
<p>启动实例会读取配置文件，根据配置文件参数启动数据库实例</p>
<p>存储引擎基于表 而不是数据库<br>oltp 在线事务处理</p>
<p>MVCC获得高并发性  实现4种隔离级别</p>
<p>插入缓冲（性能）  二次写（可靠性）  自适应哈希索引  预读</p>
<p>没有定义表主键 6字节ROWID  作为主键</p>
<p>myisam  全文索引   olap  在线分析处理   myisampack用哈夫曼算法压缩   4G  256T   全文索引</p>
<p>NDB集群存储引擎   高可用  数据全放在内存中  查询速度不行</p>
<p>Memory(heap)  数据放在内存   临时表  哈希索引  表锁 不支持TEXT,BLOB </p>
<p>Archive 只支持insert,select   存储归档数据，如日志   行锁实现高并发操作<br>show engines</p>
<p>连接数据库操作 连接进程和数据库实例通信   权限表user</p>
<p>Innodb  高性能 高可用 高可扩展存储引擎</p>
<p>INnodb存储引擎后台线程7个  4个IO 1个master（4个循环） 1个锁监控 1个错误监控线程</p>
<p>内存（缓冲池  重做日志缓冲池  内存池）</p>
<p>Innodb plugin</p>
<p>Innodb存储引擎文件<br>重做日志文件  表空间文件  ibd  由段，区(64个连续页  1MB)，页*（16kb)组成</p>
<p>面向行 </p>
<p>聚集索引  非聚集索引</p>
<p>一致性非锁定读3<br>for update 加X锁<br>lock in share mode 加S锁</p>
<p>begin</p>
<p>start transaction </p>
<p>行锁算法<br>记录锁<br>间隙锁<br>next-key</p>
<p>undo段位于共享表空间</p>
<p>事务控制语句<br>begin<br>start tarnsaction<br>commit<br>rollback</p>
<p>隔离级别越低  事务请求锁越少，保持锁时间越短</p>
<p>分布式事务   XA<br>多个资源管理器  一个事务管理器  一个应用程序</p>
<p>set autocommit=0  设置事务不自动提交</p>
<p>高性能mysql<br>changebuffer<br>redo log数据页更改   prepare  commit   checkpoint<br>binlog  sql语句<br>MVCC   解决幻读<br>每一行数据中额外保存两个隐藏的列<br>插入或上次更新该行的事务ID(删除也被认为是一次更新，只不过在代表删除的更新操作中，行中的特殊位被设置为将其标记为已删除。这个事务ID可以认为是数据行的修改版本号。)</p>
<p>回滚指针(指向undo log中用于事务回滚的日志记录)。</p>
<p>幻读就是事务执行过程中，在查询一个范围的数据时，有新的数据插入到这个范围，导致两次查询的数据不一致。因为读分为快照读和实时读，</p>
<p>快照读</p>
<p>我们普通的SELECT语句都是普通读，也就是读取的数据都是事务开始时那个状态的数据，普通读的幻读问题主要是通过MVCC来解决的，具体可以看上面的MVCC中的查询操作。</p>
<p>实时读</p>
<p>SELECT <em>*</em> FOR UPDATE 在查询时会先申请X锁</p>
<p>SELECT <em>*</em>lock IN SHARE MODE 在查询时会先申请S锁</p>
<p>就是实时读，就是读取的是实时的数据，而不快照数据，读的时候会加Next-Key Lock锁住当前的记录，以及左右两个区间的间隙，这样在读的时候就不能往我们的查询范围插入数据了。</p>
<p>MVCC实现原理</p>
<p>意向锁减小性能开销</p>
<p>关于or查询的真相是：<br>所谓的索引失效指的是：假如or连接的俩个查询条件字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描。</p>
<p>联合索引是聚集索引吗<br>什么是覆盖索引</p>
<p>聚集索引是指索引序列与表中行的排列顺序一致,组合索引是指建立在多列上的索引.</p>
<p>索引没有被采用？<br>1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个 。</p>
<p>哪些情况需要建索引：</p>
<p>主键，唯一索引<br>经常用作查询条件的字段需要创建索引<br>经常需要排序、分组和统计的字段需要建立索引<br>查询中与其他表关联的字段，外键关系建立索引<br>哪些情况不要建索引？<br>表的记录太少，百万级以下的数据不需要创建索引</p>
<p>经常增删改的表不需要创建索引</p>
<p>数据重复且分布平均的字段不需要创建索引，如 true,false 之类。</p>
<p>频发更新的字段不适合创建索引</p>
<p>where条件里用不到的字段不需要创建索引</p>
<p>跨库分页查询</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<p>在线热备份？</p>
<p>join工作流程</p>
<p>exists是拿外表作为驱动表，外表的数据做循环，每次循环去内表中查询数据，使用适内表比较大的情况</p>
<p>Simple Nested-Loop Join：SNLJ，简单嵌套循环连接 Index Nested-Loop Join：INLJ，索引嵌套循环连接 Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接 在选择Join算法时，会有优先级，理论上会优先判断能否使用INLJ、BNLJ： Index Nested-LoopJoin &gt; Block Nested-Loop Join &gt; Simple Nested-Loop Join</p>
<p>而 join的话正好相反，是那内表作为驱动表，内表的数据做循环，每次循环去外表查询数据，适合内表比较小的情况。</p>
<p>join的实现其实是先从一个表中找出所有行（或者根据where子句查出符号条件的行)，然后去下一个表中循环寻找匹配的行，依次下去，直到找到所有匹配的行，使用join不会去创建临时表，使用in的话会创建临时表，销毁临时表</p>
<p>所以不管是in子查询，exists子查询还是join连接查询，底层的实现原理都是一样的，本质上是没有任何区别的，关键的点在关联表的顺序，如果是join连接查询，MySQL会自动调整表之间的关联顺序，选择最好的一种关联方式。和上面in和exists比较的结论一样，小表驱动大表才是最优的选择方式。</p>
<p>相比于AV树（也就是自平衡的二叉查找树，左右子树高度差不超过1），红黑树插入，删除效率更高。因为不需要保证绝对的平衡，任何不平衡需要的旋转次数不超过3次，即便在最坏的情况下，红黑树能够以O(log(N))的时间复杂度进行搜索、插入、删除操作。</p>
<p>红黑树最长 红黑交替  最短全黑</p>
<p>分库分表 超过1000万</p>
<blockquote>
<p>垂直<br>根据业务，来对表进行拆分成不同的表，或者根据使用频率，将常用的列分在一个表里面，将不常用的列分在一个表里面。</p>
<p>水平</p>
</blockquote>
<p>检验数据一致性</p>
<p>bin log格式   SBR  RBR    MBR</p>
<blockquote>
<p>慢查询优化</p>
</blockquote>
<p>explain+SELECT语句执行，查看结果</p>
<p>索引创建过程<br>MySQL接受到创建索引的命令后，会进行创建索引</p>
<p>Fast Index Creation<br>在MySQL 5.5之前创建索引主要是通过</p>
<p>1.创建临时表，表结构是添加索引后的表结构</p>
<p>2.将原表数据导入到临时表</p>
<p>3.删除原表</p>
<p>4.将临时表重命名成原来的表名</p>
<p>Innodb在1.0之后支持Fast Index Creation，就是添加辅助索引（主键以外的索引），不需要重建表，只需要对表加S锁（加锁期间表只能读，不能写），然后创建索引，对主键加索引还是需要重建表。</p>
<p>Online DDL<br>就是innodb在创建索引时，会将数据库的增删改命令写入缓存日志，创建完毕后通过重放日志来保持数据库的最终一致性。</p>
<p>token会过期吗   有效期</p>
<p>什么是Nested-Loop Join？ 2.Index Nested-Loop Join怎么优化连接？ 3.Block Nested-Loop Join怎么优化连接？</p>
<p>验证码实现   jwt实现</p>
<p>cookie缺点：<br>数据存储在客户端，存在安全隐患<br>cookie存储大小、类型存在限制<br>数据存储在cookie中，如果一次请求cookie过大，会给网络增加更大的开销</p>
<p>char 存储空间浪费<br>varchar  1个字节存长度  当长度大于255时，使用两个字节来存储长度</p>
<p>索引下推<br><a href="https://blog.csdn.net/luxiaoruo/article/details/106637231" target="_blank" rel="noopener">https://blog.csdn.net/luxiaoruo/article/details/106637231</a></p>
<p>链接：<a href="https://pan.baidu.com/s/1vowXHwoDNfYM8-7hn_HBkw" target="_blank" rel="noopener">https://pan.baidu.com/s/1vowXHwoDNfYM8-7hn_HBkw</a><br>提取码：java</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http学习]]></title>
      <url>/p/80o51/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>time_wait close_wait  <a href="https://www.cnblogs.com/cangqinglang/p/13185825.html" target="_blank" rel="noopener">https://www.cnblogs.com/cangqinglang/p/13185825.html</a><br>http  不做持久化处理  无状态（stateless）协议<br>请求行（请求方法 url 协议版本）<br>请求头 请求体</p>
<p>响应行（协议版本 状态码 状态描述）<br>响应头 响应体</p>
<p>HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 Cookie 技术</p>
<p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功 能，在互联网上任意位置的资源都能访问到</p>
<p>GET ：获取资源   304 Not Modified</p>
<p>POST：传输实体主体    </p>
<p>PUT：传输文件  不安全  REST（REpresentational State Transfer，表征状态转移）  204 No Content</p>
<p>HEAD：获得报文首部   HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等</p>
<p>DELETE：删除文件</p>
<p>OPTIONS：询问支持的方法</p>
<p>TRACE：追踪路径  TRACE方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。  (容易引发 XST（Cross-Site Tracing，跨站追踪）攻击 不常用)<br>客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理 中转，TRACE 方法就是用来确认连接过程中发生的一系列操作</p>
<p>CONNECT：要求用隧道协议连接代理<br>与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容 加 密后经网络隧道传输</p>
<blockquote>
<p>使用浏览器浏览一个包含多张图片的 HTML页面时，在发送 请求访问 HTML页面资源的同时，也会请求该 HTML页面里包含的 其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断 开，增加通信量的开销</p>
</blockquote>
<p>在 HTTP/1.1 协议中存在一个问题：单个 TCP 连接在一个时刻只能处理一个请求<br>HTTP2 提供了 Multiplexing 多路传输特性，让我们可以在一个 TCP 连接中同时完成多个 HTTP 请求</p>
<p>假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输。</p>
<p>当浏览器拿到一个有几十张图片的网页该怎么办呢？</p>
<p>肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受。但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了——要是有 1000 张图片的话总不能开 1000 个 TCP 连接吧。</p>
<p>所以浏览器允许我们对同一 host 开启多个 TCP 连接，每个浏览器的数量是不一样的。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。</p>
<p>如果是「短连接」，那么一次 TCP 连接就只能对应一次 HTTP 请求；<br>如果是「长连接」，那么一次 TCP 连接就可以发送多个 HTTP 请求了</p>
<p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从 前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术 出现后，不用等待响应亦可直接发送下一个请求</p>
<blockquote>
<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态<br>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息</p>
</blockquote>
<p>用于 HTTP 协议交互的信息被称为 HTTP 报文</p>
<p>请求首部字段<br>通用首部字段<br>实体首部字段</p>
<p>响应首部字段<br>通用首部字段<br>实体首部字段</p>
<p>报文主体和实体主体的差异  ？？？</p>
<p>压缩传输的内容编码 gzip（GNU zip） compress（UNIX 系统的标准压缩） deflate（zlib） identity（不进行编码）</p>
<p>MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制</p>
<p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</p>
<p>204 No Content  请求处理成功，但没有资源返回</p>
<p>206 Partial Content<br>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<p>400 Bad Request<br>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求 的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态 码。</p>
<p>401 Unauthorized<br>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示 用 户认证失败。</p>
<p>403 Forbidden<br>请求资源的访问被服务器拒绝</p>
<p>404 Not Found<br>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用</p>
<p>500 Internal Server Error<br>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p>
<p>503 Service Unavailable<br>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<p>请求报文首部字段  含有内容协商</p>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容</p>
<p>首部字段名: 字段值<br>在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型</p>
<p>当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时 会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑 的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的 首部字段，而有些则会优先处理最后出现的首部字段。</p>
<p>实体标记（ETag）</p>
<p>End-to-end 首部和 Hop-by-hop 首部</p>
<p>缓存服务器   Cache-Control: private</p>
<p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源<br>Date 表明创建 HTTP 报文的日期和时间。</p>
<p>HTTP/1.1 的传输编码方式仅对分块传输编码有效</p>
<p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文 的传输路径。</p>
<blockquote>
<p>通信数据转发程序 ：代理、网关、隧 道</p>
</blockquote>
<p>请求首部字段<br>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。</p>
<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。</p>
<p>首部字段 Referer 会告知服务器请求的原始资源的 URI</p>
<p>User-Agent 用于传达浏览器的种类</p>
<p>响应首部字段<br>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源<br>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值 的单位为秒。</p>
<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程 序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版 本号和安装时启用的可选项</p>
<p>405 Method Not Allowed</p>
<p>对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段</p>
<p>Cookie 的工作机制是用户识别及状态管理</p>
<p>响应首部字段    Set-Cookie<br>请求首部字段    Cookie</p>
<p>仅在 HTTPS 安全通信时才会发送 Cookie<br>HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问</p>
<p>HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。</p>
<blockquote>
<p>HTTP 主要有这些不足，例举如下。 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改</p>
</blockquote>
<p>通信线路加密  通信内容加密</p>
<p>确认通信方（服务器或客户端）持有的证书， 即可判断通信方的真实意图</p>
<p>MD5 和 SHA-1 等散列值校验的方法， 以及用来确认文件的数字签名方法</p>
<p>HTTP+ 加密 + 认证 + 完整性保护 =HTTPS</p>
<p>SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应 用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是 当今世界上应用最为广泛的网络安全技术。</p>
<p>https通信过程 第7章<br>web攻击技术<br>简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会 成为攻击的对象。应用 HTTP 协议的服务器和客户端，以及运行在服 务器上的 Web 应用等资源才是攻击目标</p>
<p>请求内容主要用于POST请求，与POST请求方法配套的请求头一般有Content-Type（标识请求内容的类型）和Content-Length（标识请求内容的长度）</p>
<p>在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度</p>
<p>HTTP/2协议定义了两个字符串标识符：“h2”表示加密的HTTP/2，“h2c”表示明文的HTTP/2。</p>
<p>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</p>
<p>tcp_keepalive_time默认是2个小时，也就是TCP空闲连接可以存活2个小时，在close_wait状态下，可以把这个时间调小，减少处于close_wait连接的数量</p>
<p>在高并发短连接的业务场景下，由于短连接的传输数据+业务处理的时间很短，所以服务器处理完请求就会立即主动关闭连接，并且进入TIME_WAITING状态，而端口处于有个0~65535的范围中，除去系统占用的，总的数量有限。所以持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分请求服务。 可以通过修改TCP的默认配置来改善这个问题。</p>
<p>慢启动  拥塞避免时  慢启动阈值变为拥塞窗口一半 拥塞窗口变为1 慢启动</p>
<p>快恢复  拥塞避免时  慢启动阈值变为拥塞窗口一半 拥塞窗口变为慢启动阈值  后期+1 拥塞避免 线性增长</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wireshark网络分析就这么简单]]></title>
      <url>/p/80nye/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>缓冲和缓存 <a href="https://www.cnblogs.com/mlgjb/p/7991903.html" target="_blank" rel="noopener">https://www.cnblogs.com/mlgjb/p/7991903.html</a><br><a href="https://www.cnblogs.com/wish123/p/9145628.html" target="_blank" rel="noopener">https://www.cnblogs.com/wish123/p/9145628.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>/p/80mzy/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://c.biancheng.net/view/1343.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1343.html</a><br>代码维护复杂、可扩展性差<br>5个原则1法则<br>作者：量变会有质变<br>链接：<a href="https://www.nowcoder.com/discuss/794965?type=0&amp;order=0&amp;pos=46&amp;page=0&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;gio_id=ED2A9F5EF9CA9E3948BB79B1034A529C-1636117286125" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/794965?type=0&amp;order=0&amp;pos=46&amp;page=0&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;gio_id=ED2A9F5EF9CA9E3948BB79B1034A529C-1636117286125</a><br>来源：牛客网</p>
<p>1、面向对象设计原则：<br>①单一职责原则<br>定义：<br>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。<br>单一职责原则是实现高内聚、低耦合的指导方针，是最简单却最难运用的原则，需要设计人员发现类的不同职责并将其分离。</p>
<p>②开闭原则<br>定义：<br>软件实体应当对扩展开放，对修改关闭。<br>指软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
<p>③里氏替换原则<br>定义：<br>所有引用基类的地方必须能透明地使用其子类的对象。<br>里氏替换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。<br>在运用里氏替换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现在父类中声明的方法。</p>
<p>④依赖倒转原则<br>定义：<br>高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。<br>依赖倒转原则要求：要针对接口编程，不要针对实现编程。</p>
<p>⑤接口隔离原则<br>定义：<br>客户端不应该依赖那些它不需要的接口。<br>在使用接口隔离原则的时候，需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来不方便。</p>
<p>⑥合成复用原则<br>定义：<br>优先使用对象组合，而不是继承来达到复用的目的。<br>一般而言，如果两个类之间是”Has-A”关系应使用组合或聚合，如果是”Is-A”关系可使用继承。</p>
<p>⑦迪米特法则-又称最少知识原则<br>定义：<br>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。<br>2、开闭原则：AOP与动态代理？<br>3、依赖倒转原则与接口隔离原则：IOC（工厂模式）？<br>仅供个人学习使用，部分内容尚有待进一步确认。</p>
<blockquote>
<p>依賴 虚线箭头</p>
<p>关联 单向关联，自身关联和双向关联   实线箭头<br>聚合/聚集(aggregation)关系 聚合是关联关系的一种特例</p>
<p>组合也是关联关系的一种特例，体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合</p>
<p>泛化(generalization)关系  继承实现</p>
<p>实现(realization)关系  实现是一种类与接口的关系 泛化和实现的区别就在于子类是否继承了父类的实现，如有继承则关系为泛化，反之为实现。</p>
<p>几种关系所表现的强弱程度依次为：泛化/实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p>
</blockquote>
<p>根据其目的（模式是用来做什么的）可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种：<br>创建型模式主要用于创建对象。<br>结构型模式主要用于处理类或对象的组合。<br>行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。</p>
<p>根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种：<br>类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。<br>对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性</p>
<p>创建型模式(Creational Pattern)关注的是对象的创建，将创建对象(类的实例化)的过程进行了抽象和封装，分离了对象创建和对象使用</p>
<p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式</p>
<p>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式</p>
<p>原型模式来复制一个对象的自身，从而克隆出多个与原型对象一模一样的对象<br>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象</p>
<p>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="literal">null</span>;  <span class="comment">//静态私有成员变量</span></span><br><span class="line">	<span class="comment">//私有构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;	&#125;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//静态公有工厂方法，返回唯一实例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">		    instance=<span class="keyword">new</span> Singleton();	</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式</p>
<p>现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的</p>
<p>类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法</p>
<p>如果软件系统中某个类存在两个独立变化的维度，通过桥接模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”</p>
<blockquote>
<p>组合模式  树形结构（操作系统中的目录结构、应用软件中的菜单、办公系统中的公司组织结构）</p>
<p>组合模式又可以称为“整体-部分”(Part-Whole)模式，属于对象结构型模式，它将对象组织到树结构中，可以用来描述整体与部分的关系</p>
</blockquote>
<p>Component   Leaf  Composite</p>
<blockquote>
<p>在软件设计中，一般有两种方式可以实现给一个类或对象增加行为（新功能）：<br>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。<br>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)。</p>
<p>装饰器使用对象之间的关联关系取代类之间的继承关系，在装饰器中既可以调用原有类的方法，还可以增加新的方法，以扩充原有类的功能。它通过一种无须定义子类的方式来给对象动态增加职责，符合合成复用原则。</p>
<p>抽象装饰类，它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p>
<p>享元模式通过共享技术实现相同或相似对象的重用。</p>
<p>在享元模式中可以共享的相同内容称为内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。<br>在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象。 </p>
<p>享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</p>
<p>代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式</p>
<p>代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，后面将学习这些不同的代理形式。</p>
<p>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化</p>
<p>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。<br>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</p>
<p>类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。<br>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。</p>
<p>责任链模式 Java中的异常处理机制   Web过滤器(Filter)链</p>
<p>命令模式 请求的发送者   接收者<br>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</p>
</blockquote>
<p>命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法</p>
<blockquote>
<p>解释器模式<br>抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符和非终结符类。<br>在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一个语法规则，使得系统具有较好的扩展性和灵活性。 </p>
<p>聚合类(Aggregate Classes)，对应的对象称为聚合对象。<br>聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。<br>将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责原则”的要求。<br>同时还可以灵活地为聚合对象增加不同的遍历方法，还可以访问一个聚合对象中的元素但又不需要暴露它的内部结构。</p>
</blockquote>
<p>具体聚合类作为抽象聚合类的子类，一方面负责存储数据，另一方面实现了在抽象聚合类中声明的工厂方法createIterator()，用于返回一个与该具体聚合类对应的具体迭代器对象</p>
<blockquote>
<p>备忘录模式：需要保存内部状态的类设计为原发器<br>原发器 备忘录类 负责人类（它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节）</p>
<p>观察者模式是使用频率最高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。<br>subject observer</p>
<p>Subject：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。</p>
</blockquote>
<p>具体观察者中维护一个指向具体目标对象的引用</p>
<blockquote>
<p>为了更好地对这些具有多种状态的对象进行设计，我们将学习用于描述对象状态及其转换的状态模式。<br>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。<br>状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化<br>论坛用户等级   银行账户</p>
<p>模板方法模式(Template Method Pattern)：定义一个操作中算法的框架，而将一些步骤延迟到子类中  类行为型模式</p>
</blockquote>
<p>基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)</p>
<p>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[联合索引最左匹配]]></title>
      <url>/p/80msf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>mysql组件组成：<a href="https://www.jianshu.com/p/5b60de98332b" target="_blank" rel="noopener">https://www.jianshu.com/p/5b60de98332b</a><br><img src="/images/mysql.jpg" alt="mysql组件组成"><br>Server层 ：连接器，查询缓存，分析器，优化器，执行器<br> 存储引擎</p>
<blockquote>
<p>连接器管理着连接的创建，维持和管理以及权限验证<br>输入的ip和port没有问题，Client会和Mysql进行经典的TCP三次握手。接着会进行权限验证<br>权限表查权限<br>权限的验证是在连接建立时进行的，之后即使你修改该用户的权限，也不会起作用。新建立的连接才会使用新的权限。<br>联合索引最左匹配<br>联合索引是由非聚簇索引组成的。非聚簇索引区分 InnoDB 和 MyISAM 储存引擎时，包含的东西是不一样的</p>
</blockquote>
<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<blockquote>
<p>查询缓存:key-value形式 8.0后删除  很容易失效</p>
<p>分析器:   词法分析<br>覆盖索引<br>假设有联合索引 idx1(a,b,c)</p>
</blockquote>
<p>下面的SQL可完整用到索引。<br>1.SELECT … WHERE b=? AND c=? AND a=?;<br>2.SELECT … WHERE b=? AND a=? AND c=?;<br>3.SELECT … WHERE a=? AND b IN(?,?) AND c=?;<br>4.SELECT … WHERE a=? AND b=? ORDER BY c;<br>5.SELECT … WHERE a=? AND b IN(?,?) ORDER BY c;<br>6.SELECT … WHERE a=?  ORDER BY b,c;<br>7.SELECT … ORDER BY a,b,c;</p>
<p>而下面几个SQL则只能用到部分索引，或者可利用到ICP特性（5.6起）<br>1.SELECT …WHERE b=? AND a=? —只能用到(a,b)部分。<br>2.SELECT …WHERE a IN (?,?) AND b=?; —只用到(a,b) 部分，同时有ICP。<br>3.SELECT …WHERE (a BETWEEN ? AND ?) AND b=?; —只用到(a,b) 部分，同时有ICP。<br>4.SELECT …WHERE a=? AND b IN (?,?); —只用到(a,b)部分，同时有ICP。<br>5.SELECT …WHERE a=? AND (b BETWEEN ? AND ?) AND c=?; —可用到(a,b,c)整个索引，同时有ICP。<br>6.SELECT …WHERE a=? AND c=?；—只用到(a)部分索引，同时有ICP。<br>7.SELECT …WHERE a=? AND c&gt;=?；—只用到(a)部分索引，同时有ICP。</p>
<p>ICP（index condition pushdown）是MySQL5.6的新特性，其机制会让索引的其他部分也参与过滤，减少引擎层和server层之间的数据传输和回表请求，通常情况下可大幅提升查询效率。</p>
<p>下面几个SQL完全用不到索引<br>1.SELECT …WHERE b=?;<br>2.SELECT …WHERE b=? AND c=?;<br>3.SELECT …WHERE b=? AND c&gt;=?;<br>4.SELECT …ORDER BY b;<br>5.SELECT …ORDER BY b,a;</p>
<p>https原理及流程：<br><a href="https://www.jianshu.com/p/14cd2c9d2cd2" target="_blank" rel="noopener">https://www.jianshu.com/p/14cd2c9d2cd2</a></p>
<p>sql四大排名函数解析<br>row_number()：依次递增排名，无重复排名<br>rank()：相同分数有重复排名，但是重复后下一个人按照实际排名<br>dense_rank()：分数一致排名一致，分数不一致排名+1<br>NTILE(4)：分组排名，里面的数字是几，最多排名就是几，里面的数字是4，最多的排名就是4</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kmp算法求next数组]]></title>
      <url>/p/80mgt/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>朴素匹配算法   leetcode 28<br>在这里存在一个问题，回溯到下一位置可能导致很多多余比较操作</p>
<p>母串：ABABABABACABCAB<br>样本串：ABABABC<br>在上述比较中，进行多次多余回溯操作（多次比较无意义）</p>
<p>母串：ABABABABACABCAB<br>样本串：ABABABC<br>// 这里位置不是按数组0位开始。<br>第一次比较在第7位发现与母串不同，那么我们肉眼观察下，下一次比较为<br>ABABABABACABCAB<br>    ABABABC<br>这样最为合理（即母串的第7位与样本串的第5位进行比较）。<br>那么为什么选择该回溯位置？？</p>
<p>样本串 ABABABC 假如与未知字符串比较，那么求出当未知字符串第i位匹配不同时，样本串与未知字符串第i位重新比较的位置，即为样本串的next数组。</p>
<p>怎么求出其对应的next数组？</p>
<p>样本串 ABABABC，如果第5个位置与未知字符串不同，那么前4位为 ABAB ， （此处可以理解为样本串后移）后移几位合适？后移则是比较前缀和后缀是否相同，其最大公共前后缀的长度几位下一次比较的样本串的位置。</p>
<p>问题转化为求取样本串的当前位置之前的最大公共前后缀的长度（next数组），也是KMP算法的核心部分。</p>
<p>A B A B A B C 的next数组。<br>0 0 0 1 2 3 4</p>
<p>class Solution {</p>
<pre><code>/**
 * 寻找最长公共前缀后缀的长度
 * 示例：ABABCABAB
 * 前缀集合（不包含示例本身）：A, AB, ABA, ABAB, ABABC, ABABCA, ABABCAB, ABABCABA
 * 后缀集合（不包含示例本身）：B, AB, BAB, ABAB, CABAB, BCABAB, ABCABAB, BABCABAB
 * 最长公共前缀后缀为，ABAB；返回4
 * @param needle 传入字符串
 * @return 最长公共前缀后缀的长度
 */
public static int publicPrefix(String needle) {
    int length = needle.length();
    int result = length - 1;
    while(result &gt; 0){
        int i = 0;
        while (needle.charAt(i) == needle.charAt(length - result + i)){
            i++;
            if(i == result){
                return result;
            }
        }
        result--;
    }
    return result;
}

public int strStr(String haystack, String needle) {
    if(needle.isEmpty()){
        return 0;
    }
    if(haystack.length() &lt; needle.length()){
        return -1;
    }
    /**
     * KMP算法
     * 第一步获取needle的next数组
     **/
    int[] next = new int[needle.length()];
    next[0] = 0;
    for(int i = 1; i &lt; next.length; i++){
        next[i] = publicPrefix(needle.substring(0,i));
    }
    // 遍历母字符串
    // haystack下标指针
    int i = 0;
    int j = 0;
    boolean isExist = false;
    while(i &lt;= haystack.length() - 1){
        if(haystack.charAt(i) != needle.charAt(j)){
            if(j == 0){
                i++;
            }
            j = next[j];
        } else {
            if (j == next.length - 1) {
                isExist = true;
                break;
            } else {
                i++;
                j++;
            }
        }
    }
    int result = isExist ? i -j : -1;
    return result;
}
</code></pre><p>}</p>
<p>class Solution {<br>    public boolean repeatedSubstringPattern(String s) {<br>        return kmp(s + s, s);<br>    }</p>
<pre><code>public boolean kmp(String query, String pattern) {
    int n = query.length();
    int m = pattern.length();
    int[] fail = new int[m];
    Arrays.fill(fail, -1);
    for (int i = 1; i &lt; m; ++i) {
        int j = fail[i - 1];
        while (j != -1 &amp;&amp; pattern.charAt(j + 1) != pattern.charAt(i)) {
            j = fail[j];
        }
        if (pattern.charAt(j + 1) == pattern.charAt(i)) {
            fail[i] = j + 1;
        }
    }
    int match = -1;
    for (int i = 1; i &lt; n - 1; ++i) {
        while (match != -1 &amp;&amp; pattern.charAt(match + 1) != query.charAt(i)) {
            match = fail[match];
        }
        if (pattern.charAt(match + 1) == query.charAt(i)) {
            ++match;
            if (match == m - 1) {
                return true;
            }
        }
    }
    return false;
}
</code></pre><p>}</p>
<p>BM算法</p>
<p>散列表：<br>直接定值法</p>
<p>解决哈希冲突<br>1 开放定值法    线性探测  二次探测<br> 线性探测和二次探测必须考虑载荷因子，超过0.7-0.8就增容，增大效率，（以空间换时间）<br>其中删除是惰性删除，也就是只标记删除记号，实际操作则待表格重新整理时再进行，因为HashTable中的每一个元素不仅代表自己，也关系到其他元素。</p>
<p>删除：空散列表标志位true  存入新元素标志FALSE  删除元素不改变标志位，元素关键词设为“neverUserd”<br>初始时标志位true（查找） 关键词neverUserd （插入）<br>2 拉链法</p>
<p><a href="https://blog.csdn.net/qq_42764468/article/details/108572936" target="_blank" rel="noopener">!事务实现</a></p>
<p>CyclicBarrier reset 重复使用 全部等待<br>countdownlatch 1个线程等待其他线程执行完成并发出通知</p>
<p>volatile和CAS结合  原子类<br>ABA  变量原子性 不能保证代码块原子性</p>
<p>ReadWriteLock   读写分离锁<br>读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、<br>写和写之间才会互斥，提升了读写的性能</p>
<p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数</p>
<p>同步的范围越小越好。  范围外异步执行</p>
<p>Executors框架</p>
<p>有符号数  无符号数</p>
<p>栈空间用光了会引发 StackOverflowError，而堆和常量<br>池空间不足则会引发 OutOfMemoryError</p>
<p>-128-127   Integer是否创建新对象  IntegerCache内部类  </p>
<blockquote>
<p>运行时常量池 String类的 intern()方法就是这样的。</p>
<p>JIT编译器发展 逃逸分析 对象一定分配在堆上这件事情已经变得不那么绝对了<br>栈上分配 标量替换</p>
</blockquote>
<p>四舍五入的原理是在参数上加 0.5 然后进行下取整</p>
<p>关联关系（Has-A）和依赖关系（Use-A）继承关系（Is-A）</p>
<p>char 2个字节</p>
<blockquote>
<p>加载：class文件-&gt;内存 生成Class对象<br>验证<br>准备 （静态变量分配内存 初始化）<br>解析（将符号引用替换为直接引用）<br>初始化  有父类先初始化父类 执行初始化语句 类加载器</p>
</blockquote>
<p><a href="https://baijiahao.baidu.com/s?id=1715222351753027085&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1715222351753027085&amp;wfr=spider&amp;for=pc</a></p>
<blockquote>
<p>Error通常是程序无法处理的错误，这些错误大多数与代码编写者执行的操作无关，并且它们是无法被捕获的，因为它们在应用程序的控制和处理能力之外，比如。<br>OutOfMemoryError, 内存溢出，比较常见的错误，是值内存空间不足以再提供新对象的分配。<br>StackOverflowError，栈溢出。<br>虚拟机栈：如果线程请求的栈深度大于虚拟机栈所允许的深度，将会出现StackOverflowError异常；如果虚拟机动态扩展无法申请到足够的内存，将出现OutOfMemoryError。<br>本地方法栈和虚拟机栈一样。<br>堆：Java 堆可以处于物理上不连续，逻辑上连续，就像我们的磁盘空间一样，如果堆中没有内存完成实例分配，并且堆无法扩展时，将会抛出 OutOfMemoryError。<br>方法区：方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<p>常见的非受检异常有<br>ArrayIndexOutOfBoundsException，数组越界异常<br>NullPointerException，空指针异常<br>IllegalArgumentException，非法参数异常<br>NegativeArraySizeException，数组长度为负异常<br>IllegalStateException，非法状态异常<br>ClassCastException，类型转换异常</p>
</blockquote>
<p>字符被从 JVM 内部转移到外部时（例如存入文件系统<br>中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节<br>流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，<br>这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务</p>
<blockquote>
<p>抽象方法需要子类重写，而静态的方法是无法被重写</p>
<p>本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的</p>
<p>synchronized 和方法的实现细节有关，抽象方法不涉及实现细<br>节</p>
</blockquote>
<p>Tenured  老年代</p>
<p>接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类</p>
<blockquote>
<p>强引用 不会回收  内存不足时抛出内存溢出异常 引用赋值null中断和对象关联<br>软引用  内存足够垃圾收集器不会回收 内存不够时回收   缓存<br>弱引用  生命周期更短  被发现就会被回收    静态内部类<br>虚引用  相当于没有引用 任何时候都可能被垃圾回收器回收<br>jdk中直接内存的回收就用到虚引用<br><a href="https://www.cnblogs.com/zeussbook/p/12716173.html" target="_blank" rel="noopener">https://www.cnblogs.com/zeussbook/p/12716173.html</a></p>
</blockquote>
<p>Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Objec）</p>
<p>面向对象 6原则1法则</p>
<p>leetcode  84    85  单调栈</p>
<p>spring循环依赖<br><a href="https://www.cnblogs.com/zzq6032010/p/11406405.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzq6032010/p/11406405.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习方向]]></title>
      <url>/p/80lm7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>leetcode 65 确定有限状态自动机<br>struct默认防控属性是public的（只是数据集合 没有对数据操作），而class默认的防控属性是private的<br>深度（为什么  过程 实现细节 自己设计  适用场景）</p>
<p>buffer（缓冲）是为了提高内存和硬盘（或其他I/0设备）之间的数据交换的速度而设计的。</p>
<p>cache（缓存）是为了提高cpu和内存之间的数据交换速度而设计，也就是平常见到的一级缓存、二级缓存、三级缓存（也叫内存缓存）。</p>
<p>cpu在执行程序所用的指令和读数据都是针对内存的，也就是从内存中取得的。由于内存读写速度慢，为了提高cpu和内存之间数据交换的速度，在cpu和内存之间增加了cache，它的速度比内存快，但是造价高，又由于在cpu内不能集成太多集成电路，所以一般cache比较小，以后intel等公司为了进一步提高速度，又增加了二级cache，甚至三级cache，</p>
<p>缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</p>
<p>static<br>强软弱虚引用<br>https工作过程    同一连接2个请求  <a href="https://www.cnblogs.com/Sandy-1128/p/http.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sandy-1128/p/http.html</a></p>
<p>ca证书怎么回事  怎么验证证书有效<br>session cookie 在哪里（请求体还是哪？）  请求头 <a href="https://blog.csdn.net/z9061/article/details/82905874" target="_blank" rel="noopener">https://blog.csdn.net/z9061/article/details/82905874</a><br>jwt实现细节<br>ping 过程  协议  ICMP<br>spring  三重缓存   提前暴露  没有循环依赖不暴露-》三重缓存<br>select id，a，b，c from where a= and b&gt;  and c&lt;   怎么建索引 sql语句查询过程<br>(a,b)    那（a，c）可不可以<br>为什么不用select*<br>buffer cache   channel<br>虚拟地址 物理地址  逻辑地址   <a href="https://blog.csdn.net/macrossdzh/article/details/5954763" target="_blank" rel="noopener">https://blog.csdn.net/macrossdzh/article/details/5954763</a><br>线程池怎么工作的<br>自己设计线程池</p>
<p>http 6种请求  get post head delete put patch<br>状态码</p>
<p>自旋锁  可重入锁  <a href="https://www.cnblogs.com/theRhyme/p/9133804.html" target="_blank" rel="noopener">https://www.cnblogs.com/theRhyme/p/9133804.html</a><br>leetcode:峰值</p>
<p>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。<br>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员</p>
<p>Arrays.binarySearch</p>
<p>207 课程表 210</p>
<p>有限状态自动机、</p>
<p>214 最短回文串   字符串哈希  kmp算法<br>459  kmp算法</p>
<p>239   滑动窗口最大值</p>
<p>to do list</p>
<p>两个栈实现队列  每次压入元素时将栈中所有元素弹出 压入元素  再将所有元素压入</p>
<p>B树和B+树区别  <a href="https://blog.csdn.net/weixin_42228338/article/details/97684517" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42228338/article/details/97684517</a></p>
<p>二叉查找树<br>插入  新节点插入到叶子节点<br>删除（叶子节点 带有1个子节点的节点  带有2个子节点的节点）  <a href="https://www.cnblogs.com/lanhaicode/p/11298338.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanhaicode/p/11298338.html</a><br>带有1个子节点的节点  都是将待删除节点的左/右子树 赋值给 待删除节点的父节点的左/右子树<br>带有2个子节点的节点<br>（1）后继节点为子节点   都是将 后继节点 替代 待删除节点，并将待删除节点的左子树 赋值给 后继节点的左子树<br>（2）后继节点不为子节点<br>后继节点无右子节点：<br>后继节点替换删除节点，<br>后继节点无右子节点：<br>后继节点替换删除节点，后继节点右子树变为后继节点父节点左子树</p>
<p>AVL树旋转  <a href="https://blog.csdn.net/qq_37934101/article/details/81160254" target="_blank" rel="noopener">https://blog.csdn.net/qq_37934101/article/details/81160254</a></p>
<p>左旋——自己变为右孩子的左孩子；右旋——自己变为左孩子的右孩子</p>
<p>在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。</p>
<p>先左后右双旋转<br>当在ptr的左子树的右子树中插入一个结点后，造成了ptr平衡因子为-2的不平衡，将ptr向下找到当前结点的左孩子的右孩子，先进行左单旋ptr-&gt;left = subL，然后将ptr的右子树断开指向subR，此时便完成了旋转，最后将平衡因子进行更新。</p>
<p>先右后左双旋转</p>
<p>插入排序<br>反序对<br>冒泡排序<br>反序表</p>
<p>归并排序是在归并的基础上将数组不断划分成子数组进行排序，从而使整个数组完全有序，该算法是采用了典型的分治法来解决问题，即先将问题分解成子问题，再对子问题的解进行合并从而得到整个问题的解   <a href="https://my.oschina.net/joanfen/blog/5008658" target="_blank" rel="noopener">https://my.oschina.net/joanfen/blog/5008658</a></p>
<p>说起JWT，我们应该来谈一谈基于token的认证和传统的session认证的区别。  <a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">https://www.jianshu.com/p/576dbf44b2ae</a><br>但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来</p>
<p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了</p>
<p>用户使用用户名密码来请求服务器<br>服务器进行验证用户的信息<br>服务器通过验证发送给用户一个token<br>客户端存储token，并在每次请求时附送上这个token值<br>服务端验证token值，并返回数据</p>
<p>token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。</p>
<p>JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串<br>第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).<br>银行家算法</p>
<p>删除链表中重复的结点<br>垃圾收集中 工作线程和垃圾收集线程都怎么做的（收集的时候有对象死亡）</p>
<p>事务怎么实现的   https怎么工作的</p>
<p>看书  面经</p>
<p>sql语句优化  查询过程  查询优化器  通常是基于代价估计来做出决定，代价小的先执行<br>redis数据结构底层</p>
<p>垃圾收集：三色标记法  </p>
<blockquote>
<p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。<br>1.客户端向服务器发起HTTPS请求，连接到服务器的443端口</p>
</blockquote>
<p>2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</p>
<p>3.服务器将自己的公钥发送给客户端。</p>
<p>4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</p>
<p>5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p>
<p>6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</p>
<p>7.然后服务器将加密后的密文发送给客户端。</p>
<p>8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试题总结]]></title>
      <url>/p/80kvv/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>整理面试题（资料非常多 还没看完）<br>算法 把后面面试题刷完<br>项目  小说精品屋 分布式（理论 ）</p>
<p>BeanFactory:负责生产和管理Bean的一个工厂接口，提供一个Spring Ioc容器规范,<br>FactoryBean: 一种Bean创建的一种方式，对Bean的一种扩展。对于复杂的Bean对象初始化创建使用其可封装对象的创建细节。</p>
<p>什么情况造成跨域？<br>同源策略限制 不同源会造成跨域。以下任意一种情况不同，都是不同源。<br>同源：协议 域名 端口号全部相同 只要有一个不相同就是非同源策略</p>
<p>1:get通过url传递参数<br> 2:post设置请求头  规定请求数据类型</p>
<h3 id="使用上的区别"><a href="#使用上的区别" class="headerlink" title="使用上的区别"></a>使用上的区别</h3><p> 1:post比get安全<br> (因为post参数在请求体中。get参数在url上面)<br> 2:get传输速度比post快 根据传参决定的。<br> (post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取)<br> 3:post传输文件大理论没有限制  get传输文件小大概7-8k ie4k左右<br> 4:get获取数据  post上传数据<br> (上传的数据比较多  而且上传数据都是重要数据。所以不论在安全性还是数据量级 post是最好的选择)</p>
<p>分布在不同数据库或者不同应用上的分布式事务<br> 常见的分布式事务包括 2PC、3PC、TCC、本地消息表、消息事务、最大努力通知</p>
<p> TCP连接攻击  time_wait  close_wait  <1>半连接攻击?</1></p>
<pre><code>半连接攻击是一种攻击协议栈的攻击方式，坦白说就是攻击主机的一种攻击方式。通过将主机的资源消耗殆尽，从而导致应用层的程序无资源可用，导致无法运行。在正常情况下，客户端连接服务端需要通过三次握手，首先客户端构造一个SYN连接数据包发送至服务端，自身进入SYN_SEND状态，当服务端收到客户端的SYN包之后，为其分配内存核心内存，并将其放置在半连接队列中，服务端接收客户SYN包并会向客户端发送一个SYN包和ACK包，此刻服务端进入SYN_RECV态。客户端收到包之后，再次向服务端发送ACK确认包。至此连接建立完成，双方都进入ESTABLSHEDZ状态。半连接就是通过不断地构造客户端的SYN连接数据包发向服务端，等到服务端的半连接队列满的时候，后续的正常用户的连接请求将会被丢弃，从而无法连接到服务端。此为半连接攻击方式。根据服务端的半连接队列的大小，不同主机的抵抗这种SYN攻击的能力也是不一样。
</code></pre><p>如何来解决半连接攻击？</p>
<p>可以通过拓展半连接队列的大小，来进行补救，但缺点是，不能无限制的增加，这样会耗费过多的服务端资源，导致服务端性能地下。这种方式几乎不可取。现主要通syn cookie或者syn中继机制来防范半连接攻，部位半连接分配核心内存的方式来防范。</p>
<p><2>全连接攻击？</2></p>
<p>   全连接攻击是通过消费服务端进程数和连接数，只连接而不进行发送数据的一种攻击方式。当客户端连接到服务端，仅仅只是连接，此时服务端会为每一个连接创建一个进程来处理客户端发送的数据。但是客户端只是连接而不发送数据，此时服务端会一直阻塞在recv或者read的状态，如此一来，多个连接，服务端的每个连接都是出于阻塞状态从而导致服务端的崩溃。</p>
<p>如何来解决全连接攻击？</p>
<p>可以通过不为全连接分配进程处理的方式来防范全连接攻击，具体的情况是当收到数据之后，在为其分配一个处理线程。具体的处理方式在accept返回之前是不分配处理线程的。直到接收相关的数据之后才为之提供一个处理过程。例如在apache服务中，是通过预创建一定量的子进程作为处理连接继承。所有的自己进程都继承父进程的sockfd，每当有一个连接过来时，只有当accept返回是，才会为该链接分配一个进程来处理连接请求。负责，子进程一直处于等待状态。如果出现值是连接存在，而始终不放数据，该链接的状态是SYN_RECV，在协议栈中，提供一个保活期给该链接，如果超过保活期还没有数据到来，服务端协议栈将会断开该链接。如果没有该保活期，虽然避免了ESTABLESHED状态的数量，但是SYN_RECV的数据量的增长仍旧是不可估算的，所以需要利用保活期来监控该链接是需要清除断开。</p>
<p>说说 Redis 哈希槽的概念？<br>答：Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有<br>16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，<br>集群的每个节点负责一部分 hash 槽。</p>
<p>经典算法应用之一——归并排序（微软笔试题） 经典算法应用之二——基数排序（google笔试题） 经典算法应用之三——应用二中题目的升华 经典算法应用之四（上）—-基本位操作之算法篇 经典算法应用之四（中）—-基本位操作之算法篇 经典算法应用之四（下）—-百度面试题 经典算法应用之五—-随机生成和为S的N个正整数 经典算法应用之六—-过桥问题和过河问题 经典算法应用之七——10亿数据中取最大的100个数据</p>
<p>剑指 Offer II 077. 链表排序<br>快速排序思想的链表排序，原地排序，不新建额外节点<br>class Solution {<br>    public ListNode sortList(ListNode head) {<br>        ListNode preh = new ListNode(-1);<br>        preh.next = head;<br>        return mySortList(preh, head);<br>    }<br>    public ListNode mySortList(ListNode preh, ListNode head){<br>        if (head == null || head.next == null) return head;<br>        //当待排序链表val全部相等直接输出<br>        if(equal(head)) return head;<br>        //交换head和mid节点，以mid节点为基准进行分割<br>        head = findmid(preh, head);</p>
<pre><code>    //记录此时的头节点和其val值，进行分割
    ListNode p = head;
    int val = head.val;
    ListNode temp1 = head, temp2 = head.next;
    while(temp2 != null){
        if(temp2.val &lt; val){
            ListNode ptr = temp2.next;
            temp2.next = head;
            head = temp2;
            temp1.next = ptr;
            temp2 = ptr;
        }else{
            temp1 = temp1.next;
            temp2 = temp2.next;
        }
    }

    //排序后面的链表
    p.next = mySortList(p,p.next);
    //p前面没有了，直接输出
    if(p == head){
        return p;
    }
    //否则排序前面的
    temp1 = head;
    while(temp1.next != p) temp1 = temp1.next;
    temp1.next = null;
    head = mySortList(preh, head);

    //连接两端链表
    temp1 = head;
    while(temp1.next != null) temp1 = temp1.next;
    temp1.next = p;
    return head;
}

//交换两个链表中的节点函数
public ListNode swap(ListNode a, ListNode b, ListNode prea, ListNode preb){
    ListNode temp = a.next;
    a.next = b.next;
    b.next = temp;
    if(prea != null) prea.next = b;
    if(preb != null) preb.next = a;
    return b;
}

//交换头节点和中间节点
public ListNode findmid(ListNode preh ,ListNode head){
    if(head == null || head.next == null) return head;
    ListNode slow = head, fast = head.next;
    while(fast != null &amp;&amp; fast.next != null){
        slow = slow.next;
        fast = fast.next.next;
    }
    //交换slow和head
    return slow==head ? head : swap(head, slow.next, preh, slow);
}

//判断链表中的val是否全部相等
public boolean equal(ListNode head){
    int headval = head.val;
    ListNode temp = head.next;
    while(temp != null){
        if(temp.val != headval) return false;
        temp = temp.next;
    }
    return true;
}
</code></pre><p>}</p>
<p>归并排序<br>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>ListNode *next;</li>
<li>ListNode() : val(0), next(nullptr) {}</li>
<li>ListNode(int x) : val(x), next(nullptr) {}</li>
<li>ListNode(int x, ListNode *next) : val(x), next(next) {}</li>
<li>};<br><em>/<br>class Solution {<br>public:<br> ListNode</em> merge(ListNode<em> l1,ListNode</em> l2){<pre><code> ListNode* head=new ListNode(),*fake=head;
 ListNode* ptr1=l1,*ptr2=l2;
 while(ptr1&amp;&amp;ptr2){
     if(ptr1-&gt;val&lt;=ptr2-&gt;val){
         head-&gt;next=ptr1;
         ptr1=ptr1-&gt;next;
     }
     else{
         head-&gt;next=ptr2;
         ptr2=ptr2-&gt;next;
     }
     head=head-&gt;next;
 }
 if(ptr1)head-&gt;next=ptr1;
 else head-&gt;next=ptr2;
 return fake-&gt;next;
</code></pre> }<br> ListNode<em> sortList(ListNode</em> head) {<pre><code> if(!head||!head-&gt;next)return head;
 ListNode* slow=head,*fast=head;
 while(1){
     fast=fast-&gt;next;
     if(!fast)break;
     fast=fast-&gt;next;
     if(!fast)break;
     slow=slow-&gt;next;
 }
 ListNode* head2=slow-&gt;next;
 slow-&gt;next=nullptr;
 ListNode* l1=sortList(head);
 ListNode* l2=sortList(head2);
 return merge(l1,l2);
</code></pre> }<br>};</li>
</ul>
<p>剑指offer  107<br>对于此题，bfs的出发点是所有mat中为0的格子<br>在bfs的queue中不仅要保存当前节点的编号（行和列），还要保存到最近的0的距离（设为dis）<br>queue中的元素是三元组int[row,col,dis]，初始元素为所有dis为0的格子，并全部标记为已访问<br>对于每个队列中的元素，遍历它的相邻点，若未被访问，则将相邻点加入队列，其dis为当前点的dis+1<br>当队列为空时，所有格子都计算完毕<br>设矩阵大小为m<em>n，此算法的时间复杂度为O(m</em>n)，每个格子会处理一次<br>空间复杂度为O(m*n)，既是visited数组大小，也是queue可能的最大长度</p>
<p>剑指offer  66<br>前缀树：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class MapSum &#123;</span><br><span class="line">    class TreeNode&#123;</span><br><span class="line">        <span class="built_in">int</span> val ;</span><br><span class="line">        TreeNode[] next = <span class="keyword">new</span> TreeNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TreeNode root ;</span><br><span class="line">    Map&lt;<span class="keyword">String</span>,Integer&gt; <span class="built_in">map</span> ;</span><br><span class="line">    <span class="keyword">public</span> MapSum() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> insert(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="built_in">int</span> val) &#123;</span><br><span class="line">        TreeNode cur = root ;</span><br><span class="line">        <span class="built_in">int</span> update = val ;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">map</span>.containsKey(<span class="built_in">key</span>) )&#123;</span><br><span class="line">            update = update - <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">key</span>.length() ; i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> index = <span class="built_in">key</span>.charAt(i)-<span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span>( cur.next[index] == <span class="keyword">null</span> )&#123;</span><br><span class="line">                cur.next[index] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur.next[index].val += update ; </span><br><span class="line">            cur = cur.next[index] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="built_in">key</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> sum(<span class="keyword">String</span> prefix) &#123;</span><br><span class="line">        TreeNode cur = root ;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; prefix.length() ; i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> index = prefix.charAt(i)-<span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span>( cur.next[index] == <span class="keyword">null</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">            cur = cur.next[index] ;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> cur.val ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>67  最大异或<br>Trie树</p>
<p>剑指offer 73  向上取整<br>hour += (pile + speed - 1) / speed;  //向上取整</p>
<p>162  寻找峰值</p>
<p>深度优先和拓扑排序判断有无环</p>
<p>可达性</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面经]]></title>
      <url>/p/807jl/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>链接：<a href="https://www.nowcoder.com/discuss/780303?channel=-1&amp;source_id=profile_follow_post_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/780303?channel=-1&amp;source_id=profile_follow_post_nctrack</a><br>来源：牛客网</p>
<ol>
<li>static关键字<br>2.重载重写 构造器能不能重载重写<br>3.集合list set map<br>4.创建线程的方式<br>5.字符串string stringbuiler stringbuffer<br>6.g1 gc jvm模型<br>7.三张表联表查询 计算 使用函数<br>8.简单算法题<br>9.排序算法复杂度 稳定性<br>10.接口和抽象类</li>
<li>final关键字<br>12.多态<br>13.equal == 字符串 new 字符串<br>14.异常分类<br>15.死锁情况 解决死锁<br>16.线程关键字 wait sleep suspend …..<br>17.索引 </li>
<li>Linux命令</li>
</ol>
<p>mysql最左匹配原则<br>java内部类和匿名方法</p>
<p>392 动态规划解法<br>编辑距离</p>
<p>动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如这里的统计方案数的问题，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「最优子结构」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑</p>
<p>剑指 Offer 46. 把数字翻译成字符串」、「70. 爬楼梯」等  滚动数组思想</p>
<p>307线段树</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode刷题]]></title>
      <url>/p/8069v/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>a ^ b = c ，则 a ^ c = b，且 b ^ c = a<br>接雨水  dp  单调栈<br>76 最小覆盖子串<br>80  双指针<br>146  LRU<br>哈希表+双向链表</p>
<p>221最大正方形</p>
<p>141 环形链表</p>
<p>其实，快慢指针法，就是一种 映射 操作， 链表 里面的 一次映射操作，就是 求 next，且 将位置 更新到 这里； 数组 这里，就是 根据 下标 i 求 nums[i] 这个元素值，且 将 下标 更新到这里。</p>
<p>链表里面 有环，即 一个节点 被不同的 节点指向（映射）； 而 这里说的 数组 有环，即 数组中的一个元素值 被不同的 index 指向（映射）； 所以，求解方法 一样可以 使用 快慢指针法。</p>
<p>图java代码   牛客网美团试题<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Graph &#123;</span><br><span class="line">    <span class="comment">//边</span></span><br><span class="line">    <span class="keyword">public</span> class EdgeNode&#123;</span><br><span class="line">        <span class="built_in">int</span> index;  <span class="comment">//存储该顶点对应的下标</span></span><br><span class="line">        <span class="built_in">int</span> weight; <span class="comment">//存储权重</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;<span class="keyword">String</span>&gt; pointList;    <span class="comment">//顶点数组</span></span><br><span class="line">    LinkedList&lt;EdgeNode&gt; edjList[]; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="built_in">int</span> pointNum;       <span class="comment">//顶点数</span></span><br><span class="line">    <span class="built_in">int</span> edgeNum;        <span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Graph(<span class="built_in">int</span> n)&#123;</span><br><span class="line">        pointList = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        edjList = <span class="keyword">new</span> LinkedList[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            edjList[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        pointNum = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> addPoint(<span class="keyword">String</span> name)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pointList.<span class="built_in">size</span>() &gt;= pointNum)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"point array full"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pointList.indexOf(name) != <span class="number">-1</span>)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"已经存在"</span>+name);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        pointList.<span class="built_in">add</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getName(<span class="built_in">int</span> index)&#123;</span><br><span class="line">        <span class="keyword">return</span> pointList.<span class="built_in">get</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> addEdge(<span class="keyword">String</span> name1, <span class="keyword">String</span> name2, <span class="built_in">int</span> weight)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> i = pointList.indexOf(name1);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">-1</span>)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"not find nam1="</span>+name1);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> j = pointList.indexOf(name2);</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span>)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"not find name2="</span>+name2);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EdgeNode edge = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">        edge.index = j;</span><br><span class="line">        edge.weight = weight;</span><br><span class="line">        edjList[i].<span class="built_in">add</span>(edge);</span><br><span class="line">        edgeNum++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入另一个边 （无向边 两边都加）</span></span><br><span class="line">        edge = <span class="keyword">new</span> EdgeNode();</span><br><span class="line">        edge.index = i;</span><br><span class="line">        edge.weight = weight;</span><br><span class="line">        edjList[j].<span class="built_in">add</span>(edge);</span><br><span class="line">        edgeNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> printAll()&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> s : pointList) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;pointList.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="string">"节点"</span>+pointList.<span class="built_in">get</span>(i) +<span class="string">"边为:"</span>);</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode edgeNode : edjList[i]) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(pointList.<span class="built_in">get</span>(edgeNode.index)+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广度遍历</span></span><br><span class="line"><span class="comment">     * @param name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> BSTTraverse(<span class="keyword">String</span> name)&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到name</span></span><br><span class="line">        <span class="built_in">int</span> i = pointList.indexOf(name);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">-1</span>)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"not find name="</span>+name);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[pointNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; pointNum; j++) &#123;</span><br><span class="line">            a[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line">        LinkedList&lt;EdgeNode&gt; list = edjList[i];</span><br><span class="line">        <span class="keyword">for</span> (EdgeNode edgeNode : list) &#123;</span><br><span class="line">            queue.addLast(edgeNode.index);</span><br><span class="line">            a[edgeNode.index] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//从queue中拿出一个节点</span></span><br><span class="line">            i = queue.removeFirst();</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"遍历 "</span> + pointList.<span class="built_in">get</span>(i));</span><br><span class="line"></span><br><span class="line">            list = edjList[i];</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode edgeNode : list) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[edgeNode.index] != <span class="number">1</span>)&#123;</span><br><span class="line">                    queue.addLast(edgeNode.index);</span><br><span class="line">                    a[edgeNode.index] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> class Node&#123;</span><br><span class="line">        <span class="built_in">int</span> index;</span><br><span class="line">        <span class="built_in">int</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据深度获取好友队列</span></span><br><span class="line"><span class="comment">     * @param name</span></span><br><span class="line"><span class="comment">     * @param deep 获取1度好友 则深度为2</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     * 采用广度优先算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Node&gt; getQueueByDeep(<span class="keyword">String</span> name, <span class="built_in">int</span> deep)&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//找到name</span></span><br><span class="line">        <span class="built_in">int</span> i = pointList.indexOf(name);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">-1</span>)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"not find name="</span>+name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[pointNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; pointNum; j++) &#123;</span><br><span class="line">            a[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        node.index = i;</span><br><span class="line">        node.deep = <span class="number">1</span>;</span><br><span class="line">        queue.addLast(node);</span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//从queue中拿出一个节点</span></span><br><span class="line">            node = queue.getFirst();</span><br><span class="line">            <span class="keyword">if</span>(node.deep == deep)&#123;</span><br><span class="line">                <span class="keyword">return</span> queue;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.removeFirst();</span><br><span class="line">            <span class="comment">//System.out.println("遍历 " + pointList.get(node.index).data);</span></span><br><span class="line"></span><br><span class="line">            List&lt;EdgeNode&gt; list = edjList[node.index];</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode edgeNode : list) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[edgeNode.index] != <span class="number">1</span>)&#123;</span><br><span class="line">                    Node temp = <span class="keyword">new</span> Node();</span><br><span class="line">                    temp.index = edgeNode.index;</span><br><span class="line">                    temp.deep = node.deep+<span class="number">1</span>;</span><br><span class="line">                    queue.addLast(temp);</span><br><span class="line">                    a[edgeNode.index] = <span class="number">1</span>;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"deep="</span>+temp.deep + pointList.<span class="built_in">get</span>(edgeNode.index));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">7</span>);</span><br><span class="line">        g.addPoint(<span class="string">"小团"</span>);</span><br><span class="line">        g.addPoint(<span class="string">"小美"</span>);</span><br><span class="line">        g.addPoint(<span class="string">"小诚"</span>);</span><br><span class="line">        g.addPoint(<span class="string">"小信"</span>);</span><br><span class="line">        g.addPoint(<span class="string">"小卓"</span>);</span><br><span class="line">        g.addPoint(<span class="string">"小越"</span>);</span><br><span class="line"></span><br><span class="line">        g.addPoint(<span class="string">"小孩"</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="string">"小团"</span>, <span class="string">"小美"</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="string">"小卓"</span>, <span class="string">"小美"</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="string">"小诚"</span>, <span class="string">"小美"</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="string">"小团"</span>, <span class="string">"小卓"</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="string">"小诚"</span>, <span class="string">"小信"</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="string">"小信"</span>, <span class="string">"小越"</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="string">"小卓"</span>, <span class="string">"小越"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="string">"小信"</span>, <span class="string">"小孩"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        g.printAll();</span><br><span class="line"></span><br><span class="line">        g.BSTTraverse(<span class="string">"小美"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> deep = <span class="number">4</span>;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = g.getQueueByDeep(<span class="string">"小美"</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(queue == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"没有"</span>+(deep<span class="number">-1</span>)+<span class="string">"度好友"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Node node : queue) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(node.deep+<span class="string">"度好友为 "</span>+ g.getName(node.index));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HTTPS的实现原理 HTTP的5个常用Method及其含义，以及5个常用Status Code及其含义</p>
<p>拓扑排序<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="keyword">Array</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定按火星字典序排列的单词，求单词中出现过的字符的字典序</span></span><br><span class="line"><span class="comment"> * wrt wrf er ett rftt</span></span><br><span class="line"><span class="comment"> * x z x</span></span><br><span class="line"><span class="comment"> * abc bbc</span></span><br><span class="line"><span class="comment"> * hij ikjk kih jkca jkaa jj</span></span><br><span class="line"><span class="comment"> * 构造一个字符的有向无环图，再找拓扑序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class Main &#123;</span><br><span class="line">    <span class="comment">// 保存图，定义如果字符i在字符j前，那么存在i到j路径，即map[i][j]=1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span>[][] <span class="built_in">map</span> = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 保存每个节点的入度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span>[] indegree = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 记录出现过的字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">boolean</span>[] flag = <span class="keyword">new</span> <span class="built_in">boolean</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Character&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Character&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">// wrt wrf er ett rftt</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">String</span>[] input = sc.nextLine().<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 创建有向图</span></span><br><span class="line">        build(input);</span><br><span class="line">        <span class="comment">// 找拓扑序列</span></span><br><span class="line">        topology();</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == <span class="built_in">set</span>.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Character c : ans) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"invalid"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> topology() &#123;</span><br><span class="line">        <span class="keyword">while</span>(ans.<span class="built_in">size</span>() &lt; <span class="built_in">set</span>.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 是否在一个遍历中找到入度为0的节点，如果没找到，要break;如果一次遍历找到两个入度为0的点，说明是无法确认顺序的</span></span><br><span class="line">            <span class="built_in">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; indegree.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(indegree[i] == <span class="number">0</span> &amp;&amp; flag[i]) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt != <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 找没有入度的节点，加入序列，在有向图中删除这个节点和从这个节点出发的边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; indegree.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (indegree[i] == <span class="number">0</span> &amp;&amp; flag[i]) &#123;</span><br><span class="line">                    ans.<span class="built_in">add</span>((<span class="built_in">char</span>) (<span class="string">'a'</span> + i));</span><br><span class="line">                    flag[i] = <span class="keyword">false</span>;    <span class="comment">// 删除节点</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;       <span class="comment">// 删除从这个节点出发的边</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        indegree[j]--;</span><br><span class="line">                        <span class="built_in">map</span>[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//[wrt wrf er ett rftt]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> build(<span class="keyword">String</span>[] strs) &#123;</span><br><span class="line">        <span class="comment">// 找到相邻的两个字符串，第一个不相同的字符可以确定字符的顺序</span></span><br><span class="line">        <span class="comment">// 如wrt和wrf可以得到：t-&gt;f</span></span><br><span class="line">        <span class="keyword">String</span> pre = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">char</span> c : pre.toCharArray()) &#123;</span><br><span class="line">            <span class="built_in">set</span>.<span class="built_in">add</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">String</span> cur = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">char</span> c : cur.toCharArray()) &#123;</span><br><span class="line">                <span class="built_in">set</span>.<span class="built_in">add</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; Math.<span class="built_in">min</span>(pre.length(), cur.length()); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre.charAt(j) == cur.charAt(j)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[pre.charAt(j)-<span class="string">'a'</span>][cur.charAt(j)-<span class="string">'a'</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">map</span>[pre.charAt(j)-<span class="string">'a'</span>][cur.charAt(j)-<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">                indegree[cur.charAt(j)-<span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">                flag[pre.charAt(j)-<span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">                flag[cur.charAt(j)-<span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>redis</p>
<p>有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是OlogN</p>
<p>单机版：很少使用。存在的问题：1、内存容量有限 2、处理能力有限 3、无法高可用。</p>
<p>主从模式：master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。</p>
<p>哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p>
<p>Redis cluster：主要是针对海量数据+高并发+高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用Redis cluster，所有主节点的容量总和就是Redis cluster可缓存的数据容量。</p>
<p>105  106 二叉树 前 中 后</p>
<h1 id="创建普通的索引"><a href="#创建普通的索引" class="headerlink" title="创建普通的索引"></a>创建普通的索引</h1><p> alter table <code>table_name</code>  add  index <code>index_name</code> (<code>字段名</code>)</p>
<h1 id="创建主键索引"><a href="#创建主键索引" class="headerlink" title="创建主键索引"></a>创建主键索引</h1><p>alter  table <code>table_name</code> add primary  key (<code>字段名</code>)</p>
<h1 id="创建-唯一索引"><a href="#创建-唯一索引" class="headerlink" title="创建 唯一索引"></a>创建 唯一索引</h1><p>alter  table  <code>table_name</code> add unique  (<code>字段名</code>)</p>
<h1 id="创建全文的索引"><a href="#创建全文的索引" class="headerlink" title="创建全文的索引"></a>创建全文的索引</h1><p>alter table <code>table_name</code> add  fulltext (<code>字段名</code>)</p>
<h1 id="创建多个索引"><a href="#创建多个索引" class="headerlink" title="创建多个索引"></a>创建多个索引</h1><p>alter  table <code>table_name</code>  add index  <code>index_Name</code>(<code>column</code>,<code>column1</code>,<code>column_N</code>…….)</p>
<p>下面是删除索引的语句</p>
<p>drop  index <code>index_name</code> on <code>table_name</code></p>
<p>alter  table <code>table_name</code> drop index <code>index_name</code></p>
<p>40  组合总和</p>
<p>分治</p>
<p>int quickMulti(int A, int B) {<br>    int ans = 0;<br>    for ( ; B; B &gt;&gt;= 1) {<br>        if (B &amp; 1) {<br>            ans += A;<br>        }<br>        A &lt;&lt;= 1;<br>    }<br>    return ans;<br>}</p>
<p>约瑟夫环</p>
<p>扩展中心    priority queue   比较器<br>剑指 Offer II 020. 回文子字符串的个数 Manacher 算法</p>
<p>instance = new Singleton();</p>
<p>这句代码在执行时会分解为三个步骤：</p>
<p>1.为对象分配内存空间。</p>
<p>2.执行初始化的代码。</p>
<p>3.将分配好的内存地址设置给instance引用。</p>
<p>当线程进行一个volatile变量的写操作时，JIT编译器生成的汇编指令会在写操作的指令后面加上一个“lock”指令</p>
<h1 id="线程池生命周期："><a href="#线程池生命周期：" class="headerlink" title="线程池生命周期："></a>线程池生命周期：</h1><h2 id="RUNNING：表示线程池处于运行状态，这时候的线程池可以接受任务和处理任务。值是-1，"><a href="#RUNNING：表示线程池处于运行状态，这时候的线程池可以接受任务和处理任务。值是-1，" class="headerlink" title="RUNNING：表示线程池处于运行状态，这时候的线程池可以接受任务和处理任务。值是-1，"></a>RUNNING：表示线程池处于运行状态，这时候的线程池可以接受任务和处理任务。值是-1，</h2><h2 id="SHUTDOWN：表示线程池不接受新任务，但仍然可以处理队列中的任务，二进制值是0。调用showdown-方法会进入到SHUTDOWN状态。"><a href="#SHUTDOWN：表示线程池不接受新任务，但仍然可以处理队列中的任务，二进制值是0。调用showdown-方法会进入到SHUTDOWN状态。" class="headerlink" title="SHUTDOWN：表示线程池不接受新任务，但仍然可以处理队列中的任务，二进制值是0。调用showdown()方法会进入到SHUTDOWN状态。"></a>SHUTDOWN：表示线程池不接受新任务，但仍然可以处理队列中的任务，二进制值是0。调用showdown()方法会进入到SHUTDOWN状态。</h2><h2 id="STOP：表示线程池不接受新任务，也不处理队列中的任务，同时中断正在执行任务的线程，值是1。调用showdownNow-方法会进入到STOP状态。"><a href="#STOP：表示线程池不接受新任务，也不处理队列中的任务，同时中断正在执行任务的线程，值是1。调用showdownNow-方法会进入到STOP状态。" class="headerlink" title="STOP：表示线程池不接受新任务，也不处理队列中的任务，同时中断正在执行任务的线程，值是1。调用showdownNow()方法会进入到STOP状态。"></a>STOP：表示线程池不接受新任务，也不处理队列中的任务，同时中断正在执行任务的线程，值是1。调用showdownNow()方法会进入到STOP状态。</h2><h2 id="TIDYING：表示所有的任务都已经终止，并且工作线程的数量为0。值是2。SHUTDOWN和STOP状态的线程池任务执行完了，工作线程也为0了就会进入到TIDYING状态。"><a href="#TIDYING：表示所有的任务都已经终止，并且工作线程的数量为0。值是2。SHUTDOWN和STOP状态的线程池任务执行完了，工作线程也为0了就会进入到TIDYING状态。" class="headerlink" title="TIDYING：表示所有的任务都已经终止，并且工作线程的数量为0。值是2。SHUTDOWN和STOP状态的线程池任务执行完了，工作线程也为0了就会进入到TIDYING状态。"></a>TIDYING：表示所有的任务都已经终止，并且工作线程的数量为0。值是2。SHUTDOWN和STOP状态的线程池任务执行完了，工作线程也为0了就会进入到TIDYING状态。</h2><h2 id="TERMINATED：表示线程池处于终止状态。值是3"><a href="#TERMINATED：表示线程池处于终止状态。值是3" class="headerlink" title="TERMINATED：表示线程池处于终止状态。值是3"></a>TERMINATED：表示线程池处于终止状态。值是3</h2><p>javap -v 命令查看class文件对应的JVM字节码信息<br>Java对象的内存布局其实由对象头+实例数据+对齐填充</p>
<p>就是Java对象的内存布局其实由对象头+实例数据+对齐填充三部分组成，而对象头主要包含Mark Word+指向对象所属的类的指针组成。Mark Word主要用于存储对象自身的运行时数据，哈希码，GC分代年龄，锁标志等。</p>
<blockquote>
<p>最左匹配原则  联合索引  范围查询<br>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
</blockquote>
<p>链表递归实现</p>
<p>跳跃表  单链表 索引</p>
<p>不用平衡二叉树做索引<br>指的是逻辑结构上的平衡二叉树，其物理实现是数组。然后由于在逻辑结构上相近的节点在物理结构上可能会差很远。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。</p>
<p>Zset是基于跳跃表+字典实现的，如果只是单key查询，那么就直接从字典中查询(字典的key就是保存了元素的值，value则是元素的分值score)，这样可以用O(1)的时间复杂度完成查询。如果是根据分值score进行范围查询，就是去跳跃表中查询</p>
<p>undo log 事务原子性 （失败回滚）  MVCC<br>逻辑日志 记录SQL语句</p>
<p>redo log  持久性<br>将对数据页的更改写入到redo log，此时redo log中这条事务的状态为prepare状态。</p>
<p>MySQL在可重复读的隔离级别下，通过MVCC机制和Next-key Lock解决了幻读的问题</p>
<p>反射机制优缺点：<br>反射机制的优缺点：<br>优点： 1）能够运行时动态获取类的实例，提高灵活性； 2）与动态编译结合 缺点： 1）使用反射<br>性能较低，需要解析字节码，将内存中的对象进行解析。 解决方案： 1、通过setAccessible(true)<br>关闭JDK的安全检查来提升反射速度； 2、多次创建一个类的实例时，有缓存会快很多 3、<br>ReflectASM工具类，通过字节码生成的方式加快反射速度 2）相对不安全，破坏了封装性（因为通<br>过反射可以获得私有方法和属性）</p>
<p>notify可能会导致死锁，而notifyAll则不会</p>
<p>剑指offer33</p>
<p>剑指offer40     小跟堆<br>647回文子串<br>网络问题，延迟开销，带宽问题，安全问题<br> kafka 的设计理念，broker -&gt; topic -&gt; partition</p>
<p> 高可用：主从</p>
<p> Lucene 是著名的搜索开源软件，ElasticSearch 和 Solr 底层用的都是它<br> 分词<br> 分段的思想大大的提高了维护索引的效率<br> TF IDF  TF-IDF = TF / IDF<br> ElasticSearch 是集群的 = 主分片 + 副本分片<br> 脑裂</p>
<p> maven  pom 项目对象模型</p>
<p> SaaS系统开发</p>
<p>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做<br>Zab协议</p>
<p>Zab 协议来保证分布式事务的最终一致性。Zab协议要求每个 Leader 都要经历三个阶段：发现，同<br>步，广播</p>
<p>Zookeeper 有两种选举算法：基于 basic paxos 实现和基于 fast paxos 实现。默认为 fast paxos</p>
<p>恢复模式  广播模式</p>
<p>spring循环依赖 spring事务隔离级别 spring事务传播行为<br>http  https   1.0和1.1<br>mybatis缓存   mybatis设计模式<br>mybatis 1级缓存 没有容量限定的HashMap  （多个sqlSession或者分布式环境 数据库写操作会引起脏数据）</p>
<p>多个 SqlSession之间需要共享缓存，则需要使用到二级缓存。</p>
<p>跨域  sql语句 linux命令练习   fork()<br>Docker Netty  unicode和utf8编码</p>
<p>Nginx是一个web服务器和方向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议<br>多进程  异步非阻塞  反向代理 负载均衡  </p>
<p>正向代理（通过正向代理的方式，在我们的客户端运行一个软件，将我们的HTTP请求转发<br>到其他不同的服务器端）<br>mongodb文档  vue</p>
<p>select poll epoll</p>
<p>nginx用途：<br>Nginx服务器的最佳用法是在网络上部署动态HTTP内容，使用SCGI、WSGI应用程序服务器、用于<br>脚本的FastCGI处理程序。它还可以作为负载均衡器</p>
<p>用户管理：提供用户的相关配置，新增用户后，默认密码为123456<br>角色管理：对权限与菜单进行分配，可根据部门设置角色的数据权限<br>菜单管理：已实现菜单动态路由，后端可配置化，支持多级菜单<br>部门管理：可配置系统组织架构，树形表格展示<br>岗位管理：配置各个部门的职位<br>字典管理：可维护常用一些固定的数据，如：状态，性别等<br>系统日志：记录用户操作日志与异常日志，方便开发人员定位排错<br>SQL监控：采用druid 监控数据库访问性能，默认用户名admin，密码123456<br>定时任务：整合Quartz做定时任务，加入任务日志，任务运行情况一目了然<br>代码生成：高灵活度生成前后端代码，减少大量重复的工作任务<br>邮件工具：配合富文本，发送html格式的邮件<br>七牛云存储：可同步七牛云存储的数据到系统，无需登录七牛云直接操作云数据<br>支付宝支付：整合了支付宝支付并且提供了测试账号，可自行测试<br>服务监控：监控服务器的负载情况<br>运维管理：一键部署你的应用</p>
<p>347 前k个高频元素</p>
<ol>
<li>链表随机节点   蓄水池抽样</li>
</ol>
<p>28   kmp算法<br>208   实现Trie<br>547  省份数量   并查集</p>
<p>leetcode 面试题17.13 恢复空格<br>方法1 Trie+动态规划<br>方法2  字符串哈希   Rabin-Karp </p>
<p>最小k个数 快排 还不会</p>
<p>最长递增子序列</p>
<p>面试题17.07 婴儿名字 并查集</p>
<p>面试题16.09 运算 </p>
<p>面试题  10.03 旋转数组<br>189  153  154  33 81</p>
<p>不同二叉搜索树  卡特兰数</p>
<p>Morris中序遍历</p>
<p>169  投票算法</p>
<p>以 n = 1234567n=1234567 为例，我们需要统计「百位」上数字 11 出现的次数。我们知道，对于从 00 开始每 10001000 个数，「百位」上的数字 11 都会出现 100100 次，即数的最后三位每 10001000 个数都呈现 [000, 999][000,999] 的循环，其中的 [100, 199][100,199] 在「百位」上的数字为 11，共有 100100 个。</p>
<p> 1382 将二叉搜索树变平衡<br> 783 二叉搜索树节点最小距离</p>
<p> 337 打家劫舍 III<br> 递增的三元子序列</p>
<p> 324摆动序列II  桶排序<br> 321 拼接最大数  单调栈<br> 316 去除重复字母  单调栈<br>354  套娃  动态规划<br> LIS<br> 牛顿迭代法<br> 牛顿迭代法是一种近似求解方程（近似求解函数零点）的方法。其本质是借助泰勒级数，从初始值开始快速向函数零点逼近。</p>
<p> 413 等差数列划分<br> 416 动态规划<br> NP完全问题<br> 417 太平洋  大西洋<br> 406<br> 437<br> 474<br> 491<br> 494</p>
<p> 459  kmp<br> 463<br> 498  对角线遍历</p>
<p> 单调栈 下一个更大元素  496 503<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">       Deque&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">           <span class="keyword">int</span> num = nums2[i];</span><br><span class="line">           <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty() &amp;&amp; num &gt;= <span class="built_in">stack</span>.peek()) &#123;</span><br><span class="line">               <span class="built_in">stack</span>.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">map</span>.put(num, <span class="built_in">stack</span>.isEmpty() ? <span class="number">-1</span> : <span class="built_in">stack</span>.peek());</span><br><span class="line">           <span class="built_in">stack</span>.push(num);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; ++i) &#123;</span><br><span class="line">           res[i] = <span class="built_in">map</span>.get(nums1[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>543  二叉树直径<br>零钱兑换看区别</p>
<p>556<br>746 </p>
<p>678 动态规划</p>
<p>快排 堆排序手写</p>
<p>单词接龙</p>
<p>股票利润</p>
<p>链表排序</p>
<p>合并多个链表排序</p>
<p>416<br>581<br>除法</p>
<p>DAG有向无环图</p>
<p>01背包逆序</p>
<p>完全背包正序</p>
<p>字符串哈希</p>
<p>关键路径  AOV  AOE</p>
<p>排序链表</p>
<p>归并排序</p>
<p>PriorityQueue<listnode> heap = new PriorityQueue<listnode>((a,b)-&gt;a.val-b.val);</listnode></listnode></p>
<p>单调栈  找左边  正序  <strong><strong><em>*</em></strong></strong> 找右边  逆序<br><figure class="highlight plain"><figcaption><span>******更小></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (!stack.isEmpty() &amp;&amp; num &gt;= stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(num, stack.isEmpty() ? -1 : stack.peek());</span><br><span class="line">            stack.push(num);</span><br></pre></td></tr></table></figure></p>
<p>503</p>
<p>子序列去重的问题。对于序列去重，我们可以使用串哈希算法（即 Rabin-Karp 编码</p>
<p>去重还不太会</p>
<p>1392  最长快乐前缀</p>
<p>139  单词拆分</p>
<p>Rabin-Karp 字符串编码   10的9次方+7     10的9次方+9 </p>
<p>2018  dfs<br>2012</p>
<p>1235   动态规划</p>
<p>1995</p>
<p>康托对角线</p>
<p>1975   贪心</p>
<p>Floyd 算法</p>
<p>记忆化搜索</p>
<p>1901</p>
<p>1920  原地操作</p>
<p>1922 快速幂    50</p>
<p>1942</p>
<p>最小费用最大流</p>
<p>698 如果求方案 dfs怎么做<br>状态压缩动态规划   1931<br>1922    快速幂   50   分治算法       2进制拆分<br>递归<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>除法实现</p>
<p>1910  应用kmp</p>
<ol>
<li>最大子序列交替和</li>
</ol>
<p>200岛屿数量</p>
<p>394  </p>
<p>并查集   399<br>「力扣」第 547 题：省份数量（中等）；<br>「力扣」第 684 题：冗余连接（中等）；<br>「力扣」第 1319 题：连通网络的操作次数（中等）；<br>「力扣」第 1631 题：最小体力消耗路径（中等）；<br>「力扣」第 959 题：由斜杠划分区域（中等）；<br>「力扣」第 1202 题：交换字符串中的元素（中等）；<br>「力扣」第 947 题：移除最多的同行或同列石头（中等）；<br>「力扣」第 721 题：账户合并（中等）；<br>「力扣」第 803 题：打砖块（困难）；<br>「力扣」第 1579 题：保证图可完全遍历（困难）;<br>「力扣」第 778 题：水位上升的泳池中游泳（困难）</p>
<p>兑换零钱贪心</p>
<p>48  原地旋转    先水平翻转  再对角线翻转（实现矩阵顺时针旋转90度）</p>
<p>1856  单调栈</p>
<p>392  判断子序列</p>
<p>1832  状态压缩</p>
<p>回文  中心扩展  manacher</p>
<p>698</p>
<p>688  动态规划</p>
<p>687</p>
<p>684  并查集</p>
<p>718</p>
<p>797</p>
<p>788  动态规划</p>
<p>787   最短路<br>求解最短路一般有三种方法，floyd算法，dijkstra算法和bellman ford算法。这题使用bellman ford算法是适用性最强的，因为该算法的第k步就是求出的从给定起点到所有节点经过最多k步的最短路。如果只想到了dijkstra算法，说明思考方向是对的，但没有用到最合适的算法。</p>
<p>779  找规律</p>
<p>买股票无限次<br>买股票只买一次<br>买股票有手续费<br>买股票最多买两次</p>
<p>841</p>
<p>csp  收集卡牌  状态压缩dp</p>
<p>Bellman-Ford     <a href="https://blog.csdn.net/lym940928/article/details/90209172" target="_blank" rel="noopener">https://blog.csdn.net/lym940928/article/details/90209172</a><br>它的基本原理是对图进行|V| - 1次松弛操作，得到所有可能的最短路径。<br>它比Dijkstra算法好的部分在于，在计算最短路径的班的权值可以为负，实现起来比较简单。<br>缺点则是时间复杂度较高，为O(|V||E|)。不过算法已经有了一些改进方案，比如队列优化的Bellmanford算法（SPFA算法），一定程度上提高了效率。</p>
<p>SPFA算法</p>
<p>改进的Dijkstra算法<br>由于最小费用最大流网络中存在负权值，Dijkstra算法不能直接求解最小费用最大流问题，如果最小费用最大流网络中的权值都非负，则可使用Dijkstra算法。引入势函数h(u)为上一次Dijkstra算法的dist(u)（表示从源点到顶点u的最短距离），对每一条边（u,v）,h(v)&lt;=h(u)+w(u,v)成立，则下一次计算中dist(v)=dist(u)+w(u,v)+h(u)-h(v)，所有的dist值必然都大于等于0，则可以继续用Dijkstra算法求解最短路。</p>
<p>1928  动态规划</p>
<p>1905  子岛屿</p>
<p>出口</p>
<p>784  字母大小写全排列   和子集看区别  90</p>
<p>322  零钱兑换    518      求组合怎么求？</p>
<p>70  爬楼梯</p>
<p>做链表</p>
<p>同值路径等深搜</p>
<p>39  组合总和 搜索回溯</p>
<p>6  z字型变换</p>
<p>2^31−1=2147483647</p>
<p>17</p>
<p>二分查找经典题  旋转排序数组</p>
<p>字符串相乘</p>
<p>40</p>
<p>75颜色分类  荷兰国旗  单指针  双指针</p>
<p>91 解码方法<br>97  交错字符串 动态规划<br>剑指offer46</p>
<p>做股票</p>
<p>[−2147483648,2147483647]</p>
<p>接雨水   双指针  单调栈  dp<br>正则表达式匹配</p>
<p>85 单调栈</p>
<p>140 记忆化搜索</p>
<p>698  划分为k个相等子集   状态压缩dp</p>
<p>线性筛  0/1背包  完全背包  最小费用最大流 taj强连通分量</p>
<p>二分图  匈牙利算法</p>
<p>DAG最小路径覆盖</p>
<p>二分图最小点覆盖</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213112909911.jpg" alt><br>start法则</p>
<p>二分图最大匹配<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213114319836.jpg" alt></p>
<p>增广路的匈牙利算法<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213150828410.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213151141492.jpg" alt></p>
<p>带权二分图最佳完美匹配</p>
<p>manacher算法      最长回文子串    中心检测法O(n2)<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213133459307.jpg" alt></p>
<p>无向图双连通分量      割点  桥<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213124131747.jpg" alt></p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213124926065.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213125419516.jpg" alt><br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213125704139.jpg" alt></p>
<p>有向图强连通分量  Tarjan的SCC算法</p>
<p>树上DP   平衡的艺术  树的重心</p>
<p>FF  EA 最大流算法</p>
<p>最小费用最大流<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213120650002.jpg" alt><br>Dinic<br>ISAP</p>
<p>hash LCP</p>
<p>后缀自动机</p>
<p>线段树和树状数组   lowbit<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213142024751.jpg" alt><br>树状数组  动态前缀和（可修改）<br>线段树   平衡二叉树</p>
<p>区间最值 线段树<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213140923042.jpg" alt><br>ST表  静态RMQ(区间最值)<br><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213143017605.jpg" alt></p>
<p>组合数学和计数</p>
<p>排序二叉树（二叉搜索树）    平衡树  set map 优势人群   multiset</p>
<p>异象石</p>
<p>Treap</p>
<p>ac自动机</p>
<p>RMQ     倍增法求解LCA    链式前向星</p>
<p>关键路径</p>
<p>增广路<br>dinic   分层图</p>
<p><img src="https://gitee.com/mosheng123456789/pics/raw/master/img/360截图20211213150352411.jpg" alt><br>sap<br>ek<br>sf<br>ff<br><a href="https://www.cnblogs.com/ZJUT-jiangnan/p/3632525.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZJUT-jiangnan/p/3632525.html</a></p>
<p>Java红黑树 <a href="https://www.cnblogs.com/skywang12345/p/3624343.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3624343.html</a></p>
<p>307 线段树<br><a href="https://www.cnblogs.com/strongmore/p/14223224.html" target="_blank" rel="noopener">https://www.cnblogs.com/strongmore/p/14223224.html</a></p>
<p>Java  bellman-ford和SPFA算法实现<br><a href="https://www.cnblogs.com/lfri/p/9521271.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfri/p/9521271.html</a></p>
<p>面试题 17.17. 多次搜索  trie  kmp</p>
<p>面试题 08.14. 布尔运算  记忆化搜索  区间dp</p>
<p>剑指 Offer II 063. 替换单词    trie</p>
<p>kmp算法<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int strStr(String haystack, String needle) &#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">length</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		int[]next=new int[needle.<span class="built_in">length</span>()];</span><br><span class="line">		int <span class="built_in">j</span>=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;needle.<span class="built_in">length</span>();<span class="built_in">i</span>++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">j</span>&gt;<span class="number">0</span>&amp;&amp;needle.charAt(<span class="built_in">i</span>)!=needle.charAt(<span class="built_in">j</span>))<span class="built_in">j</span>=next[<span class="built_in">j</span><span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span>(needle.charAt(<span class="built_in">i</span>)==needle.charAt(<span class="built_in">j</span>))<span class="built_in">j</span>++;</span><br><span class="line">			next[<span class="built_in">i</span>]=<span class="built_in">j</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">j</span>=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;haystack.<span class="built_in">length</span>();<span class="built_in">i</span>++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">j</span>&gt;<span class="number">0</span>&amp;&amp;haystack.charAt(<span class="built_in">i</span>)!=needle.charAt(<span class="built_in">j</span>))<span class="built_in">j</span>=next[<span class="built_in">j</span><span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span>(haystack.charAt(<span class="built_in">i</span>)==needle.charAt(<span class="built_in">j</span>)) &#123;</span><br><span class="line">				<span class="built_in">j</span>++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">j</span>==needle.<span class="built_in">length</span>())<span class="keyword">return</span> <span class="built_in">i</span>-needle.<span class="built_in">length</span>()+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>剑指offerII 76 快速排序</p>
<p>单调队列   918. 环形子数组的最大和   前缀和 + 单调队列</p>
<ol>
<li>跳跃游戏 VI</li>
</ol>
<p>双连通分量   1192</p>
<p>强连通分量  1489   tarjan<br><a href="https://blog.csdn.net/u013376508/article/details/50995675" target="_blank" rel="noopener">https://blog.csdn.net/u013376508/article/details/50995675</a><br><a href="https://blog.csdn.net/springrolls/article/details/101386049" target="_blank" rel="noopener">https://blog.csdn.net/springrolls/article/details/101386049</a><br><a href="https://www.cnblogs.com/nullzx/p/7968110.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/7968110.html</a></p>
<p>关键路径<br><a href="https://blog.csdn.net/CmdSmith/article/details/60960276" target="_blank" rel="noopener">https://blog.csdn.net/CmdSmith/article/details/60960276</a></p>
<p>计数排序</p>
<p>基数排序</p>
<p>线段树   673最长递增子序列个数</p>
<ol>
<li>区域和检索 - 数组可修改</li>
</ol>
<p>多线程</p>
<p>欧拉回路</p>
<p>马拉车    线性筛</p>
<p>线性探查  二次探查</p>
<p>B树  B+树<br><a href="https://www.jianshu.com/p/92d15df75027" target="_blank" rel="noopener">https://www.jianshu.com/p/92d15df75027</a></p>
<p>字节流和字符流<br><a href="https://blog.csdn.net/qq_35122713/article/details/88793019" target="_blank" rel="noopener">https://blog.csdn.net/qq_35122713/article/details/88793019</a></p>
<p>阻塞 非阻塞 同步  异步</p>
<p>1717贪心</p>
<p>1734</p>
<p>1695   前缀和   滑动窗口</p>
<p>1901 二分</p>
<p>打断标记为真时 park失效</p>
<p>锁  while(防止虚假唤醒)   wait</p>
<p>无索引行锁升级为表锁</p>
<p>show processlist</p>
<p>in走索引 not in 不走</p>
<p>大批量插入数据<br>主键顺序<br>关闭唯一性校验<br>设置手动提交事务</p>
<p>insert</p>
<p>like<br>前缀  覆盖索引</p>
<p>order by<br>统一升序，统一降序  和索引顺序一致 覆盖索引</p>
<p>group by<br> 用order by null 覆盖索引</p>
<p>建议用union替换or</p>
<p>索引提示<br>use index,ignore index,force index(针对全表扫描不走索引时)</p>
<p>java图邻接链表实现<br><a href="https://www.jianshu.com/p/3b09a37cf16d" target="_blank" rel="noopener">https://www.jianshu.com/p/3b09a37cf16d</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis框架学习]]></title>
      <url>/p/800a4/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hibernate高并发-低延迟-批处理不好-采用Mybatis"><a href="#Hibernate高并发-低延迟-批处理不好-采用Mybatis" class="headerlink" title="Hibernate高并发 低延迟 批处理不好 采用Mybatis"></a>Hibernate高并发 低延迟 批处理不好 采用Mybatis</h1><p>映射配置文件   Mapper接口<br>动态sql  scripting模块   占位符</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker学习]]></title>
      <url>/p/7qvuz/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty框架学习]]></title>
      <url>/p/7qvp7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多线程和网络编程    Reactor模式   通信  java内存模型  并发编程<br>同步 （需要1个额外线程询问是否完成）<br>阻塞  客户端：IO线程=1：1<br>非阻塞  客户端：IO线程=M：1<br>BIO(同步阻塞I/O)</p>
<p>AIO(异步非阻塞I/O)</p>
<p>NIO（New I/O）</p>
<p>Selector   多路复用<br>ByteBuffer  SocketChannel ServerSocketChannel<br>Hadoop RPC框架avro使用Netty作为底层通信框架</p>
<p>Netty入门</p>
<p>TCP 粘包/拆包问题解决之道</p>
<p>分隔符和定长解码器应用</p>
<p><strong>搭建Netty开发环境</strong></p>
<blockquote>
<p><a href="https://netty.io/" target="_blank" rel="noopener">Netty官网</a></p>
</blockquote>
<p>读半包问题</p>
<p>Netty编解码功能</p>
<p>java序列化   Java对象   字节数组   Serializable接口</p>
<p>HTTP协议   UDP协议   WebSocket协议   文件传输</p>
<p>字典树</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[elasticSearch学习]]></title>
      <url>/p/7q7i2/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>基于lucene</p>
</blockquote>
<p>创建索引 搜索<br>倒排索引<br>文本分析 分析器由分词器，过滤器，字符映射器组成</p>
<p><strong>Lucene查询语言</strong></p>
<p>前缀查询(prefix query)不会被分析<br>匹配查询(map query)会被分析</p>
<p>查询类型</p>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询  ~"></a>模糊查询  ~</h2><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>[]带边界  {}不带边界</p>
<p>索引分片,复制机制及其配置</p>
<p><strong>ElasticSeaarch基本概念</strong></p>
<p>索引，文档，映射，类型，节点，集群，分片，副本，网关</p>
<p>默认评分公式<br>二次评分<br>排序<br>查询重写</p>
]]></content>
      
        
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mall-learning]]></title>
      <url>/p/7q1i5/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>mall-learning</p>
<p>spring-security  登录认证   JWT<br>Swagger-UI<br>整合SpringTask实现定时任务   （Quartz）<br>elasticsearch 实现商品搜索</p>
<p>Cron表达式</p>
<p>只需要在配置类中添加一个@EnableScheduling注解即可开启SpringTask的定时任务能力。</p>
<p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，可用于实现全文搜索和实时数据统计。</p>
<p>Spring Data Elasticsearch是Spring提供的一种以Spring Data风格来操作数据存储的方式，它可以避免编写大量的样板代码。</p>
<p>mall整合Mongodb实现文档操作</p>
<p>安装Robo 3T(Robomongo)MongoDB可视化工具</p>
<p>mall整合RabbitMQ实现延迟消息</p>
<p>官方手册</p>
<p>Lombok插件   交换机  队列</p>
<p>mall整合OSS实现文件上传    服务端签名后前端直传的相关说明</p>
<p>对象存储    </p>
<p>CORS全称Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问的那个资源就会遇到跨域问题。</p>
<p>springboot处理校验逻辑两种方式<br>Hibernate Validator   Vuex</p>
<p>Elasticsearch  DSL语句<br>Logstash，用于收集日志</p>
<p>RabbitMQ消息模型<br><img src="/images/RabbitMQ.jpg" alt="ss"><br><img src="/images/图像融合.jpg" alt="dwt2函数"></p>
<p>SpringCloud为开发人员提供了快速构建分布式系统架构的工具，例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态等。</p>
<p>Spring Boot Admin</p>
<p>Spring Cloud Alibaba：Nacos 作为注册中心和配置中心使用</p>
<p>Spring Boot Admin不仅可以监控单体应用，还可以和Spring Cloud的注册中心相结合来监控微服务应用。</p>
<p>Spring Cloud Security：Oauth2使用入门</p>
<p>单点登录（Single Sign On）指的是当有多个系统需要登录时，用户只需登录一个系统，就可以访问其他需要登录的系统而无需登录。</p>
<p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。 Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>使用Seata彻底解决Spring Cloud中的分布式事务问题！</p>
<p>Spring Cloud Gateway：新一代API网关服务</p>
<p>Spring Cloud Consul：服务治理与配置中心</p>
<p>Zuul  网关</p>
<p>自动化部署（Jenkins）</p>
<p>Spring Cloud OpenFeign：基于Ribbon和Hystrix的声明式服务调用</p>
<p>Feign是声明式的服务调用工具  Hystrix服务容错 </p>
<p>Ribbon提供负载均衡</p>
<p>Spring Cloud Eureka：服务注册与发现</p>
<p>DockerFile<br>使用Docker Compose部署SpringBoot应用<br>写网络结构消融实验部分和conclusion,experiments分析   画图 整合</p>
<p>服务治理<br>服务注册中心（单节点  高可用） 服务提供者  服务消费者</p>
<p>@EnableEurekaServer</p>
<p>消息代理（RabbitMQ RocketMQ Kafka ActiveMQ）</p>
<p>RESTful API 设计指南<br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p>
<p>缓存的出现加快了数据查询的速度，同时增加了维护成本，建议使用在高频读低频写的数据上。<br>使用不当可能会出现数据不一致的问题，请谨慎使用。</p>
<p>maven的项目继承依赖</p>
<p>ZooKeeper的安装模式分为三种，分别为：单机模式（stand-alone）、集群模式和集群伪分布模式。</p>
<p>Dubbo是：</p>
<p>一款分布式服务框架<br>高性能和透明化的RPC远程服务调用方案<br>SOA服务治理方案</p>
<p>Dubbo提供的注册中心有如下几种类型可供选择：</p>
<p>Multicast注册中心<br>Zookeeper注册中心<br>Redis注册中心<br>Simple注册中心</p>
<p>多提供者多消费者情况   dubbo-admin安装和使用<br>Dubbo：搭建管理控制台(dubbo-admin)</p>
<p>开源的Dubbo的服务管理控制台是阿里巴巴内部裁剪版本，<br>开源部分主要包含：路由规则/动态配置/服务降级/访问控制/权重调整/负载均衡等管理功能。</p>
<p>git init<br>git add<br>git commit -m “first commit”<br>git remote add origin github网址<br>git push -u origin master</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[随便测试]]></title>
      <url>/p/7q0bl/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[语义分割]]></title>
      <url>/p/7nitr/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[推荐系统学习]]></title>
      <url>/p/7ci5l/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[牛客网刷题目录.md]]></title>
      <url>/p/7ax53/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p align="center" color="black"><img width="300" src="https://static.nowcoder.com/images/res/logo/logo-v3.png"></p><p></p>
<h3 align="center">My accepted nowcoder solutions</h3>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">标题</th>
<th style="text-align:center">代码地址</th>
<th style="text-align:center">使用语言</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><a href="nowcoder/1-获取所有员工的em.md">获取所有员工的em</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50171705" target="_blank" rel="noopener">获取所有员工的em</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><a href="nowcoder/2-获取有奖金的员工相.md">获取有奖金的员工相</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50171377" target="_blank" rel="noopener">获取有奖金的员工相</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><a href="nowcoder/3-对于employe.md">对于employe</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50171140" target="_blank" rel="noopener">对于employe</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><a href="nowcoder/4-统计salary的.md">统计salary的</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50170957" target="_blank" rel="noopener">统计salary的</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><a href="nowcoder/5-查找字符串&#39;10,.md">查找字符串’10,</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50170718" target="_blank" rel="noopener">查找字符串’10,</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><a href="nowcoder/6-针对库中的所有表生.md">针对库中的所有表生</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50170552" target="_blank" rel="noopener">针对库中的所有表生</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><a href="nowcoder/7-将所有获取奖金的员.md">将所有获取奖金的员</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50170049" target="_blank" rel="noopener">将所有获取奖金的员</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><a href="nowcoder/8-如何获取emp_v.md">如何获取emp_v</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50168893" target="_blank" rel="noopener">如何获取emp_v</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><a href="nowcoder/9-在audit表上创.md">在audit表上创</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50168765" target="_blank" rel="noopener">在audit表上创</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center"><a href="nowcoder/10-将titles_t.md">将titles_t</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50167346" target="_blank" rel="noopener">将titles_t</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><a href="nowcoder/11-将id=5以及em.md">将id=5以及em</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50167267" target="_blank" rel="noopener">将id=5以及em</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"><a href="nowcoder/12-将所有to_dat.md">将所有to_dat</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50167103" target="_blank" rel="noopener">将所有to_dat</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><a href="nowcoder/13-删除emp_no重.md">删除emp_no重</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50166867" target="_blank" rel="noopener">删除emp_no重</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center"><a href="nowcoder/14-构造一个触发器au.md">构造一个触发器au</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50166005" target="_blank" rel="noopener">构造一个触发器au</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><a href="nowcoder/15-在last_upd.md">在last_upd</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50165797" target="_blank" rel="noopener">在last_upd</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center"><a href="nowcoder/16-针对上面的sala.md">针对上面的sala</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50165444" target="_blank" rel="noopener">针对上面的sala</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center"><a href="nowcoder/17-针对actor表创.md">针对actor表创</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50163897" target="_blank" rel="noopener">针对actor表创</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center"><a href="nowcoder/18-对first_na.md">对first_na</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50163598" target="_blank" rel="noopener">对first_na</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center"><a href="nowcoder/19-创建一个actor.md">创建一个actor</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50163075" target="_blank" rel="noopener">创建一个actor</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center"><a href="nowcoder/20-批量插入数据，不使.md">批量插入数据，不使</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50162668" target="_blank" rel="noopener">批量插入数据，不使</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center"><a href="nowcoder/21-批量插入数据.md">批量插入数据</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50162415" target="_blank" rel="noopener">批量插入数据</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center"><a href="nowcoder/22-创建一个actor.md">创建一个actor</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50162185" target="_blank" rel="noopener">创建一个actor</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center"><a href="nowcoder/23-将employee.md">将employee</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50161859" target="_blank" rel="noopener">将employee</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center"><a href="nowcoder/24-查找所有员工的la.md">查找所有员工的la</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50161410" target="_blank" rel="noopener">查找所有员工的la</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center"><a href="nowcoder/25-获取当前薪水第二多.md">获取当前薪水第二多</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50160644" target="_blank" rel="noopener">获取当前薪水第二多</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center"><a href="nowcoder/26-统计出当前各个ti.md">统计出当前各个ti</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50159984" target="_blank" rel="noopener">统计出当前各个ti</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center"><a href="nowcoder/27-查找employe.md">查找employe</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50159763" target="_blank" rel="noopener">查找employe</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:center"><a href="nowcoder/28-统计各个部门对应员.md">统计各个部门对应员</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50159691" target="_blank" rel="noopener">统计各个部门对应员</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center"><a href="nowcoder/29-查找所有员工自入职.md">查找所有员工自入职</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50148184" target="_blank" rel="noopener">查找所有员工自入职</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center"><a href="nowcoder/30-获取当前薪水第二多.md">获取当前薪水第二多</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50147953" target="_blank" rel="noopener">获取当前薪水第二多</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center"><a href="nowcoder/31-查找所有已经分配部.md">查找所有已经分配部</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50147269" target="_blank" rel="noopener">查找所有已经分配部</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:center"><a href="nowcoder/32-获取所有非mana.md">获取所有非mana</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50146921" target="_blank" rel="noopener">获取所有非mana</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td style="text-align:center"><a href="nowcoder/33-获取所有部门当前m.md">获取所有部门当前m</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50146569" target="_blank" rel="noopener">获取所有部门当前m</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td style="text-align:center"><a href="nowcoder/34-找出所有员工当前薪.md">找出所有员工当前薪</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50146088" target="_blank" rel="noopener">找出所有员工当前薪</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">35</td>
<td style="text-align:center"><a href="nowcoder/35-查找入职员工时间排.md">查找入职员工时间排</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50145346" target="_blank" rel="noopener">查找入职员工时间排</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">36</td>
<td style="text-align:center"><a href="nowcoder/36-查找最晚入职员工的.md">查找最晚入职员工的</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=50144866" target="_blank" rel="noopener">查找最晚入职员工的</a></td>
<td style="text-align:center">Sql</td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td style="text-align:center"><a href="nowcoder/37-数字构造.md">数字构造</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49118258" target="_blank" rel="noopener">数字构造</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">38</td>
<td style="text-align:center"><a href="nowcoder/38-骰子游戏.md">骰子游戏</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49117634" target="_blank" rel="noopener">骰子游戏</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">39</td>
<td style="text-align:center"><a href="nowcoder/39-神奇数.md">神奇数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49116843" target="_blank" rel="noopener">神奇数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td style="text-align:center"><a href="nowcoder/40-区间表达.md">区间表达</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49115751" target="_blank" rel="noopener">区间表达</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">41</td>
<td style="text-align:center"><a href="nowcoder/41-字符串价值.md">字符串价值</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49114900" target="_blank" rel="noopener">字符串价值</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">42</td>
<td style="text-align:center"><a href="nowcoder/42-疯狂队列.md">疯狂队列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49114697" target="_blank" rel="noopener">疯狂队列</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">43</td>
<td style="text-align:center"><a href="nowcoder/43-缺失的括号.md">缺失的括号</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49114431" target="_blank" rel="noopener">缺失的括号</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">44</td>
<td style="text-align:center"><a href="nowcoder/44-缩写.md">缩写</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49114351" target="_blank" rel="noopener">缩写</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">45</td>
<td style="text-align:center"><a href="nowcoder/45-红和绿.md">红和绿</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49113037" target="_blank" rel="noopener">红和绿</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">46</td>
<td style="text-align:center"><a href="nowcoder/46-数字字符.md">数字字符</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49112706" target="_blank" rel="noopener">数字字符</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">47</td>
<td style="text-align:center"><a href="nowcoder/47-单词缩写.md">单词缩写</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49112564" target="_blank" rel="noopener">单词缩写</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center"><a href="nowcoder/48-幸运数字.md">幸运数字</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49112353" target="_blank" rel="noopener">幸运数字</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">49</td>
<td style="text-align:center"><a href="nowcoder/49-买橘子.md">买橘子</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49112012" target="_blank" rel="noopener">买橘子</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">50</td>
<td style="text-align:center"><a href="nowcoder/50-分割后处理.md">分割后处理</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49111312" target="_blank" rel="noopener">分割后处理</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">51</td>
<td style="text-align:center"><a href="nowcoder/51-寻找丑数.md">寻找丑数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49111061" target="_blank" rel="noopener">寻找丑数</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">52</td>
<td style="text-align:center"><a href="nowcoder/52-给定整数序列求连续.md">给定整数序列求连续</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49110819" target="_blank" rel="noopener">给定整数序列求连续</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">53</td>
<td style="text-align:center"><a href="nowcoder/53-整数无序数组求第K.md">整数无序数组求第K</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49110466" target="_blank" rel="noopener">整数无序数组求第K</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">54</td>
<td style="text-align:center"><a href="nowcoder/54-整数成绩最大化.md">整数成绩最大化</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49109205" target="_blank" rel="noopener">整数成绩最大化</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">55</td>
<td style="text-align:center"><a href="nowcoder/55-字符覆盖.md">字符覆盖</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49108229" target="_blank" rel="noopener">字符覆盖</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">56</td>
<td style="text-align:center"><a href="nowcoder/56-完成括号匹配.md">完成括号匹配</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49106054" target="_blank" rel="noopener">完成括号匹配</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">57</td>
<td style="text-align:center"><a href="nowcoder/57-字符串复制.md">字符串复制</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49105499" target="_blank" rel="noopener">字符串复制</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">58</td>
<td style="text-align:center"><a href="nowcoder/58-3和5的倍数.md">3和5的倍数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49097760" target="_blank" rel="noopener">3和5的倍数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">59</td>
<td style="text-align:center"><a href="nowcoder/59-字符串提取.md">字符串提取</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49096784" target="_blank" rel="noopener">字符串提取</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">60</td>
<td style="text-align:center"><a href="nowcoder/60-字母数字混合排序.md">字母数字混合排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49096461" target="_blank" rel="noopener">字母数字混合排序</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">61</td>
<td style="text-align:center"><a href="nowcoder/61-最大差值.md">最大差值</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49095486" target="_blank" rel="noopener">最大差值</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">62</td>
<td style="text-align:center"><a href="nowcoder/62-连线游戏.md">连线游戏</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49094613" target="_blank" rel="noopener">连线游戏</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">63</td>
<td style="text-align:center"><a href="nowcoder/63-序列操作.md">序列操作</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49094071" target="_blank" rel="noopener">序列操作</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">64</td>
<td style="text-align:center"><a href="nowcoder/64-题目列表.md">题目列表</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49093507" target="_blank" rel="noopener">题目列表</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">65</td>
<td style="text-align:center"><a href="nowcoder/65-交错序列.md">交错序列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49092561" target="_blank" rel="noopener">交错序列</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">66</td>
<td style="text-align:center"><a href="nowcoder/66-超链接.md">超链接</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49092151" target="_blank" rel="noopener">超链接</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">67</td>
<td style="text-align:center"><a href="nowcoder/67-人民币转换.md">人民币转换</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49090653" target="_blank" rel="noopener">人民币转换</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">68</td>
<td style="text-align:center"><a href="nowcoder/68-记票统计.md">记票统计</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49090603" target="_blank" rel="noopener">记票统计</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">69</td>
<td style="text-align:center"><a href="nowcoder/69-201301JA.md">201301 JA</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49090203" target="_blank" rel="noopener">201301 JA</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">70</td>
<td style="text-align:center"><a href="nowcoder/70-整形数组合并.md">整形数组合并</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49089897" target="_blank" rel="noopener">整形数组合并</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">71</td>
<td style="text-align:center"><a href="nowcoder/71-图片整理.md">图片整理</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49054081" target="_blank" rel="noopener">图片整理</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">72</td>
<td style="text-align:center"><a href="nowcoder/72-删除字符串中出现次.md">删除字符串中出现次</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49053893" target="_blank" rel="noopener">删除字符串中出现次</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">73</td>
<td style="text-align:center"><a href="nowcoder/73-输入一行字符，分别.md">输入一行字符，分别</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49052216" target="_blank" rel="noopener">输入一行字符，分别</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">74</td>
<td style="text-align:center"><a href="nowcoder/74-整数与IP地址间的.md">整数与IP地址间的</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49052117" target="_blank" rel="noopener">整数与IP地址间的</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">75</td>
<td style="text-align:center"><a href="nowcoder/75-字符串加解密.md">字符串加解密</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49051804" target="_blank" rel="noopener">字符串加解密</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">76</td>
<td style="text-align:center"><a href="nowcoder/76-查找兄弟单词.md">查找兄弟单词</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49050174" target="_blank" rel="noopener">查找兄弟单词</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">77</td>
<td style="text-align:center"><a href="nowcoder/77-坐标移动.md">坐标移动</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49049615" target="_blank" rel="noopener">坐标移动</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">78</td>
<td style="text-align:center"><a href="nowcoder/78-购物单.md">购物单</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49047729" target="_blank" rel="noopener">购物单</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">79</td>
<td style="text-align:center"><a href="nowcoder/79-字串的连接最长路径.md">字串的连接最长路径</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49047102" target="_blank" rel="noopener">字串的连接最长路径</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">80</td>
<td style="text-align:center"><a href="nowcoder/80-字符串反转.md">字符串反转</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49046068" target="_blank" rel="noopener">字符串反转</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">81</td>
<td style="text-align:center"><a href="nowcoder/81-数字颠倒.md">数字颠倒</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49045916" target="_blank" rel="noopener">数字颠倒</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">82</td>
<td style="text-align:center"><a href="nowcoder/82-计算字符个数.md">计算字符个数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49023570" target="_blank" rel="noopener">计算字符个数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">83</td>
<td style="text-align:center"><a href="nowcoder/83-字符串最后一个单词.md">字符串最后一个单词</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=49022812" target="_blank" rel="noopener">字符串最后一个单词</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">84</td>
<td style="text-align:center"><a href="nowcoder/84-清除行列.md">清除行列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46327824" target="_blank" rel="noopener">清除行列</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">85</td>
<td style="text-align:center"><a href="nowcoder/85-井字棋.md">井字棋</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46326796" target="_blank" rel="noopener">井字棋</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">86</td>
<td style="text-align:center"><a href="nowcoder/86-机器人走方格I.md">机器人走方格I</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46316199" target="_blank" rel="noopener">机器人走方格I</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">87</td>
<td style="text-align:center"><a href="nowcoder/87-无判断max.md">无判断max</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46315954" target="_blank" rel="noopener">无判断max</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">88</td>
<td style="text-align:center"><a href="nowcoder/88-另类加法.md">另类加法</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46314373" target="_blank" rel="noopener">另类加法</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">89</td>
<td style="text-align:center"><a href="nowcoder/89-最接近的数.md">最接近的数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46313992" target="_blank" rel="noopener">最接近的数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">90</td>
<td style="text-align:center"><a href="nowcoder/90-整数转化.md">整数转化</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46313530" target="_blank" rel="noopener">整数转化</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">91</td>
<td style="text-align:center"><a href="nowcoder/91-奇偶位交换.md">奇偶位交换</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46313223" target="_blank" rel="noopener">奇偶位交换</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">92</td>
<td style="text-align:center"><a href="nowcoder/92-链表分割.md">链表分割</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46312589" target="_blank" rel="noopener">链表分割</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">93</td>
<td style="text-align:center"><a href="nowcoder/93-链式A+B.md">链式A+B</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46311663" target="_blank" rel="noopener">链式A+B</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">94</td>
<td style="text-align:center"><a href="nowcoder/94-子串判断.md">子串判断</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46310797" target="_blank" rel="noopener">子串判断</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">95</td>
<td style="text-align:center"><a href="nowcoder/95-最大子方阵.md">最大子方阵</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46310459" target="_blank" rel="noopener">最大子方阵</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">96</td>
<td style="text-align:center"><a href="nowcoder/96-最大和子矩阵.md">最大和子矩阵</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46310123" target="_blank" rel="noopener">最大和子矩阵</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">97</td>
<td style="text-align:center"><a href="nowcoder/97-数组中的逆序对.md">数组中的逆序对</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46309876" target="_blank" rel="noopener">数组中的逆序对</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">98</td>
<td style="text-align:center"><a href="nowcoder/98-实时中位数.md">实时中位数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46309152" target="_blank" rel="noopener">实时中位数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">99</td>
<td style="text-align:center"><a href="nowcoder/99-二叉树平衡检查.md">二叉树平衡检查</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46307870" target="_blank" rel="noopener">二叉树平衡检查</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center"><a href="nowcoder/100-双栈排序.md">双栈排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46307076" target="_blank" rel="noopener">双栈排序</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">101</td>
<td style="text-align:center"><a href="nowcoder/101-回文链表.md">回文链表</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46306339" target="_blank" rel="noopener">回文链表</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">102</td>
<td style="text-align:center"><a href="nowcoder/102-基本字符串压缩.md">基本字符串压缩</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46305819" target="_blank" rel="noopener">基本字符串压缩</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">103</td>
<td style="text-align:center"><a href="nowcoder/103-确定字符互异.md">确定字符互异</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46303142" target="_blank" rel="noopener">确定字符互异</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">104</td>
<td style="text-align:center"><a href="nowcoder/104-合并表记录.md">合并表记录</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46258845" target="_blank" rel="noopener">合并表记录</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">105</td>
<td style="text-align:center"><a href="nowcoder/105-提取不重复的整数.md">提取不重复的整数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46257610" target="_blank" rel="noopener">提取不重复的整数</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">106</td>
<td style="text-align:center"><a href="nowcoder/106-字符个数统计.md">字符个数统计</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46257287" target="_blank" rel="noopener">字符个数统计</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">107</td>
<td style="text-align:center"><a href="nowcoder/107-句子逆序.md">句子逆序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46257088" target="_blank" rel="noopener">句子逆序</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">108</td>
<td style="text-align:center"><a href="nowcoder/108-矩阵乘法.md">矩阵乘法</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46256436" target="_blank" rel="noopener">矩阵乘法</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">109</td>
<td style="text-align:center"><a href="nowcoder/109-字符串排序.md">字符串排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46254636" target="_blank" rel="noopener">字符串排序</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">110</td>
<td style="text-align:center"><a href="nowcoder/110-字符串合并处理.md">字符串合并处理</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46254141" target="_blank" rel="noopener">字符串合并处理</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">111</td>
<td style="text-align:center"><a href="nowcoder/111-201301JA.md">201301 JA</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46253677" target="_blank" rel="noopener">201301 JA</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">112</td>
<td style="text-align:center"><a href="nowcoder/112-统计每个月兔子的总.md">统计每个月兔子的总</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46253364" target="_blank" rel="noopener">统计每个月兔子的总</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">113</td>
<td style="text-align:center"><a href="nowcoder/113-字符逆序.md">字符逆序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46253204" target="_blank" rel="noopener">字符逆序</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">114</td>
<td style="text-align:center"><a href="nowcoder/114-求int型正整数在.md">求int型正整数在</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46252677" target="_blank" rel="noopener">求int型正整数在</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">115</td>
<td style="text-align:center"><a href="nowcoder/115-单词识别.md">单词识别</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46161641" target="_blank" rel="noopener">单词识别</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">116</td>
<td style="text-align:center"><a href="nowcoder/116-农夫、羊、菜和狼的.md">农夫、羊、菜和狼的</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46161296" target="_blank" rel="noopener">农夫、羊、菜和狼的</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">117</td>
<td style="text-align:center"><a href="nowcoder/117-对称平方数1.md">对称平方数1</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46160605" target="_blank" rel="noopener">对称平方数1</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">118</td>
<td style="text-align:center"><a href="nowcoder/118-反序数.md">反序数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46160427" target="_blank" rel="noopener">反序数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">119</td>
<td style="text-align:center"><a href="nowcoder/119-加法等式.md">加法等式</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46160372" target="_blank" rel="noopener">加法等式</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">120</td>
<td style="text-align:center"><a href="nowcoder/120-反序相等.md">反序相等</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46159832" target="_blank" rel="noopener">反序相等</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">121</td>
<td style="text-align:center"><a href="nowcoder/121-对称平方数.md">对称平方数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46158525" target="_blank" rel="noopener">对称平方数</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">122</td>
<td style="text-align:center"><a href="nowcoder/122-三角形相加.md">三角形相加</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46157574" target="_blank" rel="noopener">三角形相加</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">123</td>
<td style="text-align:center"><a href="nowcoder/123-ZOJ.md">ZOJ</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46154513" target="_blank" rel="noopener">ZOJ</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">124</td>
<td style="text-align:center"><a href="nowcoder/124-开门人和关门人.md">开门人和关门人</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46152617" target="_blank" rel="noopener">开门人和关门人</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">125</td>
<td style="text-align:center"><a href="nowcoder/125-最大报销额.md">最大报销额</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46151619" target="_blank" rel="noopener">最大报销额</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">126</td>
<td style="text-align:center"><a href="nowcoder/126-字母统计.md">字母统计</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46151187" target="_blank" rel="noopener">字母统计</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">127</td>
<td style="text-align:center"><a href="nowcoder/127-密码翻译.md">密码翻译</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46126462" target="_blank" rel="noopener">密码翻译</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">128</td>
<td style="text-align:center"><a href="nowcoder/128-完数VS盈数.md">完数VS盈数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46124652" target="_blank" rel="noopener">完数VS盈数</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">129</td>
<td style="text-align:center"><a href="nowcoder/129-数字求和.md">数字求和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46124001" target="_blank" rel="noopener">数字求和</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">130</td>
<td style="text-align:center"><a href="nowcoder/130-谁是你的潜在朋友.md">谁是你的潜在朋友</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46123525" target="_blank" rel="noopener">谁是你的潜在朋友</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">131</td>
<td style="text-align:center"><a href="nowcoder/131-查找学生信息.md">查找学生信息</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46122823" target="_blank" rel="noopener">查找学生信息</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">132</td>
<td style="text-align:center"><a href="nowcoder/132-神奇的口袋.md">神奇的口袋</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46121748" target="_blank" rel="noopener">神奇的口袋</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">133</td>
<td style="text-align:center"><a href="nowcoder/133-全排列.md">全排列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46120315" target="_blank" rel="noopener">全排列</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">134</td>
<td style="text-align:center"><a href="nowcoder/134-最简真分数.md">最简真分数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46119907" target="_blank" rel="noopener">最简真分数</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">135</td>
<td style="text-align:center"><a href="nowcoder/135-与7无关的数.md">与7无关的数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46119707" target="_blank" rel="noopener">与7无关的数</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">136</td>
<td style="text-align:center"><a href="nowcoder/136-吃糖果.md">吃糖果</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46118908" target="_blank" rel="noopener">吃糖果</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">137</td>
<td style="text-align:center"><a href="nowcoder/137-整数奇偶排序.md">整数奇偶排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46118303" target="_blank" rel="noopener">整数奇偶排序</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">138</td>
<td style="text-align:center"><a href="nowcoder/138-字符串排序.md">字符串排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46117538" target="_blank" rel="noopener">字符串排序</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">139</td>
<td style="text-align:center"><a href="nowcoder/139-最大上升子序列和.md">最大上升子序列和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46116367" target="_blank" rel="noopener">最大上升子序列和</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">140</td>
<td style="text-align:center"><a href="nowcoder/140-学分绩点.md">学分绩点</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46115759" target="_blank" rel="noopener">学分绩点</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">141</td>
<td style="text-align:center"><a href="nowcoder/141-打印极值点下标.md">打印极值点下标</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46115265" target="_blank" rel="noopener">打印极值点下标</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">142</td>
<td style="text-align:center"><a href="nowcoder/142-日志排序.md">日志排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46114964" target="_blank" rel="noopener">日志排序</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">143</td>
<td style="text-align:center"><a href="nowcoder/143-小白鼠排队.md">小白鼠排队</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46114616" target="_blank" rel="noopener">小白鼠排队</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">144</td>
<td style="text-align:center"><a href="nowcoder/144-中位数.md">中位数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46114412" target="_blank" rel="noopener">中位数</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">145</td>
<td style="text-align:center"><a href="nowcoder/145-球的半径和体积.md">球的半径和体积</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46114242" target="_blank" rel="noopener">球的半径和体积</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">146</td>
<td style="text-align:center"><a href="nowcoder/146-大整数的因子.md">大整数的因子</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46112969" target="_blank" rel="noopener">大整数的因子</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">147</td>
<td style="text-align:center"><a href="nowcoder/147-递推数列.md">递推数列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=46112215" target="_blank" rel="noopener">递推数列</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">148</td>
<td style="text-align:center"><a href="nowcoder/148-最小邮票数.md">最小邮票数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45791130" target="_blank" rel="noopener">最小邮票数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">149</td>
<td style="text-align:center"><a href="nowcoder/149-复数.md">复数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45790871" target="_blank" rel="noopener">复数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">150</td>
<td style="text-align:center"><a href="nowcoder/150-N阶楼梯上楼问题.md">N阶楼梯上楼问题</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45788924" target="_blank" rel="noopener">N阶楼梯上楼问题</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">151</td>
<td style="text-align:center"><a href="nowcoder/151-守形数.md">守形数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45787475" target="_blank" rel="noopener">守形数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">152</td>
<td style="text-align:center"><a href="nowcoder/152-统计字符.md">统计字符</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45786710" target="_blank" rel="noopener">统计字符</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">153</td>
<td style="text-align:center"><a href="nowcoder/153-数字反转.md">数字反转</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45785697" target="_blank" rel="noopener">数字反转</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">154</td>
<td style="text-align:center"><a href="nowcoder/154-分段函数.md">分段函数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45783701" target="_blank" rel="noopener">分段函数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">155</td>
<td style="text-align:center"><a href="nowcoder/155-进制转换2.md">进制转换2</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45783540" target="_blank" rel="noopener">进制转换2</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">156</td>
<td style="text-align:center"><a href="nowcoder/156-最长&amp;最短文本.md">最长&amp;最短文本</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45783092" target="_blank" rel="noopener">最长&amp;最短文本</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">157</td>
<td style="text-align:center"><a href="nowcoder/157-哈夫曼树.md">哈夫曼树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45781836" target="_blank" rel="noopener">哈夫曼树</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">158</td>
<td style="text-align:center"><a href="nowcoder/158-最小长方形.md">最小长方形</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45778839" target="_blank" rel="noopener">最小长方形</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">159</td>
<td style="text-align:center"><a href="nowcoder/159-统计同成绩学生人数.md">统计同成绩学生人数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45777136" target="_blank" rel="noopener">统计同成绩学生人数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">160</td>
<td style="text-align:center"><a href="nowcoder/160-二次方程计算器.md">二次方程计算器</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45776877" target="_blank" rel="noopener">二次方程计算器</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">161</td>
<td style="text-align:center"><a href="nowcoder/161-计算表达式.md">计算表达式</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45776406" target="_blank" rel="noopener">计算表达式</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">162</td>
<td style="text-align:center"><a href="nowcoder/162-进制转换.md">进制转换</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45775808" target="_blank" rel="noopener">进制转换</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">163</td>
<td style="text-align:center"><a href="nowcoder/163-拦截导弹.md">拦截导弹</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45775186" target="_blank" rel="noopener">拦截导弹</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">164</td>
<td style="text-align:center"><a href="nowcoder/164-买房子.md">买房子</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45773427" target="_blank" rel="noopener">买房子</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">165</td>
<td style="text-align:center"><a href="nowcoder/165-围圈报数.md">围圈报数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45771174" target="_blank" rel="noopener">围圈报数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">166</td>
<td style="text-align:center"><a href="nowcoder/166-众数.md">众数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45770021" target="_blank" rel="noopener">众数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">167</td>
<td style="text-align:center"><a href="nowcoder/167-阶乘.md">阶乘</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45734996" target="_blank" rel="noopener">阶乘</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">168</td>
<td style="text-align:center"><a href="nowcoder/168-整数和.md">整数和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45734904" target="_blank" rel="noopener">整数和</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">169</td>
<td style="text-align:center"><a href="nowcoder/169-字符串连接.md">字符串连接</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45734278" target="_blank" rel="noopener">字符串连接</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">170</td>
<td style="text-align:center"><a href="nowcoder/170-完数.md">完数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45734159" target="_blank" rel="noopener">完数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">171</td>
<td style="text-align:center"><a href="nowcoder/171-放苹果.md">放苹果</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45676749" target="_blank" rel="noopener">放苹果</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">172</td>
<td style="text-align:center"><a href="nowcoder/172-进制转换.md">进制转换</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45676193" target="_blank" rel="noopener">进制转换</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">173</td>
<td style="text-align:center"><a href="nowcoder/173-abc.md">abc</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45675938" target="_blank" rel="noopener">abc</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">174</td>
<td style="text-align:center"><a href="nowcoder/174-最大子矩阵.md">最大子矩阵</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45675498" target="_blank" rel="noopener">最大子矩阵</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">175</td>
<td style="text-align:center"><a href="nowcoder/175-10进制VS2.md">10进制 VS 2</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45666396" target="_blank" rel="noopener">10进制 VS 2</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">176</td>
<td style="text-align:center"><a href="nowcoder/176-剩下的树.md">剩下的树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45665619" target="_blank" rel="noopener">剩下的树</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">177</td>
<td style="text-align:center"><a href="nowcoder/177-最大序列和.md">最大序列和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45665279" target="_blank" rel="noopener">最大序列和</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">178</td>
<td style="text-align:center"><a href="nowcoder/178-玛雅人的密码.md">玛雅人的密码</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=45664921" target="_blank" rel="noopener">玛雅人的密码</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">179</td>
<td style="text-align:center"><a href="nowcoder/179-回文串.md">回文串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39475375" target="_blank" rel="noopener">回文串</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">180</td>
<td style="text-align:center"><a href="nowcoder/180-有几个PAT（25.md">有几个PAT（25</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39459098" target="_blank" rel="noopener">有几个PAT（25</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">181</td>
<td style="text-align:center"><a href="nowcoder/181-第二大的数.md">第二大的数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39355038" target="_blank" rel="noopener">第二大的数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">182</td>
<td style="text-align:center"><a href="nowcoder/182-倒水.md">倒水</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39354952" target="_blank" rel="noopener">倒水</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">183</td>
<td style="text-align:center"><a href="nowcoder/183-斐波那契数列.md">斐波那契数列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39354745" target="_blank" rel="noopener">斐波那契数列</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">184</td>
<td style="text-align:center"><a href="nowcoder/184-2的N次方.md">2的N次方</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39353832" target="_blank" rel="noopener">2的N次方</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">185</td>
<td style="text-align:center"><a href="nowcoder/185-求素数.md">求素数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39353635" target="_blank" rel="noopener">求素数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">186</td>
<td style="text-align:center"><a href="nowcoder/186-排序.md">排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39351700" target="_blank" rel="noopener">排序</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">187</td>
<td style="text-align:center"><a href="nowcoder/187-合并符串.md">合并符串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39351555" target="_blank" rel="noopener">合并符串</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">188</td>
<td style="text-align:center"><a href="nowcoder/188-调整方阵.md">调整方阵</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39351357" target="_blank" rel="noopener">调整方阵</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">189</td>
<td style="text-align:center"><a href="nowcoder/189-找最小数.md">找最小数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39350586" target="_blank" rel="noopener">找最小数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">190</td>
<td style="text-align:center"><a href="nowcoder/190-素数.md">素数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39350454" target="_blank" rel="noopener">素数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">191</td>
<td style="text-align:center"><a href="nowcoder/191-找最小数.md">找最小数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39350184" target="_blank" rel="noopener">找最小数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">192</td>
<td style="text-align:center"><a href="nowcoder/192-数字之和.md">数字之和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39350058" target="_blank" rel="noopener">数字之和</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">193</td>
<td style="text-align:center"><a href="nowcoder/193-平方因子.md">平方因子</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39349965" target="_blank" rel="noopener">平方因子</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">194</td>
<td style="text-align:center"><a href="nowcoder/194-三角形的边.md">三角形的边</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39349660" target="_blank" rel="noopener">三角形的边</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">195</td>
<td style="text-align:center"><a href="nowcoder/195-字符串的反码.md">字符串的反码</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39349571" target="_blank" rel="noopener">字符串的反码</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">196</td>
<td style="text-align:center"><a href="nowcoder/196-链表中倒数第k个结.md">链表中倒数第k个结</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39349286" target="_blank" rel="noopener">链表中倒数第k个结</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">197</td>
<td style="text-align:center"><a href="nowcoder/197-简单计算器.md">简单计算器</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39324314" target="_blank" rel="noopener">简单计算器</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">198</td>
<td style="text-align:center"><a href="nowcoder/198-进制转换.md">进制转换</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39323794" target="_blank" rel="noopener">进制转换</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">199</td>
<td style="text-align:center"><a href="nowcoder/199-连通图.md">连通图</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39323529" target="_blank" rel="noopener">连通图</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center"><a href="nowcoder/200-N的阶乘.md">N的阶乘</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39322378" target="_blank" rel="noopener">N的阶乘</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">201</td>
<td style="text-align:center"><a href="nowcoder/201-特殊乘法.md">特殊乘法</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39322341" target="_blank" rel="noopener">特殊乘法</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">202</td>
<td style="text-align:center"><a href="nowcoder/202-计算两个矩阵的乘积.md">计算两个矩阵的乘积</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39322226" target="_blank" rel="noopener">计算两个矩阵的乘积</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">203</td>
<td style="text-align:center"><a href="nowcoder/203-字符串去特定字符.md">字符串去特定字符</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39321918" target="_blank" rel="noopener">字符串去特定字符</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">204</td>
<td style="text-align:center"><a href="nowcoder/204-欧拉回路.md">欧拉回路</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39321684" target="_blank" rel="noopener">欧拉回路</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">205</td>
<td style="text-align:center"><a href="nowcoder/205-最短路径问题.md">最短路径问题</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39321231" target="_blank" rel="noopener">最短路径问题</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">206</td>
<td style="text-align:center"><a href="nowcoder/206-字符串内排序.md">字符串内排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39314584" target="_blank" rel="noopener">字符串内排序</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">207</td>
<td style="text-align:center"><a href="nowcoder/207-字符串链接.md">字符串链接</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39314515" target="_blank" rel="noopener">字符串链接</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">208</td>
<td style="text-align:center"><a href="nowcoder/208-素数判定.md">素数判定</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39314461" target="_blank" rel="noopener">素数判定</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">209</td>
<td style="text-align:center"><a href="nowcoder/209-阶乘.md">阶乘</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39313644" target="_blank" rel="noopener">阶乘</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">210</td>
<td style="text-align:center"><a href="nowcoder/210-a+b.md">a+b</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39313161" target="_blank" rel="noopener">a+b</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">211</td>
<td style="text-align:center"><a href="nowcoder/211-矩阵转置.md">矩阵转置</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39312122" target="_blank" rel="noopener">矩阵转置</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">212</td>
<td style="text-align:center"><a href="nowcoder/212-比较奇偶数个数.md">比较奇偶数个数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39311983" target="_blank" rel="noopener">比较奇偶数个数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">213</td>
<td style="text-align:center"><a href="nowcoder/213-求最大值.md">求最大值</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39311370" target="_blank" rel="noopener">求最大值</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">214</td>
<td style="text-align:center"><a href="nowcoder/214-数组逆置.md">数组逆置</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39311295" target="_blank" rel="noopener">数组逆置</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">215</td>
<td style="text-align:center"><a href="nowcoder/215-找x.md">找x</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39310556" target="_blank" rel="noopener">找x</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">216</td>
<td style="text-align:center"><a href="nowcoder/216-互换最大最小数.md">互换最大最小数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39310358" target="_blank" rel="noopener">互换最大最小数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">217</td>
<td style="text-align:center"><a href="nowcoder/217-二叉树.md">二叉树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39309971" target="_blank" rel="noopener">二叉树</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">218</td>
<td style="text-align:center"><a href="nowcoder/218-反序输出.md">反序输出</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39309391" target="_blank" rel="noopener">反序输出</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">219</td>
<td style="text-align:center"><a href="nowcoder/219-求平均年龄.md">求平均年龄</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39308606" target="_blank" rel="noopener">求平均年龄</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">220</td>
<td style="text-align:center"><a href="nowcoder/220-八进制.md">八进制</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39308541" target="_blank" rel="noopener">八进制</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">221</td>
<td style="text-align:center"><a href="nowcoder/221-回文字符串.md">回文字符串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39308431" target="_blank" rel="noopener">回文字符串</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">222</td>
<td style="text-align:center"><a href="nowcoder/222-矩阵最大值.md">矩阵最大值</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39308223" target="_blank" rel="noopener">矩阵最大值</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">223</td>
<td style="text-align:center"><a href="nowcoder/223-对称矩阵.md">对称矩阵</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39307764" target="_blank" rel="noopener">对称矩阵</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">224</td>
<td style="text-align:center"><a href="nowcoder/224-二叉树遍历.md">二叉树遍历</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39307374" target="_blank" rel="noopener">二叉树遍历</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">225</td>
<td style="text-align:center"><a href="nowcoder/225-n的阶乘.md">n的阶乘</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39306199" target="_blank" rel="noopener">n的阶乘</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">226</td>
<td style="text-align:center"><a href="nowcoder/226-重建二叉树.md">重建二叉树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39303988" target="_blank" rel="noopener">重建二叉树</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">227</td>
<td style="text-align:center"><a href="nowcoder/227-栈的压入、弹出序列.md">栈的压入、弹出序列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39303484" target="_blank" rel="noopener">栈的压入、弹出序列</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">228</td>
<td style="text-align:center"><a href="nowcoder/228-矩形覆盖.md">矩形覆盖</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39301970" target="_blank" rel="noopener">矩形覆盖</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">229</td>
<td style="text-align:center"><a href="nowcoder/229-序列化二叉树.md">序列化二叉树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39299903" target="_blank" rel="noopener">序列化二叉树</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">230</td>
<td style="text-align:center"><a href="nowcoder/230-把二叉树打印成多行.md">把二叉树打印成多行</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39299748" target="_blank" rel="noopener">把二叉树打印成多行</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">231</td>
<td style="text-align:center"><a href="nowcoder/231-机器人的运动范围.md">机器人的运动范围</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39299050" target="_blank" rel="noopener">机器人的运动范围</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">232</td>
<td style="text-align:center"><a href="nowcoder/232-矩阵中的路径.md">矩阵中的路径</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39298723" target="_blank" rel="noopener">矩阵中的路径</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">233</td>
<td style="text-align:center"><a href="nowcoder/233-滑动窗口的最大值.md">滑动窗口的最大值</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39298403" target="_blank" rel="noopener">滑动窗口的最大值</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">234</td>
<td style="text-align:center"><a href="nowcoder/234-反转链表.md">反转链表</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39298069" target="_blank" rel="noopener">反转链表</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">235</td>
<td style="text-align:center"><a href="nowcoder/235-调整数组顺序使奇数.md">调整数组顺序使奇数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39297859" target="_blank" rel="noopener">调整数组顺序使奇数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">236</td>
<td style="text-align:center"><a href="nowcoder/236-平衡二叉树.md">平衡二叉树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39262857" target="_blank" rel="noopener">平衡二叉树</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">237</td>
<td style="text-align:center"><a href="nowcoder/237-数字在排序数组中出.md">数字在排序数组中出</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39262622" target="_blank" rel="noopener">数字在排序数组中出</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">238</td>
<td style="text-align:center"><a href="nowcoder/238-孩子们的游戏(圆圈">孩子们的游戏(圆圈</a>.md)</td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39262466" target="_blank" rel="noopener">孩子们的游戏(圆圈</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">239</td>
<td style="text-align:center"><a href="nowcoder/239-数组中只出现一次的.md">数组中只出现一次的</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39260452" target="_blank" rel="noopener">数组中只出现一次的</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">240</td>
<td style="text-align:center"><a href="nowcoder/240-二叉树的深度.md">二叉树的深度</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39259054" target="_blank" rel="noopener">二叉树的深度</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">241</td>
<td style="text-align:center"><a href="nowcoder/241-数组中出现次数超过.md">数组中出现次数超过</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39258050" target="_blank" rel="noopener">数组中出现次数超过</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">242</td>
<td style="text-align:center"><a href="nowcoder/242-从上往下打印二叉树.md">从上往下打印二叉树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39257326" target="_blank" rel="noopener">从上往下打印二叉树</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">243</td>
<td style="text-align:center"><a href="nowcoder/243-对称的二叉树.md">对称的二叉树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39254978" target="_blank" rel="noopener">对称的二叉树</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">244</td>
<td style="text-align:center"><a href="nowcoder/244-两个链表的第一个公.md">两个链表的第一个公</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39254891" target="_blank" rel="noopener">两个链表的第一个公</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">245</td>
<td style="text-align:center"><a href="nowcoder/245-第一个只出现一次的.md">第一个只出现一次的</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39252432" target="_blank" rel="noopener">第一个只出现一次的</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">246</td>
<td style="text-align:center"><a href="nowcoder/246-把数组排成最小的数.md">把数组排成最小的数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39252238" target="_blank" rel="noopener">把数组排成最小的数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">247</td>
<td style="text-align:center"><a href="nowcoder/247-整数中1出现的次数.md">整数中1出现的次数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39252152" target="_blank" rel="noopener">整数中1出现的次数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">248</td>
<td style="text-align:center"><a href="nowcoder/248-连续子数组的最大和.md">连续子数组的最大和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39251873" target="_blank" rel="noopener">连续子数组的最大和</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">249</td>
<td style="text-align:center"><a href="nowcoder/249-最小的K个数.md">最小的K个数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39251432" target="_blank" rel="noopener">最小的K个数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">250</td>
<td style="text-align:center"><a href="nowcoder/250-数值的整数次方.md">数值的整数次方</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39247755" target="_blank" rel="noopener">数值的整数次方</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">251</td>
<td style="text-align:center"><a href="nowcoder/251-二进制中1的个数.md">二进制中1的个数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39247639" target="_blank" rel="noopener">二进制中1的个数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">252</td>
<td style="text-align:center"><a href="nowcoder/252-变态跳台阶.md">变态跳台阶</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39247003" target="_blank" rel="noopener">变态跳台阶</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">253</td>
<td style="text-align:center"><a href="nowcoder/253-斐波那契数列.md">斐波那契数列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39245938" target="_blank" rel="noopener">斐波那契数列</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">254</td>
<td style="text-align:center"><a href="nowcoder/254-从尾到头打印链表.md">从尾到头打印链表</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39244630" target="_blank" rel="noopener">从尾到头打印链表</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">255</td>
<td style="text-align:center"><a href="nowcoder/255-二维数组中的查找.md">二维数组中的查找</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39244365" target="_blank" rel="noopener">二维数组中的查找</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">256</td>
<td style="text-align:center"><a href="nowcoder/256-用两个栈实现队列.md">用两个栈实现队列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39244198" target="_blank" rel="noopener">用两个栈实现队列</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">257</td>
<td style="text-align:center"><a href="nowcoder/257-合并两个排序的链表.md">合并两个排序的链表</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39175672" target="_blank" rel="noopener">合并两个排序的链表</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">258</td>
<td style="text-align:center"><a href="nowcoder/258-输入整型数组和排序.md">输入整型数组和排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39106191" target="_blank" rel="noopener">输入整型数组和排序</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">259</td>
<td style="text-align:center"><a href="nowcoder/259-查找输入整数二进制.md">查找输入整数二进制</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39105874" target="_blank" rel="noopener">查找输入整数二进制</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">260</td>
<td style="text-align:center"><a href="nowcoder/260-找出字符串中第一个.md">找出字符串中第一个</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39105457" target="_blank" rel="noopener">找出字符串中第一个</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">261</td>
<td style="text-align:center"><a href="nowcoder/261-尼科彻斯定理.md">尼科彻斯定理</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39104954" target="_blank" rel="noopener">尼科彻斯定理</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">262</td>
<td style="text-align:center"><a href="nowcoder/262-字符串分割.md">字符串分割</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39103841" target="_blank" rel="noopener">字符串分割</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">263</td>
<td style="text-align:center"><a href="nowcoder/263-（练习用）挑7.md">（练习用）挑7</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39101820" target="_blank" rel="noopener">（练习用）挑7</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">264</td>
<td style="text-align:center"><a href="nowcoder/264-火车进站.md">火车进站</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39100498" target="_blank" rel="noopener">火车进站</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">265</td>
<td style="text-align:center"><a href="nowcoder/265-超长正整数相加.md">超长正整数相加</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39099293" target="_blank" rel="noopener">超长正整数相加</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">266</td>
<td style="text-align:center"><a href="nowcoder/266-按字节截取字符串.md">按字节截取字符串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39099222" target="_blank" rel="noopener">按字节截取字符串</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">267</td>
<td style="text-align:center"><a href="nowcoder/267-计算字符串的距离.md">计算字符串的距离</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39098493" target="_blank" rel="noopener">计算字符串的距离</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">268</td>
<td style="text-align:center"><a href="nowcoder/268-输出单向链表中倒数.md">输出单向链表中倒数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39097860" target="_blank" rel="noopener">输出单向链表中倒数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">269</td>
<td style="text-align:center"><a href="nowcoder/269-名字的漂亮度.md">名字的漂亮度</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39097652" target="_blank" rel="noopener">名字的漂亮度</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">270</td>
<td style="text-align:center"><a href="nowcoder/270-蛇形矩阵.md">蛇形矩阵</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39097391" target="_blank" rel="noopener">蛇形矩阵</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">271</td>
<td style="text-align:center"><a href="nowcoder/271-24点运算.md">24点运算</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39097053" target="_blank" rel="noopener">24点运算</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">272</td>
<td style="text-align:center"><a href="nowcoder/272-统计大写字母个数.md">统计大写字母个数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39096831" target="_blank" rel="noopener">统计大写字母个数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">273</td>
<td style="text-align:center"><a href="nowcoder/273-表示数字.md">表示数字</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39089196" target="_blank" rel="noopener">表示数字</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">274</td>
<td style="text-align:center"><a href="nowcoder/274-等差数列.md">等差数列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39088951" target="_blank" rel="noopener">等差数列</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">275</td>
<td style="text-align:center"><a href="nowcoder/275-四则运算.md">四则运算</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39088261" target="_blank" rel="noopener">四则运算</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">276</td>
<td style="text-align:center"><a href="nowcoder/276-字符串匹配.md">字符串匹配</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39087990" target="_blank" rel="noopener">字符串匹配</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">277</td>
<td style="text-align:center"><a href="nowcoder/277-字符串运用-密码截.md">字符串运用-密码截</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39087478" target="_blank" rel="noopener">字符串运用-密码截</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">278</td>
<td style="text-align:center"><a href="nowcoder/278-【中级】单词倒排.md">【中级】单词倒排</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39086588" target="_blank" rel="noopener">【中级】单词倒排</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">279</td>
<td style="text-align:center"><a href="nowcoder/279-字符统计.md">字符统计</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39084731" target="_blank" rel="noopener">字符统计</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">280</td>
<td style="text-align:center"><a href="nowcoder/280-螺旋数.md">螺旋数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39082544" target="_blank" rel="noopener">螺旋数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">281</td>
<td style="text-align:center"><a href="nowcoder/281-寄居蟹与海葵.md">寄居蟹与海葵</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39080363" target="_blank" rel="noopener">寄居蟹与海葵</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">282</td>
<td style="text-align:center"><a href="nowcoder/282-英文金曲大赛.md">英文金曲大赛</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39079283" target="_blank" rel="noopener">英文金曲大赛</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">283</td>
<td style="text-align:center"><a href="nowcoder/283-叠筐.md">叠筐</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39078881" target="_blank" rel="noopener">叠筐</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">284</td>
<td style="text-align:center"><a href="nowcoder/284-发放贷款.md">发放贷款</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39077933" target="_blank" rel="noopener">发放贷款</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">285</td>
<td style="text-align:center"><a href="nowcoder/285-鹊桥相会.md">鹊桥相会</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39077485" target="_blank" rel="noopener">鹊桥相会</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">286</td>
<td style="text-align:center"><a href="nowcoder/286-最长公共子序列.md">最长公共子序列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39076694" target="_blank" rel="noopener">最长公共子序列</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">287</td>
<td style="text-align:center"><a href="nowcoder/287-数字和为sum的方.md">数字和为sum的方</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39073612" target="_blank" rel="noopener">数字和为sum的方</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">288</td>
<td style="text-align:center"><a href="nowcoder/288-删除公共字符.md">删除公共字符</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39065974" target="_blank" rel="noopener">删除公共字符</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">289</td>
<td style="text-align:center"><a href="nowcoder/289-编码.md">编码</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39065723" target="_blank" rel="noopener">编码</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">290</td>
<td style="text-align:center"><a href="nowcoder/290-集合.md">集合</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39065323" target="_blank" rel="noopener">集合</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">291</td>
<td style="text-align:center"><a href="nowcoder/291-整数加法.md">整数加法</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39064646" target="_blank" rel="noopener">整数加法</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">292</td>
<td style="text-align:center"><a href="nowcoder/292-统计字符.md">统计字符</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39061397" target="_blank" rel="noopener">统计字符</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">293</td>
<td style="text-align:center"><a href="nowcoder/293-字符串中找出连续最.md">字符串中找出连续最</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39057669" target="_blank" rel="noopener">字符串中找出连续最</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">294</td>
<td style="text-align:center"><a href="nowcoder/294-n个数里出现次数大.md">n个数里出现次数大</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39057494" target="_blank" rel="noopener">n个数里出现次数大</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">295</td>
<td style="text-align:center"><a href="nowcoder/295-n个数里最小的k个.md">n个数里最小的k个</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39057371" target="_blank" rel="noopener">n个数里最小的k个</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">296</td>
<td style="text-align:center"><a href="nowcoder/296-水仙花数.md">水仙花数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39056422" target="_blank" rel="noopener">水仙花数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">297</td>
<td style="text-align:center"><a href="nowcoder/297-买苹果.md">买苹果</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39055793" target="_blank" rel="noopener">买苹果</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">298</td>
<td style="text-align:center"><a href="nowcoder/298-数字翻转.md">数字翻转</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39055124" target="_blank" rel="noopener">数字翻转</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">299</td>
<td style="text-align:center"><a href="nowcoder/299-连续最大和.md">连续最大和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39053770" target="_blank" rel="noopener">连续最大和</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">300</td>
<td style="text-align:center"><a href="nowcoder/300-最大的奇约数.md">最大的奇约数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39052749" target="_blank" rel="noopener">最大的奇约数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">301</td>
<td style="text-align:center"><a href="nowcoder/301-数串.md">数串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39048049" target="_blank" rel="noopener">数串</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">302</td>
<td style="text-align:center"><a href="nowcoder/302-拼凑面额.md">拼凑面额</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39047687" target="_blank" rel="noopener">拼凑面额</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">303</td>
<td style="text-align:center"><a href="nowcoder/303-求和.md">求和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39046946" target="_blank" rel="noopener">求和</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">304</td>
<td style="text-align:center"><a href="nowcoder/304-求数列的和.md">求数列的和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39046596" target="_blank" rel="noopener">求数列的和</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">305</td>
<td style="text-align:center"><a href="nowcoder/305-保留最大的数.md">保留最大的数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39045336" target="_blank" rel="noopener">保留最大的数</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">306</td>
<td style="text-align:center"><a href="nowcoder/306-判断题.md">判断题</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39031006" target="_blank" rel="noopener">判断题</a></td>
<td style="text-align:center">Matlab</td>
</tr>
<tr>
<td style="text-align:center">307</td>
<td style="text-align:center"><a href="nowcoder/307-六一儿童节.md">六一儿童节</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=39011148" target="_blank" rel="noopener">六一儿童节</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">308</td>
<td style="text-align:center"><a href="nowcoder/308-出差.md">出差</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38964478" target="_blank" rel="noopener">出差</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">309</td>
<td style="text-align:center"><a href="nowcoder/309-砌墙.md">砌墙</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38963842" target="_blank" rel="noopener">砌墙</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">310</td>
<td style="text-align:center"><a href="nowcoder/310-最大收益.md">最大收益</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38963549" target="_blank" rel="noopener">最大收益</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">311</td>
<td style="text-align:center"><a href="nowcoder/311-中美代表.md">中美代表</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38962078" target="_blank" rel="noopener">中美代表</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">312</td>
<td style="text-align:center"><a href="nowcoder/312-句子反转.md">句子反转</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38956060" target="_blank" rel="noopener">句子反转</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">313</td>
<td style="text-align:center"><a href="nowcoder/313-数根.md">数根</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38955025" target="_blank" rel="noopener">数根</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">314</td>
<td style="text-align:center"><a href="nowcoder/314-剪花布条.md">剪花布条</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38954136" target="_blank" rel="noopener">剪花布条</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">315</td>
<td style="text-align:center"><a href="nowcoder/315-抄送列表.md">抄送列表</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38951820" target="_blank" rel="noopener">抄送列表</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">316</td>
<td style="text-align:center"><a href="nowcoder/316-解读密码.md">解读密码</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38951616" target="_blank" rel="noopener">解读密码</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">317</td>
<td style="text-align:center"><a href="nowcoder/317-骆驼命名法.md">骆驼命名法</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38950989" target="_blank" rel="noopener">骆驼命名法</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">318</td>
<td style="text-align:center"><a href="nowcoder/318-冲突的电话号码.md">冲突的电话号码</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38950458" target="_blank" rel="noopener">冲突的电话号码</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">319</td>
<td style="text-align:center"><a href="nowcoder/319-All-in-Al.md">All-in-Al</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38949727" target="_blank" rel="noopener">All-in-Al</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">320</td>
<td style="text-align:center"><a href="nowcoder/320-快到碗里来.md">快到碗里来</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38949137" target="_blank" rel="noopener">快到碗里来</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">321</td>
<td style="text-align:center"><a href="nowcoder/321-统计一.md">统计一</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38948573" target="_blank" rel="noopener">统计一</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">322</td>
<td style="text-align:center"><a href="nowcoder/322-红与黑.md">红与黑</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38948406" target="_blank" rel="noopener">红与黑</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">323</td>
<td style="text-align:center"><a href="nowcoder/323-数据库连接池.md">数据库连接池</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38947118" target="_blank" rel="noopener">数据库连接池</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">324</td>
<td style="text-align:center"><a href="nowcoder/324-最长句子.md">最长句子</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38946442" target="_blank" rel="noopener">最长句子</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">325</td>
<td style="text-align:center"><a href="nowcoder/325-Emacs计算器.md">Emacs计算器</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38945674" target="_blank" rel="noopener">Emacs计算器</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">326</td>
<td style="text-align:center"><a href="nowcoder/326-过年回家.md">过年回家</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38942771" target="_blank" rel="noopener">过年回家</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">327</td>
<td style="text-align:center"><a href="nowcoder/327-裁减网格纸.md">裁减网格纸</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38931060" target="_blank" rel="noopener">裁减网格纸</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">328</td>
<td style="text-align:center"><a href="nowcoder/328-删数.md">删数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38930474" target="_blank" rel="noopener">删数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">329</td>
<td style="text-align:center"><a href="nowcoder/329-年终奖.md">年终奖</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38928926" target="_blank" rel="noopener">年终奖</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">330</td>
<td style="text-align:center"><a href="nowcoder/330-投篮游戏.md">投篮游戏</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38928544" target="_blank" rel="noopener">投篮游戏</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">331</td>
<td style="text-align:center"><a href="nowcoder/331-最大间隔.md">最大间隔</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38927916" target="_blank" rel="noopener">最大间隔</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">332</td>
<td style="text-align:center"><a href="nowcoder/332-表达式组成方案.md">表达式组成方案</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38926667" target="_blank" rel="noopener">表达式组成方案</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">333</td>
<td style="text-align:center"><a href="nowcoder/333-表达式合法判断.md">表达式合法判断</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38925638" target="_blank" rel="noopener">表达式合法判断</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">334</td>
<td style="text-align:center"><a href="nowcoder/334-平均年龄.md">平均年龄</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38924902" target="_blank" rel="noopener">平均年龄</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">335</td>
<td style="text-align:center"><a href="nowcoder/335-添加回文串.md">添加回文串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38924046" target="_blank" rel="noopener">添加回文串</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">336</td>
<td style="text-align:center"><a href="nowcoder/336-顺时针旋转矩阵.md">顺时针旋转矩阵</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38916257" target="_blank" rel="noopener">顺时针旋转矩阵</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">337</td>
<td style="text-align:center"><a href="nowcoder/337-汉诺塔问题I.md">汉诺塔问题I</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38916024" target="_blank" rel="noopener">汉诺塔问题I</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">338</td>
<td style="text-align:center"><a href="nowcoder/338-发奖金.md">发奖金</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38915509" target="_blank" rel="noopener">发奖金</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">339</td>
<td style="text-align:center"><a href="nowcoder/339-二分查找.md">二分查找</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38915381" target="_blank" rel="noopener">二分查找</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">340</td>
<td style="text-align:center"><a href="nowcoder/340-首个重复字符.md">首个重复字符</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38915031" target="_blank" rel="noopener">首个重复字符</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">341</td>
<td style="text-align:center"><a href="nowcoder/341-直方图内最大矩形.md">直方图内最大矩形</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38914400" target="_blank" rel="noopener">直方图内最大矩形</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">342</td>
<td style="text-align:center"><a href="nowcoder/342-最后一位.md">最后一位</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38894573" target="_blank" rel="noopener">最后一位</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">343</td>
<td style="text-align:center"><a href="nowcoder/343-奶牛编号.md">奶牛编号</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38892876" target="_blank" rel="noopener">奶牛编号</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">344</td>
<td style="text-align:center"><a href="nowcoder/344-最小众倍数.md">最小众倍数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38891940" target="_blank" rel="noopener">最小众倍数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">345</td>
<td style="text-align:center"><a href="nowcoder/345-小易喜欢的数列.md">小易喜欢的数列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38890669" target="_blank" rel="noopener">小易喜欢的数列</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">346</td>
<td style="text-align:center"><a href="nowcoder/346-数字游戏.md">数字游戏</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38882834" target="_blank" rel="noopener">数字游戏</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">347</td>
<td style="text-align:center"><a href="nowcoder/347-迷宫寻路.md">迷宫寻路</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38877635" target="_blank" rel="noopener">迷宫寻路</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">348</td>
<td style="text-align:center"><a href="nowcoder/348-彩色的砖块.md">彩色的砖块</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38876418" target="_blank" rel="noopener">彩色的砖块</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">349</td>
<td style="text-align:center"><a href="nowcoder/349-交错01串.md">交错01串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38875705" target="_blank" rel="noopener">交错01串</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">350</td>
<td style="text-align:center"><a href="nowcoder/350-独立的小易.md">独立的小易</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38874344" target="_blank" rel="noopener">独立的小易</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">351</td>
<td style="text-align:center"><a href="nowcoder/351-空中旅行.md">空中旅行</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38873849" target="_blank" rel="noopener">空中旅行</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">352</td>
<td style="text-align:center"><a href="nowcoder/352-拼凑三角形.md">拼凑三角形</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38873244" target="_blank" rel="noopener">拼凑三角形</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">353</td>
<td style="text-align:center"><a href="nowcoder/353-回文素数.md">回文素数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38871535" target="_blank" rel="noopener">回文素数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">354</td>
<td style="text-align:center"><a href="nowcoder/354-删除重复字符.md">删除重复字符</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38870936" target="_blank" rel="noopener">删除重复字符</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">355</td>
<td style="text-align:center"><a href="nowcoder/355-大整数相乘.md">大整数相乘</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38869368" target="_blank" rel="noopener">大整数相乘</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">356</td>
<td style="text-align:center"><a href="nowcoder/356-最长回文.md">最长回文</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38846432" target="_blank" rel="noopener">最长回文</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">357</td>
<td style="text-align:center"><a href="nowcoder/357-换座位.md">换座位</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38846154" target="_blank" rel="noopener">换座位</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">358</td>
<td style="text-align:center"><a href="nowcoder/358-寻找舞伴.md">寻找舞伴</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38843384" target="_blank" rel="noopener">寻找舞伴</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">359</td>
<td style="text-align:center"><a href="nowcoder/359-二叉树.md">二叉树</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38842223" target="_blank" rel="noopener">二叉树</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">360</td>
<td style="text-align:center"><a href="nowcoder/360-最短编辑距离.md">最短编辑距离</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38841861" target="_blank" rel="noopener">最短编辑距离</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">361</td>
<td style="text-align:center"><a href="nowcoder/361-不喜欢括号.md">不喜欢括号</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38841653" target="_blank" rel="noopener">不喜欢括号</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">362</td>
<td style="text-align:center"><a href="nowcoder/362-一笔画.md">一笔画</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38840184" target="_blank" rel="noopener">一笔画</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">363</td>
<td style="text-align:center"><a href="nowcoder/363-滑雪.md">滑雪</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38837467" target="_blank" rel="noopener">滑雪</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">364</td>
<td style="text-align:center"><a href="nowcoder/364-数字三角形.md">数字三角形</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38836438" target="_blank" rel="noopener">数字三角形</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">365</td>
<td style="text-align:center"><a href="nowcoder/365-放苹果.md">放苹果</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38834677" target="_blank" rel="noopener">放苹果</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">366</td>
<td style="text-align:center"><a href="nowcoder/366-换零钱.md">换零钱</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38833051" target="_blank" rel="noopener">换零钱</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">367</td>
<td style="text-align:center"><a href="nowcoder/367-五子棋.md">五子棋</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38832300" target="_blank" rel="noopener">五子棋</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">368</td>
<td style="text-align:center"><a href="nowcoder/368-狐狸和绳子.md">狐狸和绳子</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38831098" target="_blank" rel="noopener">狐狸和绳子</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">369</td>
<td style="text-align:center"><a href="nowcoder/369-八皇后问题.md">八皇后问题</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38829724" target="_blank" rel="noopener">八皇后问题</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">370</td>
<td style="text-align:center"><a href="nowcoder/370-鸽兔同校.md">鸽兔同校</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38829453" target="_blank" rel="noopener">鸽兔同校</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">371</td>
<td style="text-align:center"><a href="nowcoder/371-杨辉三角.md">杨辉三角</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38829118" target="_blank" rel="noopener">杨辉三角</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">372</td>
<td style="text-align:center"><a href="nowcoder/372-循环数.md">循环数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38828375" target="_blank" rel="noopener">循环数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">373</td>
<td style="text-align:center"><a href="nowcoder/373-猴子分桃.md">猴子分桃</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38826596" target="_blank" rel="noopener">猴子分桃</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">374</td>
<td style="text-align:center"><a href="nowcoder/374-素数和.md">素数和</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38824999" target="_blank" rel="noopener">素数和</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">375</td>
<td style="text-align:center"><a href="nowcoder/375-写出这个数.md">写出这个数 (20</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38804949" target="_blank" rel="noopener">写出这个数 (20</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">376</td>
<td style="text-align:center"><a href="nowcoder/376-选大王.md">选大王</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38804282" target="_blank" rel="noopener">选大王</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">377</td>
<td style="text-align:center"><a href="nowcoder/377-三角形.md">三角形</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38803379" target="_blank" rel="noopener">三角形</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">378</td>
<td style="text-align:center"><a href="nowcoder/378-分解因数.md">分解因数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38750277" target="_blank" rel="noopener">分解因数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">379</td>
<td style="text-align:center"><a href="nowcoder/379-一的个数.md">一的个数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38749183" target="_blank" rel="noopener">一的个数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">380</td>
<td style="text-align:center"><a href="nowcoder/380-挖掘机技术哪家强.md">挖掘机技术哪家强(</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38747557" target="_blank" rel="noopener">挖掘机技术哪家强(</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">381</td>
<td style="text-align:center"><a href="nowcoder/381-统计同成绩学生.md">统计同成绩学生(2</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38739133" target="_blank" rel="noopener">统计同成绩学生(2</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">382</td>
<td style="text-align:center"><a href="nowcoder/382-组个最小数.md">组个最小数 (20</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38737209" target="_blank" rel="noopener">组个最小数 (20</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">383</td>
<td style="text-align:center"><a href="nowcoder/383-D进制的A+B.md">D进制的A+B (</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38737041" target="_blank" rel="noopener">D进制的A+B (</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">384</td>
<td style="text-align:center"><a href="nowcoder/384-个位数统计.md">个位数统计 (15</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38736663" target="_blank" rel="noopener">个位数统计 (15</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">385</td>
<td style="text-align:center"><a href="nowcoder/385-锤子剪刀布.md">锤子剪刀布 (20</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38730450" target="_blank" rel="noopener">锤子剪刀布 (20</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">386</td>
<td style="text-align:center"><a href="nowcoder/386-A除以B.md">A除以B (20)</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38729334" target="_blank" rel="noopener">A除以B (20)</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">387</td>
<td style="text-align:center"><a href="nowcoder/387-1016.部分A.md">1016. 部分A</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38729018" target="_blank" rel="noopener">1016. 部分A</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">388</td>
<td style="text-align:center"><a href="nowcoder/388-福尔摩斯的约会.md">福尔摩斯的约会 (</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38713517" target="_blank" rel="noopener">福尔摩斯的约会 (</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">389</td>
<td style="text-align:center"><a href="nowcoder/389-数素数.md">数素数 (20)</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38696846" target="_blank" rel="noopener">数素数 (20)</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">390</td>
<td style="text-align:center"><a href="nowcoder/390-A+B和C.md">A+B和C (15</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38695239" target="_blank" rel="noopener">A+B和C (15</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">391</td>
<td style="text-align:center"><a href="nowcoder/391-幸运的袋子.md">幸运的袋子</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38691391" target="_blank" rel="noopener">幸运的袋子</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">392</td>
<td style="text-align:center"><a href="nowcoder/392-藏宝图.md">藏宝图</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38690198" target="_blank" rel="noopener">藏宝图</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">393</td>
<td style="text-align:center"><a href="nowcoder/393-分田地.md">分田地</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38680574" target="_blank" rel="noopener">分田地</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">394</td>
<td style="text-align:center"><a href="nowcoder/394-下厨房.md">下厨房</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38679946" target="_blank" rel="noopener">下厨房</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">395</td>
<td style="text-align:center"><a href="nowcoder/395-素数对.md">素数对</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38406057" target="_blank" rel="noopener">素数对</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">396</td>
<td style="text-align:center"><a href="nowcoder/396-进制转换.md">进制转换</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38405773" target="_blank" rel="noopener">进制转换</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">397</td>
<td style="text-align:center"><a href="nowcoder/397-末尾0的个数.md">末尾0的个数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38405714" target="_blank" rel="noopener">末尾0的个数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">398</td>
<td style="text-align:center"><a href="nowcoder/398-求最大最小数.md">求最大最小数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38261946" target="_blank" rel="noopener">求最大最小数</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">399</td>
<td style="text-align:center"><a href="nowcoder/399-百万富翁问题.md">百万富翁问题</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38261778" target="_blank" rel="noopener">百万富翁问题</a></td>
<td style="text-align:center">Python</td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center"><a href="nowcoder/400-模块.md">模块</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38260932" target="_blank" rel="noopener">模块</a></td>
<td style="text-align:center">前端</td>
</tr>
<tr>
<td style="text-align:center">401</td>
<td style="text-align:center"><a href="nowcoder/401-正确的使用par.md">正确的使用 par</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38260810" target="_blank" rel="noopener">正确的使用 par</a></td>
<td style="text-align:center">前端</td>
</tr>
<tr>
<td style="text-align:center">402</td>
<td style="text-align:center"><a href="nowcoder/402-乘法.md">乘法</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38260675" target="_blank" rel="noopener">乘法</a></td>
<td style="text-align:center">前端</td>
</tr>
<tr>
<td style="text-align:center">403</td>
<td style="text-align:center"><a href="nowcoder/403-求二次方.md">求二次方</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38260654" target="_blank" rel="noopener">求二次方</a></td>
<td style="text-align:center">前端</td>
</tr>
<tr>
<td style="text-align:center">404</td>
<td style="text-align:center"><a href="nowcoder/404-流程控制.md">流程控制</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38260626" target="_blank" rel="noopener">流程控制</a></td>
<td style="text-align:center">前端</td>
</tr>
<tr>
<td style="text-align:center">405</td>
<td style="text-align:center"><a href="nowcoder/405-倒置字符串.md">倒置字符串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38245279" target="_blank" rel="noopener">倒置字符串</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">406</td>
<td style="text-align:center"><a href="nowcoder/406-跳台阶.md">跳台阶</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38238429" target="_blank" rel="noopener">跳台阶</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">407</td>
<td style="text-align:center"><a href="nowcoder/407-求1+2+3+...md">求1+2+3+..</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38235391" target="_blank" rel="noopener">求1+2+3+..</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">408</td>
<td style="text-align:center"><a href="nowcoder/408-替换空格.md">替换空格</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=38234293" target="_blank" rel="noopener">替换空格</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">409</td>
<td style="text-align:center"><a href="nowcoder/409-记负均正II.md">记负均正II</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28999379" target="_blank" rel="noopener">记负均正II</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">410</td>
<td style="text-align:center"><a href="nowcoder/410-将真分数分解为埃及.md">将真分数分解为埃及</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28997643" target="_blank" rel="noopener">将真分数分解为埃及</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">411</td>
<td style="text-align:center"><a href="nowcoder/411-放苹果.md">放苹果</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28996667" target="_blank" rel="noopener">放苹果</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">412</td>
<td style="text-align:center"><a href="nowcoder/412-查找组成一个偶数最.md">查找组成一个偶数最</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28995390" target="_blank" rel="noopener">查找组成一个偶数最</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">413</td>
<td style="text-align:center"><a href="nowcoder/413-字符串通配符.md">字符串通配符</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28993793" target="_blank" rel="noopener">字符串通配符</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">414</td>
<td style="text-align:center"><a href="nowcoder/414-成绩排序.md">成绩排序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28993419" target="_blank" rel="noopener">成绩排序</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">415</td>
<td style="text-align:center"><a href="nowcoder/415-查找两个字符串a,.md">查找两个字符串a,</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28993175" target="_blank" rel="noopener">查找两个字符串a,</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">416</td>
<td style="text-align:center"><a href="nowcoder/416-MP3光标位置.md">MP3光标位置</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28989245" target="_blank" rel="noopener">MP3光标位置</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">417</td>
<td style="text-align:center"><a href="nowcoder/417-字符串加密.md">字符串加密</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28988690" target="_blank" rel="noopener">字符串加密</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">418</td>
<td style="text-align:center"><a href="nowcoder/418-DNA序列.md">DNA序列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28984919" target="_blank" rel="noopener">DNA序列</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">419</td>
<td style="text-align:center"><a href="nowcoder/419-学英语.md">学英语</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28976579" target="_blank" rel="noopener">学英语</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">420</td>
<td style="text-align:center"><a href="nowcoder/420-iNOC产品部--.md">iNOC产品部—</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28974734" target="_blank" rel="noopener">iNOC产品部—</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">421</td>
<td style="text-align:center"><a href="nowcoder/421-质数因子.md">质数因子</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28973171" target="_blank" rel="noopener">质数因子</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">422</td>
<td style="text-align:center"><a href="nowcoder/422-输入n个整数，输出.md">输入n个整数，输出</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28962262" target="_blank" rel="noopener">输入n个整数，输出</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">423</td>
<td style="text-align:center"><a href="nowcoder/423-简单密码.md">简单密码</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28959733" target="_blank" rel="noopener">简单密码</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">424</td>
<td style="text-align:center"><a href="nowcoder/424-密码验证合格程序.md">密码验证合格程序</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28959016" target="_blank" rel="noopener">密码验证合格程序</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">425</td>
<td style="text-align:center"><a href="nowcoder/425-表达式求值.md">表达式求值</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28958490" target="_blank" rel="noopener">表达式求值</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">426</td>
<td style="text-align:center"><a href="nowcoder/426-称砝码.md">称砝码</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28957974" target="_blank" rel="noopener">称砝码</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">427</td>
<td style="text-align:center"><a href="nowcoder/427-在字符串中找出连续.md">在字符串中找出连续</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28957453" target="_blank" rel="noopener">在字符串中找出连续</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">428</td>
<td style="text-align:center"><a href="nowcoder/428-求解立方根.md">求解立方根</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28955012" target="_blank" rel="noopener">求解立方根</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">429</td>
<td style="text-align:center"><a href="nowcoder/429-求最小公倍数.md">求最小公倍数</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28954578" target="_blank" rel="noopener">求最小公倍数</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">430</td>
<td style="text-align:center"><a href="nowcoder/430-计算日期到天数转换.md">计算日期到天数转换</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28954198" target="_blank" rel="noopener">计算日期到天数转换</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">431</td>
<td style="text-align:center"><a href="nowcoder/431-迷宫问题.md">迷宫问题</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28950685" target="_blank" rel="noopener">迷宫问题</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">432</td>
<td style="text-align:center"><a href="nowcoder/432-进制转换.md">进制转换</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28881747" target="_blank" rel="noopener">进制转换</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">433</td>
<td style="text-align:center"><a href="nowcoder/433-字符串分隔.md">字符串分隔</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28881568" target="_blank" rel="noopener">字符串分隔</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">434</td>
<td style="text-align:center"><a href="nowcoder/434-暗黑的字符串.md">暗黑的字符串</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28795773" target="_blank" rel="noopener">暗黑的字符串</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">435</td>
<td style="text-align:center"><a href="nowcoder/435-跳石板.md">跳石板</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28793265" target="_blank" rel="noopener">跳石板</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">436</td>
<td style="text-align:center"><a href="nowcoder/436-优雅的点.md">优雅的点</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28793042" target="_blank" rel="noopener">优雅的点</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">437</td>
<td style="text-align:center"><a href="nowcoder/437-回文序列.md">回文序列</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28792616" target="_blank" rel="noopener">回文序列</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">438</td>
<td style="text-align:center"><a href="nowcoder/438-洗牌.md">洗牌</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28791722" target="_blank" rel="noopener">洗牌</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">439</td>
<td style="text-align:center"><a href="nowcoder/439-Fibonacci.md">Fibonacci</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28776927" target="_blank" rel="noopener">Fibonacci</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">440</td>
<td style="text-align:center"><a href="nowcoder/440-小易喜欢的单词.md">小易喜欢的单词</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28776648" target="_blank" rel="noopener">小易喜欢的单词</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">441</td>
<td style="text-align:center"><a href="nowcoder/441-两种排序方法.md">两种排序方法</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28776244" target="_blank" rel="noopener">两种排序方法</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">442</td>
<td style="text-align:center"><a href="nowcoder/442-饥饿的小易.md">饥饿的小易</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28775896" target="_blank" rel="noopener">饥饿的小易</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">443</td>
<td style="text-align:center"><a href="nowcoder/443-统计回文.md">统计回文</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28774411" target="_blank" rel="noopener">统计回文</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">444</td>
<td style="text-align:center"><a href="nowcoder/444-解救小易.md">解救小易</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28772803" target="_blank" rel="noopener">解救小易</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">445</td>
<td style="text-align:center"><a href="nowcoder/445-不要二.md">不要二</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28771989" target="_blank" rel="noopener">不要二</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">446</td>
<td style="text-align:center"><a href="nowcoder/446-混合颜料.md">混合颜料</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28769381" target="_blank" rel="noopener">混合颜料</a></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">447</td>
<td style="text-align:center"><a href="nowcoder/447-数列还原.md">数列还原</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28768110" target="_blank" rel="noopener">数列还原</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">448</td>
<td style="text-align:center"><a href="nowcoder/448-星际穿越.md">星际穿越</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28763873" target="_blank" rel="noopener">星际穿越</a></td>
<td style="text-align:center">Java</td>
</tr>
<tr>
<td style="text-align:center">449</td>
<td style="text-align:center"><a href="nowcoder/449-分苹果.md">分苹果</a></td>
<td style="text-align:center"><a href="https://www.nowcoder.com/profile/4102679/codeBookDetail?submissionId=28761884" target="_blank" rel="noopener">分苹果</a></td>
<td style="text-align:center">Java</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      
        
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode刷题目录.md]]></title>
      <url>/p/7ax52/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p align="center"><img width="300" src="img/leetcode.png"></p>

<p align="center">
    <img src="https://img.shields.io/badge/44/1126-Solved/Total-blue.svg">
    <img src="https://img.shields.io/badge/Easy-17-green.svg">
    <img src="https://img.shields.io/badge/Medium-21-orange.svg">
    <img src="https://img.shields.io/badge/Hard-6-red.svg">
</p>
<h3 align="center">My accepted leetcode solutions</h3>
<p align="center">
    <b>Last updated: 2019-07-24</b>
    <br>
</p>

<!--Please keep this line to let more users know about this tool. Thank you for your support.-->
<p>This repository is automatically generated and deployed by <a href="https://github.com/jlice/leetcode-publisher" target="_blank" rel="noopener"><strong>leetcode-publisher</strong></a>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">Title</th>
<th style="text-align:center">标题</th>
<th style="text-align:center">Difficulty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/1-two-sum.md" target="_blank" rel="noopener">two-sum</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/1-two-sum.md" target="_blank" rel="noopener">两数之和</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/2-add-two-numbers.md" target="_blank" rel="noopener">add-two-numbers</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/2-add-two-numbers.md" target="_blank" rel="noopener">两数相加</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/3-longest-substring-without-repeating-characters.md" target="_blank" rel="noopener">longest-substring-without-repeating-characters</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/3-longest-substring-without-repeating-characters.md" target="_blank" rel="noopener">无重复字符的最长子串</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/4-median-of-two-sorted-arrays.md" target="_blank" rel="noopener">median-of-two-sorted-arrays</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/4-median-of-two-sorted-arrays.md" target="_blank" rel="noopener">寻找两个有序数组的中位数</a></td>
<td style="text-align:center"><img src="img/hard.png" alt></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/6-zigzag-conversion.md" target="_blank" rel="noopener">zigzag-conversion</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/6-zigzag-conversion.md" target="_blank" rel="noopener">Z 字形变换</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/7-reverse-integer.md" target="_blank" rel="noopener">reverse-integer</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/7-reverse-integer.md" target="_blank" rel="noopener">整数反转</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/9-palindrome-number.md" target="_blank" rel="noopener">palindrome-number</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/9-palindrome-number.md" target="_blank" rel="noopener">回文数</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/10-regular-expression-matching.md" target="_blank" rel="noopener">regular-expression-matching</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/10-regular-expression-matching.md" target="_blank" rel="noopener">正则表达式匹配</a></td>
<td style="text-align:center"><img src="img/hard.png" alt></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/11-container-with-most-water.md" target="_blank" rel="noopener">container-with-most-water</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/11-container-with-most-water.md" target="_blank" rel="noopener">盛最多水的容器</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/15-3sum.md" target="_blank" rel="noopener">3sum</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/15-3sum.md" target="_blank" rel="noopener">三数之和</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/16-3sum-closest.md" target="_blank" rel="noopener">3sum-closest</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/16-3sum-closest.md" target="_blank" rel="noopener">最接近的三数之和</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/17-letter-combinations-of-a-phone-number.md" target="_blank" rel="noopener">letter-combinations-of-a-phone-number</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/17-letter-combinations-of-a-phone-number.md" target="_blank" rel="noopener">电话号码的字母组合</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/19-remove-nth-node-from-end-of-list.md" target="_blank" rel="noopener">remove-nth-node-from-end-of-list</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/19-remove-nth-node-from-end-of-list.md" target="_blank" rel="noopener">删除链表的倒数第N个节点</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/20-valid-parentheses.md" target="_blank" rel="noopener">valid-parentheses</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/20-valid-parentheses.md" target="_blank" rel="noopener">有效的括号</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/21-merge-two-sorted-lists.md" target="_blank" rel="noopener">merge-two-sorted-lists</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/21-merge-two-sorted-lists.md" target="_blank" rel="noopener">合并两个有序链表</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/29-divide-two-integers.md" target="_blank" rel="noopener">divide-two-integers</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/29-divide-two-integers.md" target="_blank" rel="noopener">两数相除</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">45</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/45-jump-game-ii.md" target="_blank" rel="noopener">jump-game-ii</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/45-jump-game-ii.md" target="_blank" rel="noopener">跳跃游戏 II</a></td>
<td style="text-align:center"><img src="img/hard.png" alt></td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/48-rotate-image.md" target="_blank" rel="noopener">rotate-image</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/48-rotate-image.md" target="_blank" rel="noopener">旋转图像</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">50</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/50-powx-n.md" target="_blank" rel="noopener">powx-n</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/50-powx-n.md" target="_blank" rel="noopener">Pow(x, n)</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">53</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/53-maximum-subarray.md" target="_blank" rel="noopener">maximum-subarray</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/53-maximum-subarray.md" target="_blank" rel="noopener">最大子序和</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">55</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/55-jump-game.md" target="_blank" rel="noopener">jump-game</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/55-jump-game.md" target="_blank" rel="noopener">跳跃游戏</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">56</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/56-merge-intervals.md" target="_blank" rel="noopener">merge-intervals</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/56-merge-intervals.md" target="_blank" rel="noopener">合并区间</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">57</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/57-insert-interval.md" target="_blank" rel="noopener">insert-interval</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/57-insert-interval.md" target="_blank" rel="noopener">插入区间</a></td>
<td style="text-align:center"><img src="img/hard.png" alt></td>
</tr>
<tr>
<td style="text-align:center">58</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/58-length-of-last-word.md" target="_blank" rel="noopener">length-of-last-word</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/58-length-of-last-word.md" target="_blank" rel="noopener">最后一个单词的长度</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">66</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/66-plus-one.md" target="_blank" rel="noopener">plus-one</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/66-plus-one.md" target="_blank" rel="noopener">加一</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">72</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/72-edit-distance.md" target="_blank" rel="noopener">edit-distance</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/72-edit-distance.md" target="_blank" rel="noopener">编辑距离</a></td>
<td style="text-align:center"><img src="img/hard.png" alt></td>
</tr>
<tr>
<td style="text-align:center">73</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/73-set-matrix-zeroes.md" target="_blank" rel="noopener">set-matrix-zeroes</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/73-set-matrix-zeroes.md" target="_blank" rel="noopener">矩阵置零</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">74</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/74-search-a-2d-matrix.md" target="_blank" rel="noopener">search-a-2d-matrix</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/74-search-a-2d-matrix.md" target="_blank" rel="noopener">搜索二维矩阵</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">94</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/94-binary-tree-inorder-traversal.md" target="_blank" rel="noopener">binary-tree-inorder-traversal</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/94-binary-tree-inorder-traversal.md" target="_blank" rel="noopener">二叉树的中序遍历</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/100-same-tree.md" target="_blank" rel="noopener">same-tree</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/100-same-tree.md" target="_blank" rel="noopener">相同的树</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">102</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/102-binary-tree-level-order-traversal.md" target="_blank" rel="noopener">binary-tree-level-order-traversal</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/102-binary-tree-level-order-traversal.md" target="_blank" rel="noopener">二叉树的层次遍历</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">144</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/144-binary-tree-preorder-traversal.md" target="_blank" rel="noopener">binary-tree-preorder-traversal</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/144-binary-tree-preorder-traversal.md" target="_blank" rel="noopener">二叉树的前序遍历</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">150</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/150-evaluate-reverse-polish-notation.md" target="_blank" rel="noopener">evaluate-reverse-polish-notation</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/150-evaluate-reverse-polish-notation.md" target="_blank" rel="noopener">逆波兰表达式求值</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">151</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/151-reverse-words-in-a-string.md" target="_blank" rel="noopener">reverse-words-in-a-string</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/151-reverse-words-in-a-string.md" target="_blank" rel="noopener">翻转字符串里的单词</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">154</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/154-find-minimum-in-rotated-sorted-array-ii.md" target="_blank" rel="noopener">find-minimum-in-rotated-sorted-array-ii</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/154-find-minimum-in-rotated-sorted-array-ii.md" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 II</a></td>
<td style="text-align:center"><img src="img/hard.png" alt></td>
</tr>
<tr>
<td style="text-align:center">155</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/155-min-stack.md" target="_blank" rel="noopener">min-stack</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/155-min-stack.md" target="_blank" rel="noopener">最小栈</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">338</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/338-counting-bits.md" target="_blank" rel="noopener">counting-bits</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/338-counting-bits.md" target="_blank" rel="noopener">比特位计数</a></td>
<td style="text-align:center"><img src="img/medium.png" alt></td>
</tr>
<tr>
<td style="text-align:center">344</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/344-reverse-string.md" target="_blank" rel="noopener">reverse-string</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/344-reverse-string.md" target="_blank" rel="noopener">反转字符串</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">367</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/367-valid-perfect-square.md" target="_blank" rel="noopener">valid-perfect-square</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/367-valid-perfect-square.md" target="_blank" rel="noopener">有效的完全平方数</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">371</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/371-sum-of-two-integers.md" target="_blank" rel="noopener">sum-of-two-integers</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/371-sum-of-two-integers.md" target="_blank" rel="noopener">两整数之和</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">387</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/387-first-unique-character-in-a-string.md" target="_blank" rel="noopener">first-unique-character-in-a-string</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/387-first-unique-character-in-a-string.md" target="_blank" rel="noopener">字符串中的第一个唯一字符</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">453</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/453-minimum-moves-to-equal-array-elements.md" target="_blank" rel="noopener">minimum-moves-to-equal-array-elements</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/453-minimum-moves-to-equal-array-elements.md" target="_blank" rel="noopener">最小移动次数使数组元素相等</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">551</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/551-student-attendance-record-i.md" target="_blank" rel="noopener">student-attendance-record-i</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/551-student-attendance-record-i.md" target="_blank" rel="noopener">学生出勤记录 I</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
<tr>
<td style="text-align:center">557</td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/557-reverse-words-in-a-string-iii.md" target="_blank" rel="noopener">reverse-words-in-a-string-iii</a></td>
<td style="text-align:center"><a href="https://github.com/aaaa3293823524/leetcode/blob/master/problems/557-reverse-words-in-a-string-iii.md" target="_blank" rel="noopener">反转字符串中的单词 III</a></td>
<td style="text-align:center"><img src="img/easy.png" alt></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      
        
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git常见使用命令]]></title>
      <url>/p/7afov/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="create-a-new-repository-on-the-command-line"><a href="#create-a-new-repository-on-the-command-line" class="headerlink" title="create a new repository on the command line"></a>create a new repository on the command line</h1><p>git init<br>git add README.md<br>git commit -m “first commit”<br>git remote add origin git@github.com:aaaa3293823524/leet.git<br>git push -u origin master</p>
<h1 id="push-an-existing-repository-from-the-command-line"><a href="#push-an-existing-repository-from-the-command-line" class="headerlink" title="push an existing repository from the command line"></a>push an existing repository from the command line</h1><p>git remote add origin git@github.com:aaaa3293823524/leet.git<br>git push -u origin master</p>
]]></content>
      
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最优化算法学习]]></title>
      <url>/p/7afmh/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 最优化算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[概率论和数理统计知识点总结]]></title>
      <url>/p/7a8iv/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="随机试验-样本空间-随机事件（-基本事件-必然事件-不可能事件）"><a href="#随机试验-样本空间-随机事件（-基本事件-必然事件-不可能事件）" class="headerlink" title="随机试验  样本空间 随机事件（ 基本事件  必然事件 不可能事件）"></a>随机试验  样本空间 随机事件（ 基本事件  必然事件 不可能事件）</h2><h2 id="事件关系和运算-和事件-积事件-差事件-对立事件-互逆"><a href="#事件关系和运算-和事件-积事件-差事件-对立事件-互逆" class="headerlink" title="事件关系和运算   和事件  积事件  差事件  对立事件  互逆"></a>事件关系和运算   和事件  积事件  差事件  对立事件  互逆</h2><h2 id="交换律-结合律-分配律-德摩根律"><a href="#交换律-结合律-分配律-德摩根律" class="headerlink" title="交换律  结合律  分配律  德摩根律"></a>交换律  结合律  分配律  德摩根律</h2><h2 id="频率（频数除以试验次数）-概率（非负-规范-可列可加性）"><a href="#频率（频数除以试验次数）-概率（非负-规范-可列可加性）" class="headerlink" title="频率（频数除以试验次数）  概率（非负  规范  可列可加性）"></a>频率（频数除以试验次数）  概率（非负  规范  可列可加性）</h2><h2 id="古典概型（取球-有放回-不放回）"><a href="#古典概型（取球-有放回-不放回）" class="headerlink" title="古典概型（取球 有放回  不放回）"></a>古典概型（取球 有放回  不放回）</h2><h2 id="加法公式-乘法公式（条件概率）"><a href="#加法公式-乘法公式（条件概率）" class="headerlink" title="加法公式  乘法公式（条件概率）"></a>加法公式  乘法公式（条件概率）</h2><h2 id="全概率公式-P-A-P-A-B1-P-B1-P-A-B2-P-B2"><a href="#全概率公式-P-A-P-A-B1-P-B1-P-A-B2-P-B2" class="headerlink" title="全概率公式   P(A)=P(A|B1)P(B1)+P(A|B2)P(B2)"></a>全概率公式   P(A)=P(A|B1)P(B1)+P(A|B2)P(B2)</h2><h2 id="贝叶斯公式-P-B1-A-P-B1A-P-A-P-A-B1-P-B1-如上全概率公式"><a href="#贝叶斯公式-P-B1-A-P-B1A-P-A-P-A-B1-P-B1-如上全概率公式" class="headerlink" title="贝叶斯公式  P(B1|A)=P(B1A)/P(A)=P(A|B1)P(B1)/如上全概率公式"></a>贝叶斯公式  P(B1|A)=P(B1A)/P(A)=P(A|B1)P(B1)/如上全概率公式</h2><h2 id="独立性-P（AB）-P-A-P-B"><a href="#独立性-P（AB）-P-A-P-B" class="headerlink" title="独立性  P（AB）=P(A)P(B)"></a>独立性  P（AB）=P(A)P(B)</h2><h1 id="第二章-随机变量及其分布"><a href="#第二章-随机变量及其分布" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h1><h2 id="离散型随机变量和分布函数"><a href="#离散型随机变量和分布函数" class="headerlink" title="离散型随机变量和分布函数"></a>离散型随机变量和分布函数</h2><h3 id="0-1分布"><a href="#0-1分布" class="headerlink" title="0-1分布"></a>0-1分布</h3><h3 id="二项（伯努利）分布"><a href="#二项（伯努利）分布" class="headerlink" title="二项（伯努利）分布"></a>二项（伯努利）分布</h3><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><h3 id="随机变量分布函数"><a href="#随机变量分布函数" class="headerlink" title="随机变量分布函数"></a>随机变量分布函数</h3><p>F(x)=P{X&lt;=x}<br>分布函数性质<br>1 单调不减<br>2 0&lt;=F（x）&lt;=1<br>3右连续</p>
<h2 id="连续型随机变量和概率密度-（对分布函数求导得概率密度-对概率密度求积分得分布函数）"><a href="#连续型随机变量和概率密度-（对分布函数求导得概率密度-对概率密度求积分得分布函数）" class="headerlink" title="连续型随机变量和概率密度  （对分布函数求导得概率密度  对概率密度求积分得分布函数）"></a>连续型随机变量和概率密度  （对分布函数求导得概率密度  对概率密度求积分得分布函数）</h2><h1 id="第三章-多维随机变量及其分布"><a href="#第三章-多维随机变量及其分布" class="headerlink" title="第三章  多维随机变量及其分布"></a>第三章  多维随机变量及其分布</h1><h2 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h2><p>联合分布律<br>边缘分布<br>条件分布  条件分布律  条件概率密度</p>
<p>独立性  f(x,y)=fX(x)fY(y)     F(x,y)=FX(x)FY(y) </p>
<p>条件概率密度  联合概率密度  边缘概率密度</p>
<p>两个随机变量的函数的分布<br>1  Z=X+Y   卷积公式</p>
<p>2 Z=Y/X   Z=XY分布</p>
<p>3 M=max{X,Y}   N=min{X,Y}</p>
<h1 id="第四章-随机变量的数字特征"><a href="#第四章-随机变量的数字特征" class="headerlink" title="第四章  随机变量的数字特征"></a>第四章  随机变量的数字特征</h1><p>数学期望  方差 协方差     相关系数                            矩，协方差矩阵<br>E(X)     D(X) COV(x,y)  pxy =COV(x,y)/(根号D(x)*根号D(y))   原点矩，中心矩，混合矩</p>
<h1 id="第五章-大数定律及中心极限定理"><a href="#第五章-大数定律及中心极限定理" class="headerlink" title="第五章  大数定律及中心极限定理"></a>第五章  大数定律及中心极限定理</h1><p>切比雪夫不等式</p>
<p>辛钦大数定理（弱大数定理）  相互独立 服从同一分布  依概率收敛</p>
<p>伯努利大数定理   （相当于辛钦大数定理对概率以概率收敛的特殊情况）</p>
<p>1中心极限定理  独立同分布<br>2李雅普诺夫定理   不服从同分布  但独立<br>3德莫弗-拉普拉斯定理  服从二项分布</p>
<h1 id="第六章-样本及抽样分布"><a href="#第六章-样本及抽样分布" class="headerlink" title="第六章  样本及抽样分布"></a>第六章  样本及抽样分布</h1><p>随机样本</p>
<p>频率直方图</p>
<p>箱线图</p>
<p>统计量  不含未知参数</p>
<p>X2分布</p>
<p>t分布（学生式分布）</p>
<p>F分布</p>
<h1 id="第七章-参数估计"><a href="#第七章-参数估计" class="headerlink" title="第七章  参数估计"></a>第七章  参数估计</h1><p>统计推断的基本问题可以分为两大类  一类是估计问题  另一类是假设检验问题</p>
<p>点估计和区间估计<br>分布函数已知 含有未知参数 根据总体的一个样本来估计参数  X:样本  x:样本值  </p>
<p>最大似然估计法    最大似然估计值  最大似然估计量  对数似然方程</p>
<p>估计量的评选标准<br>1 无偏性</p>
<p>2有效性</p>
<p>3相合性</p>
<p>置信水平  置信下限  置信上限   上a分位点  置信区间</p>
<p>正态总体均值与方差的区间估计</p>
<p>单侧置信区间<br>单侧置信下限  单侧置信上限</p>
<h1 id="第八章-假设检验"><a href="#第八章-假设检验" class="headerlink" title="第八章  假设检验"></a>第八章  假设检验</h1><p>检验统计量<br>H0 原假设（零假设）<br>H1 备择假设<br>拒绝域  拒绝域的边界点为临界值<br>第1类错误       弃真<br>第2类错误       存伪</p>
<p>双边</p>
<p>单边  左边  右边</p>
<p>正态总体均值的假设检验</p>
<p>正态总体方差的假设检验</p>
<h1 id="方差分析和回归分析"><a href="#方差分析和回归分析" class="headerlink" title="方差分析和回归分析"></a>方差分析和回归分析</h1><h1 id="bootstrap方法"><a href="#bootstrap方法" class="headerlink" title="bootstrap方法"></a>bootstrap方法</h1><h1 id="随机过程及统计描述"><a href="#随机过程及统计描述" class="headerlink" title="随机过程及统计描述"></a>随机过程及统计描述</h1><h1 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h1><h1 id="平稳随机过程"><a href="#平稳随机过程" class="headerlink" title="平稳随机过程"></a>平稳随机过程</h1>]]></content>
      
        
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js_DOM操作学习总结（一）]]></title>
      <url>/p/79wnf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[photoshop学习知识总结（一）]]></title>
      <url>/p/79wi4/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>抠图  修图 绘图 工具熟练度  审美  特效</p>
<p>近似色 类似色  对比色</p>
<p>色相、饱和度 图层蒙版（点着色）    黑色遮挡   白色显示</p>
<p>[  ]   画笔变大变小</p>
<p>蒙版填充  Alt+Delete</p>
<p>蒙版填充黑色   白色画笔填充想要的效果</p>
<p>X 切换前、背景色</p>
<p>视图  ctrl   + </p>
<p>ctrl+J  复制图层</p>
<p>色彩平衡</p>
<p>图像模式</p>
<p>剪贴蒙版   上图下形   ctrl  alt g</p>
<p>ctrl shift alt e 盖印   </p>
<p>快速选择工具     ctrl  d 取消选区</p>
<p>颜色替换工具  alt 减选</p>
<p>调整图层顺序   ctrl shift ] 图层置顶</p>
]]></content>
      
        
        <tags>
            
            <tag> photoshop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[推荐系统知识总结（一）]]></title>
      <url>/p/79wfu/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CTR</p>
<p>用户  物品</p>
]]></content>
      
        
        <tags>
            
            <tag> 推荐系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学术的一些知识（一）]]></title>
      <url>/p/79wau/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>谷歌学术，百度学术，中国知网，小木虫，SCI-hub,EI village</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java知识总结（一）]]></title>
      <url>/p/79wah/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式学习总结]]></title>
      <url>/p/79vrp/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开闭原则<br>单一职责原则</p>
<p>继承<br>关联<br>依赖<br>组合<br>聚合</p>
<p>UML图</p>
<h1 id="创建型-创建型模式-Creational-Pattern-关注的是对象的创建，将创建对象-类的实例化-的过程进行了抽象和封装，分离了对象创建和对象使用"><a href="#创建型-创建型模式-Creational-Pattern-关注的是对象的创建，将创建对象-类的实例化-的过程进行了抽象和封装，分离了对象创建和对象使用" class="headerlink" title="创建型  创建型模式(Creational Pattern)关注的是对象的创建，将创建对象(类的实例化)的过程进行了抽象和封装，分离了对象创建和对象使用"></a>创建型  创建型模式(Creational Pattern)关注的是对象的创建，将创建对象(类的实例化)的过程进行了抽象和封装，分离了对象创建和对象使用</h1><h2 id="简单工厂-（静态工厂方法）"><a href="#简单工厂-（静态工厂方法）" class="headerlink" title="简单工厂 （静态工厂方法）"></a>简单工厂 （静态工厂方法）</h2><p>equalsIgnoreCase()</p>
<p>在JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</p>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h2 id="建造者-（部件和组装过程分开，一步步创建一个复杂的对象）"><a href="#建造者-（部件和组装过程分开，一步步创建一个复杂的对象）" class="headerlink" title="建造者 （部件和组装过程分开，一步步创建一个复杂的对象）"></a>建造者 （部件和组装过程分开，一步步创建一个复杂的对象）</h2><p>JavaMail（一步一步构造一个完整的邮件对象，然后发送）</p>
<h2 id="原型-（复制）"><a href="#原型-（复制）" class="headerlink" title="原型  （复制）"></a>原型  （复制）</h2><p>深克隆 浅克隆<br>clone() getClass()<br>structs2中Action对象 Spring创建bean实例</p>
<h2 id="单例-并发和同步问题-java-lang-Runtime类-默认情况下Spring会通过单例模式创建bean实例"><a href="#单例-并发和同步问题-java-lang-Runtime类-默认情况下Spring会通过单例模式创建bean实例" class="headerlink" title="单例   并发和同步问题  java.lang.Runtime类   默认情况下Spring会通过单例模式创建bean实例"></a>单例   并发和同步问题  java.lang.Runtime类   默认情况下Spring会通过单例模式创建bean实例</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"date"</span> <span class="attribute">class</span>=<span class="string">"java.util.Date"</span> <span class="attribute">scope</span>=<span class="string">"singleton"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>饿汉  懒汉</p>
<h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><p>结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构<br>结构型模式可以分为类结构型模式和对象结构型模式</p>
<h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式(Adapter)"></a>适配器模式(Adapter)</h2><p>适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<h2 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式(Bridge)"></a>桥接模式(Bridge)</h2><h2 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式(Composite)"></a>组合模式(Composite)</h2><p>树形结构  容器对象  叶子对象<br>组合模式又可以称为“整体-部分”(Part-Whole)模式，属于对象结构型模式，<br>它将对象组织到树结构中，可以用来描述整体与部分的关系</p>
<h2 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式(Decorator)"></a>装饰模式(Decorator)</h2><p>在装饰器中既可以调用原有类的方法，还可以增加新的方法，以扩充原有类的功能</p>
<h2 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式(Facade)"></a>外观模式(Facade)</h2><h2 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式(Flyweight)"></a>享元模式(Flyweight)</h2><h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><p>行为型模式分为类行为型模式和对象行为型模式两种</p>
<h2 id="职责链模式-Chain-of-Responsibility"><a href="#职责链模式-Chain-of-Responsibility" class="headerlink" title="职责链模式(Chain of Responsibility)"></a>职责链模式(Chain of Responsibility)</h2><p> Java中的异常处理机制<br> 在Web应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等。<br> 早期的Java AWT事件模型(JDK 1.0及更早) ：事件浮升(Event Bubbling)机制。</p>
<h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式(Command)"></a>命令模式(Command)</h2><h2 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式(Interpreter)"></a>解释器模式(Interpreter)</h2><h2 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式(Iterator)"></a>迭代器模式(Iterator)</h2><p> 遍历<br> java内置迭代器<br> next()   </p>
<h2 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式(Mediator)"></a>中介者模式(Mediator)</h2><p>qq群<br>网状结构<br>同事对象<br>中介者模式的目的主要是松散多个模块之间的耦合，<br>把这些耦合关系全部放到中介者中去实现；<br>而外观模式的目的是简化客户端的调用，这点和中介者模式也不同。</p>
<h2 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式(Memento)"></a>备忘录模式(Memento)</h2><p>撤销(Undo)的功能   历史状态</p>
<h2 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式(Observer)"></a>观察者模式(Observer)</h2><p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。<br>观察者模式又叫做发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式是一种对象行为型模式。</p>
<h2 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式(State)"></a>状态模式(State)</h2><p>状态类</p>
<p>状态模式和观察者模式的区别<br>这两个模式都是在状态发生改变的时候触发行为，只不过观察者模式的行为是固定的，那就是通知所有的观察者，而状态模式是根据状态来选择不同的处理，当状态发生改变的时候，动态改变行为。</p>
<h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h2><p>Java SE的容器布局管理是策略模式应用的经典实例。</p>
<p>策略模式与状态模式的比较<br>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</p>
<p>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。<br>策略模式中，具体策略类无须关心环境类；而状态模式中具体状态往往需要维护一个环境类的引用，以便通过该引用实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</p>
<h2 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式(Template Method)"></a>模板方法模式(Template Method)</h2><p>类行为型模式</p>
<p>基本方法是实现算法各个步骤的方法，是模板方法的组成部分。<br>基本方法分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。</p>
<h2 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式(Visitor)"></a>访问者模式(Visitor)</h2><p>优缺点</p>
<p>模式之间的比较和区别</p>
]]></content>
      
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[英语口语学习总结（一）]]></title>
      <url>/p/79vnc/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试知识总结（一）]]></title>
      <url>/p/79vna/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不同公司准备不同简历<br>准备一个日程本 记录笔试 面试时间</p>
<p>offer<br>1 薪水（税前还是税后）<br>2 补助（税前还是税后）<br>3 工作职位<br>4 工作时间 地点<br>5 保险公积金等福利<br>6 加班 出差<br>7 工作内容<br>8 年假<br>9 户口<br>10 股票<br>11 发展机会<br>12 奖金（年终）<br>13 公司背景<br>14 签约年限和违约金</p>
<h1 id="应聘渠道"><a href="#应聘渠道" class="headerlink" title="应聘渠道"></a>应聘渠道</h1><p>宣讲会等书面简历<br>中华英才  智联招聘 电子简历<br>拉勾网 牛客网 大街网</p>
<h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><ul>
<li>100题系列by_July</li>
<li>C和c++常见笔试题</li>
<li>程序员面试金典（第5版）</li>
<li>剑指offer 名企面试官精讲典型编程题</li>
<li>十五个经典算法研究与总结、目录+索引</li>
<li>程序员面试宝典 欧立奇 第五版</li>
<li>程序员代码面试指南  IT名企算法与数据结构题目最优解 [左程云著]</li>
<li>Java程序员面试宝典(第2版)(欧立奇,刘洋,段韬)  PDF </li>
<li>大公司最爱问的97道面试题</li>
<li>完整面试资料</li>
<li>200+最常见Java面试题参考答案</li>
</ul>
<p>面试流程<br>1 电话面试<br>2 共享桌面远程面试<br>单点  调试能力</p>
<p>思考清楚再开始编码<br>良好的代码命名和缩进对齐习惯<br>能单元测试<br>3 现场面试</p>
<p>英语面试</p>
<h2 id="行为面试"><a href="#行为面试" class="headerlink" title="行为面试"></a>行为面试</h2><p>自我介绍<br>项目经验</p>
<p>为什么跳槽： 换个环境和学习状态  能学习到新知识 对自己的能力提升有帮助</p>
<h2 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h2><p>基础知识</p>
<p>要仔细考虑边界情况 如输入为空的情况<br>错误处理</p>
<p>动手写代码之前先想好测试用例</p>
<p>哈希表 最大堆  红黑树</p>
<p>沟通能力</p>
<p>学习能力（看了什么书  学了什么新技术）</p>
<p>抽象建模和发散思维能力</p>
<p>位运算实现加法</p>
<h2 id="应聘者提问"><a href="#应聘者提问" class="headerlink" title="应聘者提问"></a>应聘者提问</h2>]]></content>
      
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[笔试题知识总结（一）]]></title>
      <url>/p/79vna/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 笔试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务学习总结（一）]]></title>
      <url>/p/79vn9/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[运维学习总结（一）]]></title>
      <url>/p/79vn5/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>awk<br>处理按行存储数据的工具</p>
<p>sed</p>
<p>shell脚本</p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库学习总结（一）]]></title>
      <url>/p/79vn2/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="sql语句练习"><a href="#sql语句练习" class="headerlink" title="sql语句练习"></a>sql语句练习</h1><p>牛客网练习</p>
<h1 id="MySQL技术内幕-InnoDB存储引擎"><a href="#MySQL技术内幕-InnoDB存储引擎" class="headerlink" title="MySQL技术内幕  InnoDB存储引擎"></a>MySQL技术内幕  InnoDB存储引擎</h1><p>存储引擎：MyISAM,InnoDB,NDB,Memory,Archive,Federated,Maria,Merge,CSV,Sphinx,Infobright<br>单进程多线程架构<br>数据库：文件<br>数据库实例：进程、线程</p>
<p>范围查询</p>
<p>全盘扫描</p>
<h2 id="索引与算法-索引内部机制"><a href="#索引与算法-索引内部机制" class="headerlink" title="索引与算法   索引内部机制"></a>索引与算法   索引内部机制</h2><p>索引太多 应用性能影响<br>索引太少  查询性能影响</p>
<h3 id="B-树索引（B代表平衡）"><a href="#B-树索引（B代表平衡）" class="headerlink" title="B+树索引（B代表平衡）"></a>B+树索引（B代表平衡）</h3><p>查找的是数据行所在的页，然后通过把页调入内存，再查找，最终找到数据</p>
<p>由 二叉查找树，平衡二叉树（AVL树），B树演化而来</p>
<p>AVL树维护价值大  （一次或多次左旋 右旋  看！！！！）</p>
<p> 插入  删除<br> 聚集索引  辅助聚集索引</p>
<p> 辅助索引的叶节点包含主键，但不包含完整的行信息</p>
<p> 选用时机：如果某个字段取值范围很广，几乎没有重复，高选择性</p>
<p> 顺序读，随机读与预读取</p>
<p> 联合索引  指的是对表上多个列做索引，键值数量大于等于2</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希算法  散列表数据结构</p>
<p>自适应哈希索引</p>
<blockquote>
<p>表<br>存储引擎基于表，不是数据库</p>
</blockquote>
<p>存储引擎接口</p>
<h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p>表空间<br>段  区（64个连续页  1MB） 页（64KB）</p>
<h2 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h2><p>约束   数据完整性<br>约束和索引的区别   索引是一个数据结构  约束更是一个逻辑的概念 </p>
<p>视图<br>物化视图<br>分区表</p>
<h2 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h2><h3 id="插入缓冲-二次写-自适应哈希索引-预读"><a href="#插入缓冲-二次写-自适应哈希索引-预读" class="headerlink" title="插入缓冲 二次写 自适应哈希索引  预读"></a>插入缓冲 二次写 自适应哈希索引  预读</h3><h3 id="存储容量的限制，事务支持，锁的粒度，多版本支持，支持的索引，备份和复制等"><a href="#存储容量的限制，事务支持，锁的粒度，多版本支持，支持的索引，备份和复制等" class="headerlink" title="存储容量的限制，事务支持，锁的粒度，多版本支持，支持的索引，备份和复制等"></a>存储容量的限制，事务支持，锁的粒度，多版本支持，支持的索引，备份和复制等</h3><blockquote>
<p>连接MySQL操作是连接进程和MySQL数据库实例进行通信</p>
<ul>
<li>TCP/ip  权限视图user表</li>
<li>命名管道（named-pipe）和共享内存(shared-memory)</li>
<li>unix域套接字</li>
</ul>
<p>InnoB系统架构</p>
</blockquote>
<p>后台线程</p>
<p>InnoDB存储引擎有7个后台线程：4个IO 1个master 1个锁监控线程  1个错误监控线程</p>
<p>master thread 优先级别最高 由几个循环组成，主循环，后台循环，刷新循环，暂停循环</p>
<blockquote>
<p>内存</p>
</blockquote>
<p>缓冲池</p>
<p>内存池</p>
<blockquote>
<p>锁</p>
<ul>
<li>行锁  表锁  页锁</li>
<li>自增长  </li>
<li>锁的算法</li>
<li>锁问题：丢失更新   脏读（不同事务下，可以读到另外事务未提交的数据  违反隔离性）  不可重复读（违反一致性）</li>
</ul>
</blockquote>
<p>锁升级 将当前锁的粒度降低   行-&gt;页-&gt;表</p>
<p>多用户 并发访问用到</p>
<blockquote>
<p>事务   ——-区别于文件系统重要特性之一</p>
<ul>
<li>ACID特性<br>A:原子性   整个事务是不可分割单位  只有所有事务的操作全执行成功，事务才算执行成功</li>
</ul>
</blockquote>
<p>C:一致性   一种状态到另一种状态  完整性约束没有被破坏</p>
<p>I:隔离性  在一个事务提交前 对其他事务不可见（通过锁来实现）</p>
<p>D:持久性（事务提交后 改变是永久性的）</p>
<p>A I D通过数据库的redo和undo来完成</p>
<ul>
<li><p>事务控制语句</p>
</li>
<li><p>隐式提交的sql语句+</p>
</li>
<li><p>事务隔离级别 四个</p>
</li>
<li><p>分布式事务</p>
</li>
<li><p>不好的事务习惯</p>
<blockquote>
<p>备份与恢复<br>热备 冷备 温备<br>性能调优</p>
</blockquote>
</li>
</ul>
<p>脏读（未提交数据） </p>
<p>锁升级 （粒度降低）行-&gt;页-&gt;表</p>
<p>XA事务</p>
<p>SERIALIABLE</p>
<p>二进制日志备份  快照备份  复制</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[天池竞赛学习总结（一）]]></title>
      <url>/p/79vmt/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kaggle竞赛学习总结（一）]]></title>
      <url>/p/79vmt/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[opencv学习总结（一）]]></title>
      <url>/p/79vms/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSM框架学习总结（一）]]></title>
      <url>/p/79vmr/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法和数据结构总结（一）]]></title>
      <url>/p/79vmr/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>中序线索二叉树</p>
<p>典型数据结构：集合结构  序列结构  层次结构  树形结构  图结构<br>线性表<br>单链表<br>双链表<br>循环链表<br>队列   优先队列  双端<br>堆栈  括号匹配  表达式计算和变换</p>
<p>字符串 </p>
<p>数组</p>
<p>矩阵</p>
<p>二叉树</p>
<p>树   深度  编号</p>
<p>森林</p>
<p>图  邻接矩阵  邻接表</p>
<p>基本图算法</p>
<p>最小生成树</p>
<p>最短路径</p>
<p>AOV/AOE网及其算法</p>
<p>AOV 拓扑排序</p>
<p>AOE 关键路径</p>
<p>AVL树  字典和集合</p>
<p>散列和散列表</p>
<h2 id="排序-稳定-不稳定"><a href="#排序-稳定-不稳定" class="headerlink" title="排序   稳定  不稳定"></a>排序   稳定  不稳定</h2><p>插入</p>
<p>希尔</p>
<p>冒泡</p>
<p>堆</p>
<p>堆排序</p>
<p>快速排序</p>
<p>选择排序</p>
<p>合并排序</p>
<p>值排序</p>
<p>查找</p>
<p>算法分析   时间复杂度   空间复杂度 </p>
<p>字典</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>python 列表insert放在最前面  列表append放在最后面<br>算法性质<br>//1有穷性 2能行性 3确定性 4    待更新</p>
<p>常数时间  多项式时间  指数时间<br>算法描述</p>
<p>算法设计和分析</p>
<p>进制转换（商为0停止）</p>
<p>最大公约数（辗转相除法 余数为0停止）  最小公倍数（两数相乘除以最大公约数）</p>
<p>枚举法</p>
<p>递归</p>
<p>分治法</p>
<p>贪心法</p>
<p>回溯法</p>
<p>动态规划  （最大连续子序列和  最长不下降子序列（LIS） 最长公共子序列（LCS） 最长回文子串 找零钱）</p>
<p>分支限界法</p>
<p>大整数  四则运算</p>
<p>分数</p>
<p>组合数</p>
<p>排列  散列  排序  链表处理</p>
<p>背包问题</p>
<p>并查集</p>
<p>堆</p>
<p><a href="https://www.jianshu.com/p/b66090f41f46" target="_blank" rel="noopener">算法笔记</a></p>
<p>数塔 动态规划   （递推 自底向上  递归  自顶向下）  重叠子问题和最优子结构   分治不重叠   贪心也有子结构但需要证明</p>
<p>设计状态和状态转移方程是动态规划的难点  以A[i]为结尾的。。。</p>
<p>最长回文子串  hash+二分</p>
<p>BKDRHash  ELFHash</p>
<p>动态链表  静态链表</p>
<p>stack     top()   empty()  push()   pop()  size()</p>
<p>queue   front() 队首元素  back（）队尾元素</p>
<p>pair   合成元素   （代替二元结构体   map插入）     first  second</p>
<p>map和set实现是用红黑树实现的</p>
<p>algorithm头文件下的常用函数<br>max()   min()  abs()  swap()  reverse()  sort() next_permutation() fill() lower_bound()  upper_bound() </p>
<p>set  [  erase()两种用法  1删除单个元素 2删除区间]     clear   find()     begin()  end()</p>
<p>string    substr(pos,len)   replace()    strcat  strlen  strcmp</p>
<p>prority_queue   优先级最高的元素是队首元素   只有通过top() 访问队首元素  less   greater    解决一些贪心问题  优先队列本质是堆</p>
<p>迭代器</p>
<p>全排列</p>
<p>散列  字符串散列 线性探查法  平方探查法  链地址法（拉链法）</p>
<p>二分法  two pointers</p>
<p>简单模拟 日期处理 </p>
<p>最大流问题：最大流网络和最大流  容量限制  流量守恒</p>
<p>Ford-Fulkerson方法</p>
<p>最大流最小切割定理</p>
<p>残存网络</p>
<p>增广路径</p>
<p>流网络的切割</p>
<p>最大二分匹配问题</p>
<p>推送-重贴标签算法</p>
<p>矩阵运算</p>
<p>线性规划</p>
]]></content>
      
        
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络学习总结（一）]]></title>
      <url>/p/79vmp/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习总结（一）]]></title>
      <url>/p/79vmp/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ssssss</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图像分割学习总结（一）]]></title>
      <url>/p/79vmp/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>按分割目的划分<blockquote>
<p>普通分割<br>将不同分属不同物体的像素区域分开。<br>如前景与后景分割开，狗的区域与猫的区域与背景分割开。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>语义分割   图像的语义分割（Semantic Segmentation）<br>在普通分割的基础上，分类出每一块区域的语义（即这块区域是什么物体）。<br>如把画面中的所有物体都指出它们各自的类别。</p>
<p>实例分割<br>在语义分割的基础上，给每个物体编号。<br>如这个是该画面中的狗A，那个是画面中的狗B。</p>
<p>Fully Convolutional Networks (FCN)</p>
</blockquote>
<p>我们介绍的第一篇论文是Fully Convolutional Networks for Semantic Segmentation，简称FCN。这篇论文是第一篇成功使用深度学习做图像语义分割的论文。论文的主要贡献有两点：</p>
<p>提出了全卷积网络。将全连接网络替换成了卷积网络，使得网络可以接受任意大小的图片，并输出和原图一样大小的分割图。只有这样，才能为每个像素做分类。<br>使用了反卷积层（Deconvolution）。分类神经网络的特征图一般只有原图的几分之一大小。想要映射回原图大小必须对特征图进行上采样，这就是反卷积层的作用。虽然名字叫反卷积层，但其实它并不是卷积的逆操作，更合适的名字叫做转置卷积（Transposed Convolution），作用是从小的特征图卷出大的特征图。</p>
<blockquote>
<p>DeepLab<br>DeepLab有v1 v2 v3，第一篇名字叫做DeepLab: Semantic Image Segmentation with Deep Convolutional Nets, Atrous Convolution, and Fully Connected CRFs。这一系列论文引入了以下几点比较重要的方法：</p>
</blockquote>
<p>第一个是带洞卷积，英文名叫做Dilated Convolution，或者Atrous Convolution。带洞卷积实际上就是普通的卷积核中间插入了几个洞，如下图。</p>
<blockquote>
<p>Pyramid Scene Parsing Network<br>Pyramid Scene Parsing Network的核心贡献是Global Pyramid Pooling，翻译成中文叫做全局金字塔池化。它将特征图缩放到几个不同的尺寸，使得特征具有更好地全局和多尺度信息，这一点在准确率提升上上非常有用。</p>
<p>Mask R-CNN<br>Mask R-CNN是大神何凯明的力作，将Object Detection与Semantic Segmentation合在了一起做。它的贡献主要是以下几点。</p>
</blockquote>
<p>第一，神经网络有了多个分支输出。Mask R-CNN使用类似Faster R-CNN的框架，Faster R-CNN的输出是物体的bounding box和类别，而Mask R-CNN则多了一个分支，用来预测物体的语义分割图。也就是说神经网络同时学习两项任务，可以互相促进。</p>
<p>第二，在语义分割中使用Binary Mask。原来的语义分割预测类别需要使用0 1 2 3 4等数字代表各个类别。在Mask R-CNN中，检测分支会预测类别。这时候分割只需要用0 1预测这个物体的形状面具就行了。</p>
<p>第三，Mask R-CNN提出了RoiAlign用来替换Faster R-CNN中的RoiPooling。RoiPooling的思想是将输入图像中任意一块区域对应到神经网络特征图中的对应区域。RoiPooling使用了化整的近似来寻找对应区域，导致对应关系与实际情况有偏移。这个偏移在分类任务中可以容忍，但对于精细度更高的分割则影响较大。</p>
<p>为了解决这个问题，RoiAlign不再使用化整操作，而是使用线性插值来寻找更精准的对应区域。效果就是可以得到更好地对应。实验也证明了效果不错。下面展示了与之前方法的对比，下面的图是Mask R-CNN，可以看出精细了很多。</p>
<blockquote>
<p>U-Net<br>U-Net是原作者参加ISBI Challenge提出的一种分割网络，能够适应很小的训练集（大约30张图）。U-Net与FCN都是很小的分割网络，既没有使用空洞卷积，也没有后接CRF，结构简单。</p>
</blockquote>
<p>类似于一个大大的U字母：首先进行Conv+Pooling下采样；然后Deconv反卷积进行上采样，crop之前的低层feature map，进行融合；然后再次上采样。重复这个过程，直到获得输出388x388x2的feature map，最后经过softmax获得output segment map。总体来说与FCN思路非常类似。</p>
<p>为何要提起U-Net？是因为U-Net采用了与FCN完全不同的特征融合方式：拼接！</p>
<p>语义分割网络在特征融合时也有2种办法：</p>
<p>FCN式的逐点相加，对应caffe的EltwiseLayer层，对应tensorflow的tf.add()<br>U-Net式的channel维度拼接融合，对应caffe的ConcatLayer层，对应tensorflow的tf.concat()</p>
<blockquote>
<p>FCN-全卷积网络<br>CRF-条件随机场<br>MRF-马尔科夫随机场</p>
</blockquote>
<p>FCN<br>此处的FCN特指Fully Convolutional Networks for Semantic Segmentation论文中提出的结构，而非广义的全卷积网络。</p>
<p>作者的FCN主要使用了三种技术：</p>
<p>卷积化（Convolutional）<br>上采样（Upsample）<br>跳跃结构（Skip Layer）</p>
<blockquote>
<p>卷积化</p>
</blockquote>
<p>卷积化即是将普通的分类网络，比如VGG16，ResNet50/101等网络丢弃全连接层，换上对应的卷积层即可。</p>
<blockquote>
<p>上采样</p>
</blockquote>
<p>此处的上采样即是反卷积（Deconvolution）。当然关于这个名字不同框架不同，Caffe和Kera里叫Deconvolution，而tensorflow里叫conv_transpose。CS231n这门课中说，叫conv_transpose更为合适。</p>
<p>众所诸知，普通的池化（为什么这儿是普通的池化请看后文）会缩小图片的尺寸，比如VGG16 五次池化后图片被缩小了32倍。为了得到和原图等大的分割图，我们需要上采样/反卷积。</p>
<p>反卷积和卷积类似，都是相乘相加的运算。只不过后者是多对一，前者是一对多。而反卷积的前向和后向传播，只用颠倒卷积的前后向传播即可。所以无论优化还是后向传播算法都是没有问题</p>
<blockquote>
<p>跳跃结构</p>
</blockquote>
<p>（这个奇怪的名字是我翻译的，好像一般叫忽略连接结构）这个结构的作用就在于优化结果，因为如果将全卷积之后的结果直接上采样得到的结果是很粗糙的，所以作者将不同池化层的结果进行上采样之后来优化输出</p>
<blockquote>
<p>SegNet/DeconvNet<br>这样的结构总结在这儿，只是我觉得结构上比较优雅，它得到的结果不一定比上一种好。</p>
<p>DeepLab<br>接下来介绍一个很成熟优雅的结构，以至于现在的很多改进是基于这个网络结构的进行的。</p>
</blockquote>
<p>首先这里我们将指出一个第一个结构FCN的粗糙之处：为了保证之后输出的尺寸不至于太小，FCN的作者在第一层直接对原图加了100的padding，可想而知，这会引入噪声。</p>
<p>而怎样才能保证输出的尺寸不会太小而又不会产生加100 padding这样的做法呢？可能有人会说减少池化层不就行了，这样理论上是可以的，但是这样直接就改变了原先可用的结构了，而且最重要的一点是就不能用以前的结构参数进行fine-tune了。所以，Deeplab这里使用了一个非常优雅的做法：将pooling的stride改为1，再加上 1 padding。这样池化后的图片尺寸并未减小，并且依然保留了池化整合特征的特性。</p>
<p>但是，事情还没完。因为池化层变了，后面的卷积的感受野也对应的改变了，这样也不能进行fine-tune了。所以，Deeplab提出了一种新的卷积，带孔的卷积：Atrous Convolution</p>
<blockquote>
<p>全连接条件随机场(DenseCRF)</p>
</blockquote>
<p>对于每个像素i具有类别标签x_i还有对应的观测值y_i，这样每个像素点作为节点，像素与像素间的关系作为边，即构成了一个条件随机场。而且我们通过观测变量y_i来推测像素i对应的类别标签x_i。条件随机场如下：</p>
<p>２０１５年提出的ＳｅｇＮｅｔ网络是由编码器和解码器<br>构成的分割网络<br>前半部分是由卷积层和池化层<br>组成的编码器，后半部分是由卷积层和上采样层组成<br>的解码器。ＳｅｇＮｅｔ网络中，编码器提取特征图像，解码<br>器将特征图像返回到输入图像的原始尺寸，以此方式<br>实现端到端的网络结构。<br>在此之后，又有大批的分割网络涌现出来。但大<br>多都在ＦＣＮ的基础上一步步发展而来。下面对全卷<br>积网络的主要构成进行概述</p>
<p>传统：水平集，区域生长，阈值，分水岭</p>
<p>基于阈值分割，基于边缘分割，基于聚类分<br>割，基于轮廓分割，基于区域分割以及卷积神经网络</p>
<blockquote>
<p>区域生长：<br>该方法通过定义一个生长规则，然后在每一个Ｐ域内寻找一个种子像素，通过对<br>图像进行扫描，依次在种子点周围邻域内寻找满足生长规则的像素并将其合并<br>到种子所在的区域，然后再检查该区域的全部相邻点，并把满足生长准则的点<br>合并到该区域，不断重复该过程直到找不到满足条件的像素为止。</p>
</blockquote>
<p>对于噪声过多和灰度值不均匀的图像容易产生欠拟合和过拟合的问题</p>
<blockquote>
<p>分水岭算法<br>基于拓扑理论，通过模拟形态学<br>的方法进行图像分割</p>
<p>水平集算法</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 图像分割 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数字图像处理学习总结（一）]]></title>
      <url>/p/79vmo/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习总结（一）]]></title>
      <url>/p/79vmo/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>假设样本空间全体样本服从一个未知分布</p>
<p>认识数据  离散 连续</p>
<p>数据集</p>
<p>数据增强</p>
<p>召回率</p>
<p>准确率</p>
<p>F1 score</p>
<p>损失函数</p>
<p>分类器</p>
<p>贝叶斯</p>
<p>支持向量机</p>
<p>典型核函数 </p>
<p>集成算法<br>boosting<br>bagging<br>stacking</p>
<p>随机森林</p>
<p>决策树</p>
<p>聚类<br>原型<br>kmeans<br>knn<br>层次<br>自上而下<br>自下而上</p>
<p>密度</p>
<p>网格</p>
<p>降维 PCA </p>
<p>监督学习<br>无监督学习<br>半监督学习<br>强化学习</p>
<p>概率图模型 条件随机场  马尔科夫</p>
<p>神经网络</p>
<p>欠拟合与过拟合</p>
<p>dropout</p>
<p>数据预处理</p>
<p>优化算法<br>sgd,bgd 随机梯度下降  批量梯度下降<br>动量<br>动量法（Ｍｏｍｅｎｔｕｍ）通过模拟物体运动时所产生的惯性来对其权值进行更<br>新，通过模拟惯性时在一定程度上维持了物体原有的状态，然后在此状态上对其<br>进行微调使其朝着正确的方向下降</p>
<p>Ａｄａｍ</p>
<p>最小批梯度下降法（ＭＢＧＤ</p>
<p>端到端</p>
<p>激活函数</p>
<p>在前向传播的过程<br>中，会釆用激活函数的方式，对产生的结果进行非线性的处理。反向传播则是通<br>过对结果误差的分析，通过链式法则和梯度下降的方法对神经网络中的权值进行<br>调整，使结果更加接近于准确值。</p>
<p>梯度爆炸  梯度消失</p>
<p>ｔａｎｈ函数与ｓｉｇｍｏｄ函数关系如（２－４）所示，<br>ｔａｎｈ（ｘ）＝２ｓｉｇｍｏｄ（２ｘ）—１</p>
<p>ｒｅｌｕ函数的出现有效的解决了梯度消失的问题，同时其收敛速度比另<br>外两个函数更快</p>
<p>全卷积网络作为第一个针对语<br>义进行分析的深度学习结构，在图像识别方面具有重要的影响力。Ｕ－ＮＥＴ网络<br>作为针对医疗图像进行分析的网络结构，在细胞检测等方面应用广泛。ＳｅｇＮｅｔ网<br>络作为目前最为高效的深度学习模型之一，在道路识别具有广泛的应用。</p>
<p>BN 批标准化操作</p>
<p>ＲＯＣ曲线<br>AUC值</p>
<p>残差结构的概念的提出有效的解决了由于网络层次加深而导致的网<br>络性能退化的问题，通过拟合残差映射的方式，即不直接将卷积结果作为输出，<br>而是采用残差映射的方式来进行计算</p>
<p>残差公式 H(x)=x+F(x)</p>
<p>编码器  解码器</p>
<p>数据集产生测试集</p>
<p>留出法     分层采样</p>
<p>交叉验证法   k=m时  留一法</p>
<p>自助法   数据集较小、难以有效划分训练/测试集时很有用;，在初始数据量足够时，留出法和交叉验证法更常用一些.</p>
]]></content>
      
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自然语言处理学习总结（一）]]></title>
      <url>/p/79vmn/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[循环神经网络总结]]></title>
      <url>/p/79vmm/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[卷积神经网络总结]]></title>
      <url>/p/79vmm/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>局部感知，权值共享<br>减少了人工神经网络的训练参数，提高了训练效率</p>
<p>局部链接是指卷积神经网络中每一层的神经元只和上一层的一些区域<br>进行连接。权值共享是指对同一个神经元，用于连接数据窗的权重是固定的。</p>
<p>感受野？</p>
<p>特征图 参数个数 连接数的计算？</p>
<p>卷积</p>
<p>池化<br>同时池化层具有平移不变性，即即使图像经历了一小段位移，通过池化层所提取的特征也不会有变化</p>
<p>全连接</p>
<p>反卷积</p>
<p>尺寸变大，特征图数量减少</p>
<p>采用卷积神经网络对图像进行处理主要分为五个阶段，图像预处理，神经网<br>络的构建，神经网络的训练以及参数调节，对于目标函数进行预测以及图像的后<br>处理</p>
<p>图像处理一般分为图像灰度化，图像增强，<br>图像去噪，图像二值化四个方面。</p>
<p>U-Net的特点：<br>（1）将全连接层转换成卷积层 </p>
<p>（2） 增加反卷积层<br>（3）增加跳跃结构。CNN 通过浅层卷积提取图<br>像的细节特征，如边缘、角点等，深层网络提取语义<br>特征，如类别等( Akeret et al．，2017) 。U-Net 网络包<br>括了两个呈对称状态的路径，左侧为收缩路径，用于<br>捕捉图像的内容，右侧为扩张路径，用于精准定位。<br>右侧路径每一次上采样都与对应左侧路径卷积层的<br>特征进行拼接，融合多尺度特征，获得更丰富的图像<br>信息。</p>
<p>图像分割中通常使用许多标准来评估算法的精<br>度，这些精度通常都是像素精度及 IoU 的变种。</p>
<p>采用 3 种语义分割评价指标对分割结果进行评<br>测，即: 统计像素准确率( pixel accuracy，PA) 、均像<br>素精度( mean pixel accuracy，MPA) 和平均区域重合<br>度( mean intersection over union，M-IoU) ，对网络的<br>分割结果进行评估( 杨阿庆等，2017) 。</p>
<p>实验环境：<br>基于 NVIDIA GTX1080 GPU 的硬件平<br>台上搭建 Tensorflow 深度学习框架</p>
<p>目前主流物体检测算法需要预先划定默认框，通过对默认框的筛选剔除得到物体框</p>
<p>主流深度学习物体检测模型</p>
<p>采用的是回归的思想<br>YOLO</p>
<p>SSD</p>
<p>基于区域候选的思想<br>SPP-net</p>
<p>Ｒ-FCN</p>
<p>由于物体数量不可预知，不<br>论是第 1 类还是第 2 类都需要按照一定的方式划定<br>默认框( default boxes、anchors) ，从而建立起默认框<br>预测框、真值物体框的关系以进行训练</p>
<p>迁移学习</p>
<p>０１４年Ｓｉｍｏｎｙａｎ提出的ＶＧＧ网络，通过不断加<br>深网络结构，对网络进行优化；从增强卷积功能方面进行优化，２０１４年<br>Ｇ〇〇ｇｌｅＮｅｔ网络的提出，通过采用不同的卷积核进行卷积操作，最后进行融合<br>来，进而强化卷积功能</p>
<p>VGG-16<br>VGG-19</p>
<p>AlexNet<br>ＡｌｅｘＮｅｔ网络由五个卷积层和三个全连接层组成，与ＬｅＮｅｔ网络相比，该<br>网络增加网络的卷积层以及全连接层的层数，増加特征提取的准确性，通过更换<br>激活函数，采用修正线性单元，加入Ｄｒｏｐｏｕｔ层等<br>方法减少过拟合现象的出现，通过使用ＧＰＵ来加快神经网络的训练速度，使得<br>该网络具有更高的适用性</p>
<p>LeNet<br>ＬｅＮｅｔ网络，该网络由三个卷积层，一个下采样层以<br>及一个全连接层组成 手写数字的识别<br>方面有很好的效果，是卷积神经网络的第一个网络结构</p>
<p>GoogleNet</p>
<p>resNet</p>
<p>Inception</p>
<p>V-Net</p>
<p>采用 经 典 的 语 义 分 割 模 型，<br>如 FCN、Seg-Net、PSP-Net、DeepLab、Ｒefine-Net、U-Net等经典模型进行语义分割，<br>利用特征提取模块所提取的特征，实现对每个像素点的密集分类，<br>本文采用最基础的 FCN 模型为基础进行实</p>
<p>传统的算法诸如阈值分割、边缘分割等，取得了卓越的成就</p>
<p>深度学习的前端和后端是什么</p>
<p>图像分类、图像分割、目标检测</p>
]]></content>
      
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习框架学习]]></title>
      <url>/p/79vml/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>tensorflow<br>TensorFlow 支持 14 种不同的类型，实数<br>（ tf.float32 tf.float64 ）、整<br>数（ tf.int8 tf.intl6 tf.int32 tf.int64 tf.uint8 ）、布尔型 tf.bool) 和复数（ tf.complex64<br>tf.complex128<br>计算图<br>会话<br>张量 name shape dtype<br>每个节点都是一个运算，而每 条边代表了计算之间的依赖关系</p>
<p>tf.Graph()<br>tf.get_default_graph()</p>
<p>变量.initializer</p>
<p>为了方便 变量初始化用tf.global_variables_initializer</p>
<h2 id="用placeholder代替常量"><a href="#用placeholder代替常量" class="headerlink" title="用placeholder代替常量"></a>用placeholder代替常量</h2><p>tf.placeholder(tf.float32,shape=(1,2),name=’input’)</p>
<p>sess=tf.Session()</p>
<p>y是一堆操作<br>sess.run(y,feed_dict={x:[[0.8,0.9]]})</p>
<h2 id="损失函数刻画当前预测值和真实答案之间的差距。然后通过反向传播使差距减小-（优化目标）"><a href="#损失函数刻画当前预测值和真实答案之间的差距。然后通过反向传播使差距减小-（优化目标）" class="headerlink" title="损失函数刻画当前预测值和真实答案之间的差距。然后通过反向传播使差距减小 （优化目标）"></a>损失函数刻画当前预测值和真实答案之间的差距。然后通过反向传播使差距减小 （优化目标）</h2><p>tf.train.AdadeltaOptimizer(learning_rate= 学习率).minimize(损失函数)</p>
<p>tf.nn.relu<br>tf.sigmoid<br>tf.tanh</p>
<p>均方误差 MSE</p>
<p>tf.where  相似于条件表达式<br>tf.greater<br>多层网络解决异或运算</p>
<p>噪声<br>避免过拟合 正则化 （限制权重大小 ）</p>
<p>滑动平均模型</p>
<h2 id="训练数据包括训练集和验证集-验证集来‘训练’超参数"><a href="#训练数据包括训练集和验证集-验证集来‘训练’超参数" class="headerlink" title="训练数据包括训练集和验证集 验证集来‘训练’超参数"></a>训练数据包括训练集和验证集 验证集来‘训练’超参数</h2><p>tf.variable_scope 命名空间<br>tf.get_variable  reuse=True 已经创建的变量   reuse=False 新建变量</p>
<p>tensorflow模型持久化 tf.train.Saver()<br>.meta 计算图的结构<br>.ckpt  变量的取值</p>
<p>卷积和池化 特征提取<br>全连接   分类</p>
<h2 id="参数计算："><a href="#参数计算：" class="headerlink" title="参数计算："></a>参数计算：</h2><p>卷积神经网络<br>过滤器长<em>宽</em>深*输入深度+过滤器深</p>
<p>全连接网络<br>输入*节点个数+节点个数</p>
<p>输出特征图尺寸：<br>（（输入-过滤器+2*填充）/步长）+1</p>
<p>池化层 减小矩阵尺寸 一般不改变深度 减少最后全连接层的参数</p>
<p>卷积层使用过滤器横跨整个深度，池化层过滤器只影响一个深度的节点</p>
<p>tf.nn.conv2d<br>tf.nn.max_pool<br>tf.nn.avg_pool</p>
<p>全连接参数个数：<br>输入*输出+输出</p>
<p>Inception 将卷积层并联在一起</p>
<p>当使用全0填充 步长为1时 输出矩阵大小相同 将深度拼接</p>
<p>Inception-v3有46层 11个Inception模块组成  有96个卷积层</p>
<p>迁移学习   瓶颈层</p>
<p>\ 一行不够下一行接着写</p>
<p>tensorflow多线程处理输入数据  队列</p>
<p>循环神经网络<br>序列数据<br>长期依赖问题   提出LSTM</p>
<h2 id="tensorBoard可视化高维向量"><a href="#tensorBoard可视化高维向量" class="headerlink" title="tensorBoard可视化高维向量"></a>tensorBoard可视化高维向量</h2><p>input1=tf.constant([1.0,2.0,3.0],name=”input1”)<br>input2=tf.Variable(tf.random_uniform([3]),name=”input2”)<br>output=tf.add_n([input1,input2],name=”add”)<br>writer=tf.summary.FileWriter(‘/home/zhangxuefeng/log’,tf.get_default_graph())<br>writer.close()</p>
<p>tensorboard —logdir={pwd}</p>
<p>name_scope和Variable_scope区别<br>tf.get_variable不受name_scope影响 不加命名空间</p>
<p>深度学习训练并行模式 多GPU并行  同步模式（效率不如异步模式）  异步模式（参数更新有问题）</p>
<p>分布式Tensorflow</p>
<h1 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">清华大学开源软件镜像站</a></p>
<p>conda config —add channels</p>
<h2 id="检查pytorch是否支持GPU"><a href="#检查pytorch是否支持GPU" class="headerlink" title="检查pytorch是否支持GPU"></a>检查pytorch是否支持GPU</h2><p>import torch<br>torch.cuda.is_available()</p>
<h2 id="pyTorch基础"><a href="#pyTorch基础" class="headerlink" title="pyTorch基础"></a>pyTorch基础</h2><p>Tensor可以和numpy的ndarray可以相互转换 区别在于Tensor可以在GPU运行，而ndarray只能CPU运行<br>不同数据类型的Tensor,torch.FloatTensor,torch.DoubleTensor,torch.ShortTensor,torch.IntTensor,torch.LongTensor<br>print(“a is :{}”.format(a))<br>torch.zeros((2,3))<br>torch.randn((3,2))</p>
<p>torch.utils.data.Dataset</p>
<p>torchvision 数据读取类 ImageFolder</p>
<p>torch.nn.Module<br>torch.optim 优化<br>一阶优化算法 梯度下降<br>二阶优化算法 Hessian方法  基于牛顿法</p>
<h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><p>torch.save()   第一个参数保存对象  第二个参数是保存路径和名称</p>
<p>nn.Linear()<br>nn.Sigmoid()</p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>通过梯度*学习率更新参数<br>sigmoid函数的两个缺点<br>（1）梯度消失<br>（2）非0均值<br>tanh函数<br>仍然存在梯度消失<br>解决了0均值问题</p>
<p>RELU<br>训练脆弱</p>
<p>maxout</p>
<p>交叉熵</p>
<p>均方误差</p>
<h2 id="模型的表示能力和容量"><a href="#模型的表示能力和容量" class="headerlink" title="模型的表示能力和容量"></a>模型的表示能力和容量</h2><h2 id="梯度下降法变式"><a href="#梯度下降法变式" class="headerlink" title="梯度下降法变式"></a>梯度下降法变式</h2><p>Momentum<br>动量： 动量计算，基于前面的梯度，也就是说参数更新不仅仅基于当前的梯度，也基于之前的梯度。</p>
<p>动量变形  Nesterov 计算经过动量更新后的位置的梯度<br>Adagrad<br>自适应学习率</p>
<p>RMSprop</p>
<p>Adam(可以看成是RMSprop+Momentum)</p>
<h2 id="Tensor的拼接"><a href="#Tensor的拼接" class="headerlink" title="Tensor的拼接"></a>Tensor的拼接</h2><p>torch.cat()</p>
<h2 id="处理数据和训练模型的技巧"><a href="#处理数据和训练模型的技巧" class="headerlink" title="处理数据和训练模型的技巧"></a>处理数据和训练模型的技巧</h2><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>中心化</p>
<p>标准化</p>
<p>PCA</p>
<p>白噪声</p>
<h3 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h3><p>全0初始化<br>随机初始化<br>稀疏初始化<br>初始化偏置<br>批标准化</p>
<h3 id="防止过拟合"><a href="#防止过拟合" class="headerlink" title="防止过拟合"></a>防止过拟合</h3><p>正则化<br>Dropout<br>nn.RELU(True)<br>nn.Conv2d  卷积模块</p>
<p>nn.MaxPool2d<br>nn.AvgPool2d<br>nn.BatchNorm2s<br>LeNet 网络层数很浅，也没激活层      1998年LeCun提出<br>AlexNet相对于LeNet层数更深，第一次引入激活层RELU,全连接层引入Dropout层防止过拟合 有8层   11*11滤波器    2012年冠军</p>
<p>VGG使用很多小对的滤波器 层叠很多小的滤波器的感受野和一个大的滤波器的感受野是相同的，还能减少参数，同时有更深的网络结构  2014年亚军</p>
<p>GoogleNet(InceptionNet)   22层    2014年冠军</p>
<p>ResNet 2015 ImageNet竞赛冠军 残差模块 152层神经网络 恒等映射    H(x)-x</p>
<p>LSTM      nn.LSTM()<br>记忆状态C<br>GRU将输入门和遗忘门合成更新门</p>
<p>生成对抗网络<br>生成模型      自动编码器  （编码器生成隐含向量  解码器） 变分自动编码器<br>生成对抗网络的变式和应用</p>
<p>WGAN<br>Cycle GAN</p>
<h1 id="caffe"><a href="#caffe" class="headerlink" title="caffe"></a>caffe</h1><h1 id="keras"><a href="#keras" class="headerlink" title="keras"></a>keras</h1><h1 id="theano"><a href="#theano" class="headerlink" title="theano"></a>theano</h1><h1 id="mxnet"><a href="#mxnet" class="headerlink" title="mxnet"></a>mxnet</h1><h1 id="fast-ai"><a href="#fast-ai" class="headerlink" title="fast.ai"></a>fast.ai</h1><p>服务器 anaconda启动jupyter notebook报错</p>
<p> Error loading server extension jupyter_nbextensions_configurator<br> ModuleNotFoundError: No module named ‘jupyter_nbextensions_configurator’</p>
<p> 看内存大小<br>free -m</p>
<p>free -h</p>
<p>MAP(mean average precision)</p>
<p>张量（名字 维度 类型）</p>
<p>CNN 通过浅层卷积提取图<br>像的细节特征，如边缘、角点等，深层网络提取语义<br>特征，如类别等</p>
<p>torch.optim 实现各种优化算法包</p>
<p>保存和加载<br>torch.save(model,’…….pth’)  结构和参数信息</p>
<p>torch.load(‘model.pth’)</p>
<p>sigmoid是logistic分布函数特殊形式</p>
<p>torchvision.transforms     可以图像增强 转化成Tensor</p>
<p>循环神经网络  基于记忆的模型</p>
<p>判别式模型又可以称为条件概率模型，</p>
<p>典型的判别式模型包括 k 近邻、决策树、卷积神经网<br>络、支持向量机（SVM）等。 </p>
<p>典型的生成式模型有：朴素贝叶斯和隐马尔<br>科夫模型等。 </p>
<p>自编码器的应用主要有两个方面，第一是<br>数据去噪，第二是为进行可视化降维。 </p>
<p>用%automagic on 启用自动魔术命令功能后，可以省略百分号“%’<br>的输入即可直接运行魔术命令</p>
<p>J  焦点上移一个 ce ll;<br>K  焦点下移一个 cell 熟悉 im 读者对这 模式应该很习惯；<br>A  在当前 cell 上面插入 个新的 cell;<br>B  在当前 cell 的下面插入 个新的 cell;<br>DD 连续按两次 ，删除当前 cell 。这是另 vimer 喜欢”的功能编辑模式如下。</p>
<h2 id="numpy知识"><a href="#numpy知识" class="headerlink" title="numpy知识"></a>numpy知识</h2><p>np.zeros((3,3))</p>
<p>np.ones((3,3))</p>
<p>np.random.randn()</p>
<p>np.random.randint(10 , 20 , 6)    10到20之间 6个随机数</p>
<p>b = np . random.randint(l , 5 , 20) . reshape(4 , 5)</p>
<p>a= np.arange(6)<br>In [ 4] : a + 5 ＃数组和标量<br>Out [ 4] : array ( [ 5 , 6 , 7 , 8 , 9 , 1 0 ] )</p>
<p>np.linspace(-np . pi , np.pi , 200)</p>
<p>需要注意 乘法是对应元素相乘 不是矩阵内积 矩阵内积使用 np.dot（）函 数。</p>
<p>Numpy 提供了 些基本的统计功能，包括求和、求平均值、求方差等</p>
<p>a . sum ()<br>a.mean()<br>a . std()<br>a.min()<br>a . max()<br>a . argmin() ＃最小值元素所在的索引<br>a . argmax() ＃最大值元素所在的索引</p>
<p>In [78) : b<br>Out[78) :<br>array( [ [3 , 2 , 4 , 2),<br>[ 4 , 5 , 1, l),<br>[ 4 , 4 , 1 , 4) ,<br>[3 , 3 , 4, 4) ,<br>[3 , 2, 4 , 5) ,<br>[3 , 5 , 2, 5]))<br>In [85) : b . sum()<br>Out [ 85) : 78<br>In [86) : b . sum(axis=O}<br>Out [ 8 6 ) : array ( [ 2 0 , 2 1 , 1 6 , 21 ) )<br>In [87) : b . sum(axis=l}<br>Out [87): array ( [11 , 11 , 13, 14, 14, 15))<br>In [88) : b.sum(axis=l} . sum()<br>Out [88) : 78<br>In [94) : b .min(axis=l}<br>Out[94) : array([2 , 1 , 1 , 3 , 2 , 2))<br>In [95) : b . argmin (axis=l}<br>Out[95) : array([l , 2 , 2 , 0 , 1 , 2))<br>In [96) : b.std(axis=l )</p>
<p>In (37) : a<br>Out (37] :<br>array ( [ [ 1, 4 , 8 , 10],<br>(10 , 9 , 6 , 2] ,<br>[ 1 , 4 ‘ 10 ‘ 5] ,<br>[ 5 , 7 , 1 , 1] ‘<br>[ 5 , 2 , 2 , 8 ],<br>[ 6 , 10 , 10 , 7]])<br>In [40) : b = np . sort (a , axis=1) ＃按行独立排序，返回一个备份<br>In[41) : b<br>Out[41 ):<br>array ( ([ 1 , 4 , 8 , 10) ,<br>[ 2 , 6 , 9 , 10) , </p>
<p>[1 , 4 , 5 , 10],<br>[1 , 1 , 5 , 7],<br>[2 , 2 , 5 , 8] ,<br>[6 , 7 , 10 , 10])</p>
<p>保存为文本格式的可读性好，但性能较低。也可以直接保存为 Numpy 有的二进<br>格式    np . save ( ’ a . npy ’, a)</p>
<p>c = np.load(‘a.npy’)</p>
<h1 id="Pandas知识"><a href="#Pandas知识" class="headerlink" title="Pandas知识"></a>Pandas知识</h1><p>Panda 是一个强大的时间序列数据处理工具包<br>Pandas 最基础的数据结构是 Series   另一个是DataFrame</p>
<p>df = pd . DataFrame(np . random . randn(6 , 4) , columns=list ( ’ ABCD ’ ))</p>
<p>df.shape<br>[OUT) : ( 6 , 4 )</p>
<p>df. h ead (3 )</p>
<p>df . tail (2)</p>
<p>df. describe ()<br>describ （）计算出每列的元素个数、平均值、标准差、最小值、最大<br>值及几种中位数的值</p>
<p>可以很方便地对数据进行修改，如可以添加 列，列名为 TAGo<br>(IN] : df (” TAG ” ]=[” cat”, ” dog”,”cat”,”cat”,”cat ”,”dog” ]</p>
<p>df =pd.read csv (’ data . csv ’, index col=O}</p>
<p>我们还可以使用 DataFrame to_ csv（）函数把数据保存到文件中</p>
<h1 id="Matplotlib知识"><a href="#Matplotlib知识" class="headerlink" title="Matplotlib知识"></a>Matplotlib知识</h1><h1 id="scikit-learn知识"><a href="#scikit-learn知识" class="headerlink" title="scikit-learn知识"></a>scikit-learn知识</h1><p>scikit-learn 是一个开源的 Python 机器学习工具包</p>
<p>from sklearn import datasets<br>digits = datasets .load_digits ()</p>
<p>这个过程就是数据清洗，即把采集到的 、不适合用<br>来做机器学习训练的数据进行预处理，从而转换为适合机器学习的数据。</p>
<p>scikit-le arn 所有的评估模型对象都有 fit（）这个接口，这是用来 练模型的接口。针对<br>有监督的机器学习（如上面的例子〉，使用 fit(X, ）来进行训练，其中 是标记数据。针<br>对无监督的机器学习算法，使用自t(X）来进行训练，因为无监督机器学习算法的数据集是<br>没有标记的，不需要传入y</p>
<p>2.8 妇展学习资源、</p>
<ol>
<li><a href="http://scipy" target="_blank" rel="noopener">http://scipy</a> ctures.org ，这是一个按照 CC4.0 协议发布的网站，是 个优秀的 Python<br>科学计算工具包的教程合集。</li>
<li><a href="https://docs.scipy.org/doc/" target="_blank" rel="noopener">https://docs.scipy.org/doc/</a> , numpy scipy 的官方文档。</li>
<li><a href="https://en.wikipedia.org/wiki/Random_walk" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Random_walk</a> ，随机漫步算法。</li>
<li><a href="https://en.wikipedia.org/wiki/S" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/S</a> ieve <em>of</em> Eratosthenes 埃拉托斯特尼筛法</li>
<li><a href="https://en" target="_blank" rel="noopener">https://en</a>. wikipedia.org/wiki/Monte _Carlo method 蒙特卡罗方法</li>
<li><a href="http://pandas.pydata.org" target="_blank" rel="noopener">http://pandas.pydata.org</a>, Pandas 官网</li>
<li><a href="http://matplotlib.org" target="_blank" rel="noopener">http://matplotlib.org</a>, matplotlib 的官方网站 ，包含大量 绘图实例。</li>
<li><a href="http://scikit-learn.org/stable/documentation.html" target="_blank" rel="noopener">http://scikit-learn.org/stable/documentation.html</a>, scikit-learn 宫方文档。</li>
</ol>
<p>在模型选择时，我们使用训练数据集来 练算法参数，用 交叉验证数据集来验证参数。<br>选择交叉验证数据集的成本 lcv（（）） 最小的多项式来作为数据拟合模型，最后再用测试数据<br>集来测试选择出来的模型针对测试数据集的准确性</p>
<p>在scikit-leam 里，评估模型性能的算法都在 klean. metrics 里。其中，计算查准率<br>和召回率的 API 分别为 sklean.metrics precision<em> score（）和 sklean .metrics.recall</em> score （）</p>
<p>squeeze 函数：从数组的形状中删除单维度条目，即把shape中为1的维度去掉</p>
<p>flatten层</p>
<p><a href="https://blog.csdn.net/program_developer/article/details/80853425" target="_blank" rel="noopener">https://blog.csdn.net/program_developer/article/details/80853425</a></p>
<p>很好用的网络可视化工具，专门用来可视化.prototxt文件，你可以将.prototxt文件中的内容复制到该链接点击打开 <a href="http://ethereon.github.io/netscope/#/editor" target="_blank" rel="noopener">http://ethereon.github.io/netscope/#/editor</a><br>，然后按下Shift+Enter,就可以看到漂亮的网络结构啦</p>
<h1 id="支持向量机："><a href="#支持向量机：" class="headerlink" title="支持向量机："></a>支持向量机：</h1><p>SVM有三种模型，由简至繁为</p>
<p>当训练数据训练可分时，通过硬间隔最大化，可学习到硬间隔支持向量机，又叫线性可分支持向量机<br>当训练数据训练近似可分时，通过软间隔最大化，可学习到软间隔支持向量机，又叫线性支持向量机<br>当训练数据训练不可分时，通过软间隔最大化及核技巧(kernel trick)，可学习到非线性支持向量机</p>
<h1 id="梯度提升决策树（Gradient-Boosting-Decision-Tree，GB⁃"><a href="#梯度提升决策树（Gradient-Boosting-Decision-Tree，GB⁃" class="headerlink" title="梯度提升决策树（Gradient Boosting Decision Tree，GB⁃"></a>梯度提升决策树（Gradient Boosting Decision Tree，GB⁃</h1><p>DT）是一种迭代决策树算法</p>
<p>xgboost<br>lightgbm</p>
<h1 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h1><p>主成分分析法是通过数学降维方法, 从众多原始变量中找出几个综合性强的变量来代替原始变量, 这些综合性强的几个变量彼此间互不相关且能最大程度反映原始变量的信息量[5]。</p>
<p>主成分分析计算步骤如下。</p>
<p>步骤1:对原始数据进行标准化处理并计算相关系数矩阵。</p>
<p>步骤2:计算特征值与特征向量。求出相关系数矩阵的特征值λ (i=1, 2, …, p) , 并使其按大小顺序排列, 即λ1≥λ2≥λ3…≥λp≥0, 然后分别求出对应于特征值的特征向量ei (i=1, 2, …, p) , 其中p为相关系数矩阵的阶数。</p>
<p>步骤3:计算主成分贡献率与累计贡献率。经过筛选分析, 选取累计贡献率达到85%以上的因子作为需水量的主要影响因子即主成分。</p>
<p>步骤4:计算主成分载荷。表示原始数据的协方差矩阵的特征值。</p>
<h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><p>EM 算法是在机器学习和计算机视觉的数据聚类<br>（Data Clustering）领域常用方法之一，在实际应用中，我们所观察到的数据很多时候是不完全数据，而<br>传统的优化方法在处理缺失数据情况下的极大似然估计会变得异常复杂，由此学者们提出了 EM 算法</p>
<p>M 算法也称期望最大化算法，是一种从不完全数据中求参数极大似然估计的迭代算法</p>
<p>EM 算法经常被应用于混合模型的参数估计当中，众所周知，正确使用该方法的前提是知道混合模<br>型中子总体的个数（即混合模型中的分布个数）C   </p>
]]></content>
      
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux系统搭建以及学习（黑客）]]></title>
      <url>/p/79vmf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>渗透测试</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[python学习（一）]]></title>
      <url>/p/79vm9/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">Python教程- 廖雪峰的官方网站</a><br>整除 //<br>普通除法 /<br>sys模块<br>sys.stdin</p>
<p>str int float bool tuple set </p>
<p>self cls </p>
<p>装饰器  @staticmethod<br>strip()</p>
<p>ipython<br>魔术命令</p>
<p>%run 文件</p>
<p>%magic</p>
<p>（2）%paste粘贴文本<br>选择你要复制的代码，Ctrl+C复制，在ipython解释器中直接输入%paste则将复制的代码完整粘贴并且自动执行代码输入结果</p>
<p>（3）%cpaste也是粘贴文本的，但与%paste区别的是输入%cpaste命令后提示信息，该提示信息的意思是：</p>
<p>可以粘贴任何你复制的每一条代码，在你输入结束命令之前都不会执行代码，输入‘—’按回车或者使用‘Ctrl-D’停止粘贴代码，停止粘贴代码后会执行代码</p>
<p>%hist指历史命令</p>
<p>os.path.exists</p>
<p>os.path.join</p>
]]></content>
      
        
        <tags>
            
            <tag> python学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hbase环境搭建]]></title>
      <url>/p/79vm7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spark环境搭建]]></title>
      <url>/p/79vm6/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python数据分析学习总结]]></title>
      <url>/p/79vm5/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>numpy</p>
<p>matlab.pyplot</p>
<p>pandas</p>
<p>sklearn</p>
]]></content>
      
        
        <tags>
            
            <tag> python数据分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建hive环境]]></title>
      <url>/p/79vkf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[刷题总结]]></title>
      <url>/p/79va2/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.nowcoder.com/activity/oj" target="_blank" rel="noopener">刷题网址1 牛客网</a><br><a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a><br><a href="https://www.patest.cn/" target="_blank" rel="noopener">PAT 计算机程序设计能力考试</a><br><a href="https://pintia.cn/problem-sets?tab=0" target="_blank" rel="noopener">https://pintia.cn/problem-sets?tab=0</a><br>python:<br>os模块<br>os.rename()<br>os.listdir()<br>os.chgdir()<br>os.<br>map(int,input())</p>
<p>list(set(s1+s2))</p>
<p>lambda表达式</p>
<p>filter(lambda:x,)</p>
<p>列表推导式，字典推导式</p>
<p>enumerate</p>
<p>zip</p>
<p>re模块</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"> </span><br><span class="line"><span class="built_in">string</span>, k = input(), int(input())</span><br><span class="line">arr = sorted(Counter(<span class="built_in">string</span>).<span class="built_in">values</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    arr[-<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">    arr.<span class="built_in">sort</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">lambda</span> c: c ** <span class="number">2</span>, arr)))</span><br></pre></td></tr></table></figure>
<p>sorted(    key=    )             reverse=True</p>
<p>java:</p>
<p>map的遍历<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种 普遍使用,二次取值 通过Map.keySet遍历key和value： </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">key</span>:<span class="built_in">map</span>.keySet())&#123; </span><br><span class="line">  System.out.<span class="built_in">println</span>(<span class="built_in">key</span>+<span class="string">"/"</span>+<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>)); </span><br><span class="line">  &#125; </span><br><span class="line">  System.out.<span class="built_in">println</span>(<span class="string">"---------------------------------"</span>); </span><br><span class="line">  <span class="comment">//第四种 通过Map.values()遍历所有的value，但不能遍历key </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">String</span> v:<span class="built_in">map</span>.values())&#123; </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"value:"</span>+v); </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"---------------------------------"</span>); </span><br><span class="line">    <span class="comment">//第二种遍历方法 推荐，尤其是容量大时 </span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; entry:<span class="built_in">map</span>.entrySet())&#123; </span><br><span class="line">      System.out.<span class="built_in">println</span>(entry.getKey()+<span class="string">"/"</span>+entry.getValue()); </span><br><span class="line">      &#125; </span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"---------------------------------"</span>); </span><br><span class="line">      <span class="comment">//第一种遍历方法 </span></span><br><span class="line">      Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="built_in">map</span>.keySet(); </span><br><span class="line">      Iterator&lt;<span class="keyword">String</span>&gt; it = <span class="built_in">set</span>.iterator(); </span><br><span class="line">      <span class="keyword">while</span>(it.hasNext())&#123; </span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = it.next(); </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>+<span class="string">"/"</span>+<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">str</span>)); </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>TreeSet和TreeMap可实现字典序</p>
<p>java字符串比较大小<br>···<br>String s1 = “abc”;<br>String s2 = “abcd”;<br>String s3 = “abcdfg”;<br>String s4 = “1bcdfg”;<br>String s5 = “cdfg”;<br>System.out.println( s1.compareTo(s2) ); // -1 (前面相等,s1长度小1)<br>System.out.println( s1.compareTo(s3) ); // -3 (前面相等,s1长度小3)<br>System.out.println( s1.compareTo(s4) ); // 48 (“a”的ASCII码是97,”1”的的ASCII码是49,所以返回48)<br>System.out.println( s1.compareTo(s5) ); // -2 (“a”的ASCII码是97,”c”的ASCII码是99,所以返回-2)<br>···</p>
<p>LinkedList</p>
<p>pop</p>
<p>push</p>
<p>Arrays.fill()   可用于数组初始化</p>
<p>PriorityQueue</p>
<p>c++:</p>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits stdc++.h></bits></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<vector></vector></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include"></a>include<iostrem></iostrem></h1><p>using namespace std;</p>
<p>int main(){<br>    int n;<br>    cin&gt;&gt;n;<br>    int sum=0;<br>    while(n!=1){<br>        if(n%2==0){<br>           n/=2;<br>        }else{<br>            n=(3*n+1)/2;<br>        }<br>        sum++;<br>    }<br>    cout&lt;&lt;sum&lt;&lt;endl;<br>    return 0;<br>}</p>
<p>A B<br>B C<br>C D<br>D E<br>E F<br>C E<br>F A<br>G F<br>A G</p>
]]></content>
      
        
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[黑苹果安装教程]]></title>
      <url>/p/79ujx/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>步骤<br>1.分出一个mac盘  大小60G左右 </p>
<pre><code>如果你只是看视频 之类的差不多了 如果其他的就多点
==mac 下你别想下游戏玩 


我这里分出120G  分出来时黑色的 我们先不管它 

有些步骤和大佬视频不同 也有补充
</code></pre><p>2.下载efi  可以找有自己电脑型号的 也可以下载通用的 </p>
<p>   我们用的工具也就这3个  还有你下载的eif<br>   工具等下我会打包<br>   我们先打开第一个 </p>
<p>   重点 这里有一个esp 网上说这个盘时要大于200m<br>   因为要抹盘  不过我们的方式时不用的<br>   为了安全最好也分给他200m以上  具体分盘大家百度哦<br>   双击   进去 看到EFI 在双击<br>   把大家下载好的efi 放进去<br>   复制clover</p>
<p>3.复制好后 我们打开第3个软件<br>  选择新建 类型其他系统 s输入大家喜欢的名字<br>  选择刚刚的200m esp  添加这个文件<br>  选择第一个按扭把clover反到第一个</p>
<p>  不行 这里看不到我的盘<br>  那我们换一个步骤 </p>
<p> 4.写入镜像<br>   打开我们的第二个软件<br>   这里我们还得去下载镜像的<br>   镜像分为 原版和懒人版<br>   正版是dmg 懒人的cdr格式<br>   找到我们分区来的mac  右键选择第一个<br>   手动 转错了 操 再来一次 这里等等<br>   看到这里 apple hfs<br>   就说明成功了 那我们直接先写入镜像<br>   这里我们就要去下载镜像<br>   这里是真大佬<br>   <a href="https://blog.daliansky.net/" target="_blank" rel="noopener"></a><br>   去下载<br>   下载好了后 我们选择mac盘 右键 选择第3个<br>   这里我们点击蓝色的  选择镜像<br>   淘宝的是有密码的<br>   小斌下载的应该没有  点击ok 然后点击restore<br>   我这边就用淘宝的恢复盘 拉到最大<br>   然后等下好久呢<br>   这个写好后<br>   就是最后一步 设置磁盘id了<br>   黑苹果安装容易 驱动最要人命的<br>   ==所以 要安装的 要付出很大的代价<br>   mac用来做开发很好的 特别是它的显示效果<br>   大家可以快进下<br>   好了 我们关闭软件<br>   去cmd</p>
<p>5.设置磁盘id<br>  这里就是需要用到我们的cmd工具<br>  现在可以看到我们的mac盘了 我们写入id</p>
<p>  我们现在重启电脑<br>  ==卡 开机的时候有选择<br>  这界面回根据不同的efi不一样 显示不一样<br>  说白了 就是皮肤<br>  然后选择苹果 回车 就可以进去了 </p>
<p>  进去后回安装系统<br>  选择碰到 收集信息的时候选择 不收集<br>  登入id 的时候 选择先不登入 就好了 </p>
<p>  diskpart<br>list disk                              —- 列出当前系统所有的磁盘，根据磁盘大小记下要安装的磁盘的编号<br>select disk 0                       —- 选择磁盘，0是磁盘编号，换成你自己实际的编号</p>
<p>挂载efi分区步骤：<br>1   list vol</p>
<p>2   select vol 2</p>
<p>3   assign letter=M</p>
<p>list partition                        —- 列出选择的磁盘上的分区，根据分区位置和大小记下要安装mac的分区<br>select partition 4（看后面解释）                 —- 选择分区， 4是要安装的分区的编号。<br>set id=48465300-0000-11AA-AA11-00306543ECAC                            —- 48465300-0000-11AA-AA11-00306543ECAC为苹果HFS+类型的GUID</p>
]]></content>
      
        
        <tags>
            
            <tag> 黑苹果 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[校园的一些网址]]></title>
      <url>/p/79s5x/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>成绩:uims.jlu.edu.cn<br>创新实践：ptms.jlu.edu.cn<br>一卡通：dsf.jlu.edu.cn<br>校园网：ip.jlu.edu.cn<br>sais系统：<a href="https://sais.jlu.edu.cn" target="_blank" rel="noopener">https://sais.jlu.edu.cn</a><br>账号：学号<br>密码：#+（身份证号）</p>
<p>研究生网站：<a href="http://gim.jlu.edu.cn" target="_blank" rel="noopener">http://gim.jlu.edu.cn</a></p>
<p>智慧团建  <a href="https://zhtj.youth.cn/zhtj" target="_blank" rel="noopener">https://zhtj.youth.cn/zhtj</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 校园 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[黑苹果需要做的事情]]></title>
      <url>/p/79r53/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>显卡驱动hd5500<br>三种方法<br>1 改bios dvmt 值为128m<br>2 驱动broadwell<br>3 </li>
<li><p>声卡驱动<br>显卡驱动后做的事情</p>
</li>
<li><p>添加Ubuntu到clover启动项中<br>加exfat.efi到 clover目录下的driversUEFI64下</p>
</li>
</ul>
<p>-亮度驱动 调节<br>-电源驱动</p>
]]></content>
      
        
        <tags>
            
            <tag> 黑苹果系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngrok设置服务器外网访问]]></title>
      <url>/p/79cqj/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Bash<br>dash<br>zsh</p>
<h1 id="可以把实验室服务器上的80端口-即gitlab映射出来"><a href="#可以把实验室服务器上的80端口-即gitlab映射出来" class="headerlink" title="可以把实验室服务器上的80端口 即gitlab映射出来"></a>可以把实验室服务器上的80端口 即gitlab映射出来</h1><h1 id="用这种方法可以将其他端口-如jupyter-notebook映射出来"><a href="#用这种方法可以将其他端口-如jupyter-notebook映射出来" class="headerlink" title="用这种方法可以将其他端口 如jupyter notebook映射出来"></a>用这种方法可以将其他端口 如jupyter notebook映射出来</h1><p>./ngrok -config=ngrok.cfg -subdomain xxx 80</p>
<h1 id="通过ssh外网访问"><a href="#通过ssh外网访问" class="headerlink" title="通过ssh外网访问"></a>通过ssh外网访问</h1><p>./ngrok -config=ngrok.cfg -proto=tcp 22<br>ssh -p 端口 username@0.tcp.ngrok.ibanzhuan.cn</p>
<p>scp -r  ./linux64 zhangxuefeng@192.168.3.234:/home/zhangxuefeng</p>
<p>nohup</p>
<ul>
<li><p>ubuntu安装软件命令<br>sudo  apt-get install foo<br>dpkg -i <em>.deb<br>wget http://</em></p>
</li>
<li><p>ubuntu卸载软件命令<br>sudo apt-get —purge remove foo<br>sudo  apt-get remove  foo</p>
</li>
</ul>
<p>解决依赖问题<br>sudo apt-get install -f</p>
<p>创建conda虚拟环境<br>conda create -n name python=3.5</p>
<p>进入环境<br>source activate test<br>退出环境<br>source deactivate</p>
<p>删除环境：<br>conda remove —name env_pytorch —all</p>
<p>检查cuda版本<br>cat /usr/local/cuda/version.txt</p>
<p>conda install tensorflow-gpu=1.8.0</p>
<p>安装opencv</p>
<p>conda install —channel <a href="https://conda.anaconda.org/menpo" target="_blank" rel="noopener">https://conda.anaconda.org/menpo</a> opencv3</p>
<blockquote>
<p>Anaconda安装Pytorch         （还没成功 还要再尝试）<br>添加Anaconda的TUNA镜像<br>  conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>设置搜索时显示通道地址<br>  conda config —set show_channel_urls yes</p>
</blockquote>
<p>  conda install pytorch torchvision -c soumith</p>
<p><a href="https://www.jianshu.com/p/8fc3cd032d3c" target="_blank" rel="noopener">远程访问服务器Jupyter Notebook的方法</a></p>
<p>查看已安装的conda环境<br>conda info -e</p>
<p>学习IDEA配置maven</p>
<p>配置大数据环境</p>
<p>kali linux 渗透测试系统 </p>
<p>黑客教程 腾讯课堂</p>
<p>关于jupyter notebook的一些事情</p>
<p>装插件<br>python3.7 -m pip install jupyter_contrib_nbextensions</p>
<p>import sys<br>print(sys.executable)</p>
<p>装有关内核的东西<br>pip install ipykernel —user</p>
<p>python -m ipykernel install —user</p>
<p>pip install —upgrade pip<br>&lt;!—<br>将当前环境加入内核     这是系统的环境<br>sudo python3.5 -m ipykernel install —name tf_python3.5</p>
<p>将我自己的环境加入方法</p>
<p>先看anaconda环境<br>conda info -e</p>
<h1 id="conda-environments"><a href="#conda-environments" class="headerlink" title="conda environments:"></a>conda environments:</h1><p>#<br>base                     /home/zhangxuefeng/anaconda3<br>tf_python3            *  /home/zhangxuefeng/anaconda3/envs/tf_python3</p>
<p>再用下面的命令 —&gt;</p>
<p>conda install nb_conda</p>
<p>source ~/.bashrc</p>
<p>安装pytorch<br><a href="https://pytorch.org/" target="_blank" rel="noopener">pytorch官网</a></p>
<p>conda install pytorch torchvision cudatoolkit=9.0 -c pytorch</p>
<p>换源<br>conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</a><br>conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>conda config —set show_channel_urls yes</p>
<p>conda config —prepend channels <a href="http://mirrors.ustc.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/anaconda/pkgs/free/</a></p>
<p>win10关机后自动重启解决办法</p>
<p>关机后电脑自动重启解决办法： </p>
<ul>
<li>开始/运行/输入 regedit 回车，打开注册表编辑器，依次展开[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Window NT\Currentversion\Winlgon] 然后在右侧新建或修改已有的一个名称为＂PowerdownAfterShutdown＂的字符串值,其值＂1＂表示关机时关闭计算机电源,0表示重新启动电脑。　 </li>
<li>如果是因为网络唤醒引起的，双击本地连接选属性/配置/高级/在左侧选关机网络唤醒，在右侧选关闭确定。</li>
</ul>
<p>pip install -r requirements.txt</p>
<p>方法1 在python程序中</p>
<p>import os<br>os.environ[“CUDA_VISIBLE_DEVICES”] = “1”<br> 方法2，运行时 </p>
<p>CUDA_VISIBLE_DEVICES=1 python   **.py</p>
<p>conda install cudatoolkit=9.0</p>
<h1 id="Anaconda-安装pygame"><a href="#Anaconda-安装pygame" class="headerlink" title="Anaconda 安装pygame"></a>Anaconda 安装pygame</h1><p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a> pygame</p>
]]></content>
      
        
        <tags>
            
            <tag> ngrok内网穿透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[matlab知识]]></title>
      <url>/p/795o6/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="uint8-uint16-matlab"><a href="#uint8-uint16-matlab" class="headerlink" title="uint8 uint16 matlab"></a>uint8 uint16 matlab</h1><p>四舍五入   转化为 0~255之间的整数ss<br>四舍五入   转为0~65535之间的整数</p>
<p>db4 小波基</p>
]]></content>
      
        <categories>
            
            <category> matlab编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> matlab编程 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python爬虫总结]]></title>
      <url>/p/792hn/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis总结]]></title>
      <url>/p/792hn/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[maven学习]]></title>
      <url>/p/792hl/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IntellIJ IDEA 配置 Maven 以及 修改 默认 Repository</p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop环境搭建]]></title>
      <url>/p/792hl/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>三大发行版：apache</p>
<p>三种运行模式<br>单机<br>伪分布式<br>分布式</p>
<p>结构化数据 半结构化数据 非结构化数据<br>HDFS存储<br>HDFS以流式数据访问模式来存储超大文件<br>HDFS块设置<br>要足够大 将寻址时间减少 数据传输时间占比更大<br>也不能太大 map任务并行速度会慢</p>
<p>数据容错和可用性<br>FileSystem类<br>文件系统的一致模型</p>
<p>命令行<br>hadoop fs </p>
<p>mapreduce分析处理</p>
<p>两个阶段 map阶段和reduce阶段    键值对作为输入和输出<br>两个函数  map函数和reduce函数</p>
<p>输入分片</p>
<p>jobtracker  tasktracker</p>
<p>namenode datanode</p>
<p>50070   HDFS      8020<br>8088    yarn<br>map任务将输出写入本地磁盘</p>
<p>combiner 合并函数  一种优化方案 对map输出进行处理 作为reduce的输入 无法确定其次数</p>
<p>RAID 冗余磁盘阵列</p>
<p>搭建虚拟机</p>
<p>指定虚拟机固定ip</p>
<p>安装eclipse</p>
<p>zookeeper 协调服务</p>
<p>leader选举<br>znode</p>
<p>posix 可移植操作系统界面</p>
<p>sqoop</p>
<p>Oozie</p>
<p>Hue</p>
<p>Hadoop I/O</p>
]]></content>
      
        
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux]]></title>
      <url>/p/792hk/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="打开Google浏览器"><a href="#打开Google浏览器" class="headerlink" title="打开Google浏览器"></a>打开Google浏览器</h1><p>/usr/bin/google-chrome-stable</p>
<h1 id="Ubuntu装搜狗输入法"><a href="#Ubuntu装搜狗输入法" class="headerlink" title="Ubuntu装搜狗输入法"></a>Ubuntu装搜狗输入法</h1><p>需要重启 界面操作 放弃</p>
<h1 id="在Ubuntu上安装PPTP-VPN服务"><a href="#在Ubuntu上安装PPTP-VPN服务" class="headerlink" title="在Ubuntu上安装PPTP VPN服务"></a>在Ubuntu上安装PPTP VPN服务</h1><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>sudo apt —purge remove teamviewer</p>
<p><a href="http://man.linuxde.net/" target="_blank" rel="noopener">linux命令大全</a></p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[英语翻译]]></title>
      <url>/p/791ia/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>练习：打草稿，写   逐句翻译（采用技巧 长句拆解 短句合并 定语后置 对难词解释等）<br>主题词汇<br>表达【句式 语法  句子之间连接（从句  连词）】</p>
<h1 id="翻译技巧（9个）"><a href="#翻译技巧（9个）" class="headerlink" title="翻译技巧（9个）"></a>翻译技巧（9个）</h1><h2 id="1-了解中英文区别，避免机械对等翻译"><a href="#1-了解中英文区别，避免机械对等翻译" class="headerlink" title="1 了解中英文区别，避免机械对等翻译"></a>1 了解中英文区别，避免机械对等翻译</h2><p>定语后置<br>上海的天气  the weather in Shanghai</p>
<h2 id="2-从动词入手理清句子主干，确定修饰成分"><a href="#2-从动词入手理清句子主干，确定修饰成分" class="headerlink" title="2 从动词入手理清句子主干，确定修饰成分"></a>2 从动词入手理清句子主干，确定修饰成分</h2><h2 id="3-如何确定词态"><a href="#3-如何确定词态" class="headerlink" title="3 如何确定词态"></a>3 如何确定词态</h2><p>时间/频率<br>总是，经常  每年 目前 如今 一般现在时<br>在….年，在宋代   一般过去时<br>到目前为止 已经  了  过 （改变了 提高了 去过）现在完成时</p>
<p>副词 助词   正  着 现在进行时</p>
<p>根据语篇题材确定时态<br>历史   过去时<br>文化   过去时  现在时<br>经济/社会发展  现在时</p>
<h2 id="4-根据语境及搭配选择用词"><a href="#4-根据语境及搭配选择用词" class="headerlink" title="4 根据语境及搭配选择用词"></a>4 根据语境及搭配选择用词</h2><p>big/heavy/great/large</p>
<h2 id="5-巧妙处理难词"><a href="#5-巧妙处理难词" class="headerlink" title="5 巧妙处理难词"></a>5 巧妙处理难词</h2><p>1 同/近义词<br>2用解释的方法</p>
<h2 id="6-根据篇章逻辑，相应增词或减词"><a href="#6-根据篇章逻辑，相应增词或减词" class="headerlink" title="6 根据篇章逻辑，相应增词或减词"></a>6 根据篇章逻辑，相应增词或减词</h2><h2 id="7-长句拆译，短句合译"><a href="#7-长句拆译，短句合译" class="headerlink" title="7 长句拆译，短句合译"></a>7 长句拆译，短句合译</h2><h2 id="8-语态转换"><a href="#8-语态转换" class="headerlink" title="8 语态转换"></a>8 语态转换</h2><p>1没有被动标记词的被动句<br>2汉语无主语句<br>3 直接翻译在英文出现头重脚轻，用被动语态</p>
<h2 id="9-调整语序"><a href="#9-调整语序" class="headerlink" title="9 调整语序"></a>9 调整语序</h2><h1 id="汉译英主题词汇"><a href="#汉译英主题词汇" class="headerlink" title="汉译英主题词汇"></a>汉译英主题词汇</h1><h2 id="1-传统文化"><a href="#1-传统文化" class="headerlink" title="1 传统文化"></a>1 传统文化</h2><h2 id="2-传统节日"><a href="#2-传统节日" class="headerlink" title="2 传统节日"></a>2 传统节日</h2><h2 id="3-民间艺术"><a href="#3-民间艺术" class="headerlink" title="3 民间艺术"></a>3 民间艺术</h2><h2 id="4-中餐及烹饪方法"><a href="#4-中餐及烹饪方法" class="headerlink" title="4 中餐及烹饪方法"></a>4 中餐及烹饪方法</h2><h2 id="5-中国历史"><a href="#5-中国历史" class="headerlink" title="5 中国历史"></a>5 中国历史</h2><h2 id="6-商业经济"><a href="#6-商业经济" class="headerlink" title="6 商业经济"></a>6 商业经济</h2><h2 id="7-旅游地理"><a href="#7-旅游地理" class="headerlink" title="7 旅游地理"></a>7 旅游地理</h2><h2 id="8-环境灾害"><a href="#8-环境灾害" class="headerlink" title="8 环境灾害"></a>8 环境灾害</h2><h2 id="9-教育"><a href="#9-教育" class="headerlink" title="9 教育"></a>9 教育</h2><h2 id="10-科技"><a href="#10-科技" class="headerlink" title="10 科技"></a>10 科技</h2><h2 id="11-社会生活"><a href="#11-社会生活" class="headerlink" title="11 社会生活"></a>11 社会生活</h2><h2 id="12-政策法规"><a href="#12-政策法规" class="headerlink" title="12 政策法规"></a>12 政策法规</h2><p>名词解释 （中国结 麻将）</p>
<p>人物 （诸葛亮 毛泽东）</p>
<p>风景名胜（湖泊 黄山 河流 长城）</p>
<p>现象（汉语热 ）</p>
]]></content>
      
        
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[英语听力技巧]]></title>
      <url>/p/79169/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="听时记什么-六要素-时间，地点，人物，起因，经过，结果"><a href="#听时记什么-六要素-时间，地点，人物，起因，经过，结果" class="headerlink" title="听时记什么 六要素 时间，地点，人物，起因，经过，结果"></a>听时记什么 六要素 时间，地点，人物，起因，经过，结果</h1><h1 id="看回答推测问题"><a href="#看回答推测问题" class="headerlink" title="看回答推测问题"></a>看回答推测问题</h1><p>They   某类人   问题/研究     特征   特点<br>to do  /whether 做某件事情的目的<br>时态<br>it 代指某个东西   特点、优点<br>积极/消极<br>关键词    问答形式   仔细听<br>what mainly talking about /主要谈了什么<br>接下来要做什么<br>这个男的/女的 说这个要干什么/目的是什么<br>人物、事物相关信息<br>主题<br>态度<br>数量/概率 价格 变化<br>意见/建议 结论<br>概念认知<br>影响/作用<br>地点时间</p>
<h1 id="听时预标记"><a href="#听时预标记" class="headerlink" title="听时预标记"></a>听时预标记</h1>]]></content>
      
        
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[明天要做的事情]]></title>
      <url>/p/790kb/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="买英文纸张练写字母"><a href="#买英文纸张练写字母" class="headerlink" title="买英文纸张练写字母"></a>买英文纸张练写字母</h1><h1 id="把总结与扩展的论文看了"><a href="#把总结与扩展的论文看了" class="headerlink" title="把总结与扩展的论文看了"></a>把总结与扩展的论文看了</h1><h1 id="预答辩"><a href="#预答辩" class="headerlink" title="预答辩"></a>预答辩</h1><h1 id="课外8学分"><a href="#课外8学分" class="headerlink" title="课外8学分"></a>课外8学分</h1><h1 id="2B铅笔-，橡皮，黑笔、准考证，表"><a href="#2B铅笔-，橡皮，黑笔、准考证，表" class="headerlink" title="2B铅笔 ，橡皮，黑笔、准考证，表"></a>2B铅笔 ，橡皮，黑笔、准考证，表</h1><h1 id="英语六级-2018年12月卷子-和2016年以前的卷子"><a href="#英语六级-2018年12月卷子-和2016年以前的卷子" class="headerlink" title="英语六级 2018年12月卷子 和2016年以前的卷子"></a>英语六级 2018年12月卷子 和2016年以前的卷子</h1><p><a href="https://www.jianshu.com/p/164b548519fa" target="_blank" rel="noopener">fiddler链接1</a></p>
<p><a href="https://blog.csdn.net/qq_34659777/article/details/82665183" target="_blank" rel="noopener">fiddler链接2</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 明天 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[英语作文技巧]]></title>
      <url>/p/790k6/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>how come<br>三段式<br>有人认为  另外人认为   inform of    insist<br>我认为<br>as is vividly shown<br>扩展 举例说明  对比 比较   数字说明</p>
<p>说明论点重要性</p>
<h2 id="副词修饰形容词表程度"><a href="#副词修饰形容词表程度" class="headerlink" title="副词修饰形容词表程度"></a>副词修饰形容词表程度</h2><h2 id="连词"><a href="#连词" class="headerlink" title="连词"></a>连词</h2><p>neither nor<br>either or<br>both and<br>between and<br>however<br>to begin with<br>what’s more/furthermore/in addition<br>Believe it or not<br>to sum up/all in all/in a word/last but not least<br>sincerely<br>seldom<br>therefore/thus<br>so that/in order to<br>too to<br>attach importance to/be of great importance<br>As for me/in my opinion/from my view of point<br>Nowadays<br>generally speaking<br>on the contrary<br>account for<br>at present<br>due to/owing to<br>in fact<br> Meanwhile</p>
<p> first of all<br> as    as possible</p>
<p>meantime</p>
<p>at first<br>Ultimately<br>by the way<br>eventually</p>
<p>how about 提建议<br> Worst of all<br> as a matter of fact<br> in other words</p>
<h2 id="句式"><a href="#句式" class="headerlink" title="句式"></a>句式</h2><p>only  can be<br>it  is high time 强调句<br>定语从句<br>状语从句<br>感叹句<br>条件句<br>the more  the more<br>more nad more<br>one of the most<br>比较级 more than<br>according to …… conducted by    ,a high propotion of<br>as far as i am concerned<br>mentioned above<br>what ….   is<br>there are<br>it is    for/of to do sth<br>as  known<br>as well as<br>illustrate/depict/portray</p>
<p>how did you like it?</p>
<h2 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h2>]]></content>
      
        
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图像融合]]></title>
      <url>/p/78z4w/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>低频体现轮廓，高频体现细节<br><img src="images/图像融合.jpg" alt="dwt2函数"></p>
<p><a href="http://www.docin.com/p-358189670.html" target="_blank" rel="noopener">matlab编程基本api</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第二篇博客]]></title>
      <url>/p/78uo0/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[油猴脚本]]></title>
      <url>/p/78twc/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.tampermonkey.net/" target="_blank" rel="noopener">油猴chrome下载地址</a></p>
<h1 id="油猴脚本可用于浏览器装js插件"><a href="#油猴脚本可用于浏览器装js插件" class="headerlink" title="油猴脚本可用于浏览器装js插件"></a>油猴脚本可用于浏览器装js插件</h1><p><a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">Tampermonkey脚本下载网站</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[需要做的事情]]></title>
      <url>/p/78tun/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="需要做的事情"><a href="#需要做的事情" class="headerlink" title="需要做的事情"></a>需要做的事情</h1><ul>
<li>学习制作浏览器扩展程序</li>
<li>毕设相关文件</li>
<li>跑一些tensorflow和pytorch程序</li>
<li>实现机器学习实战里的代码</li>
<li>假期继续看书，刷leetcode,牛客网，看算法数据结构,opencv,maven</li>
<li>重学数据库，操作系统，linux(包括服务器搭建)，计算机网络（HTTP,安全，私网等）,设计模式，python,matlab</li>
<li>学大数据，ssM框架，英语,js编程</li>
<li>看论文，再学一遍机器学习，深度学习</li>
<li>李航《统计学习方法 第二版》，南瓜书， 重点推导数学公式</li>
<li>学机器学习的数学基础，复习高数，线代，概率论，组合数学，离散数学，计算机图形学等</li>
<li>看完opencv和大数据的视频，跑一下人工智能视频的代码,R语言，GO语言</li>
<li>sublime,DW,VSCode,IntelliJ IDEA,photoshop,AE,PR</li>
<li>kaggle,天池,牛客竞赛，CCF CSP,PAT</li>
<li>数字图像处理，自然语言处理，推荐引擎，计算机视觉</li>
<li>自动化脚本制作，微信小程序</li>
<li>裝深度操作系統（deepin），先用虚拟机试</li>
<li>锻炼（俯卧撑，仰卧起坐，哑铃）</li>
<li>面经，笔试题</li>
<li>丰富简历</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的博客]]></title>
      <url>/p/78st7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul>
<li>一</li>
<li>二</li>
<li>三</li>
<li>四</li>
</ul>
<blockquote>
<p>引用</p>
</blockquote>
<p><img src="http://mouapp.com/Mou_128.png" alt="萌宠"><br><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<p><strong>粗体</strong></p>
<p><em>斜体</em></p>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>代码：<br>    <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main()&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello world!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{matrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 
\end{matrix} \tag{1}</script>]]></content>
      
        <categories>
            
            <category> 编程语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 首页 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
